{
  "hash": "51fb2ed050470c04a60288464508f2a4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Bulk RNA-Seq differential expression analysis and batch correction with DESeq2, limma, and sva\"\nauthor: \"Rui Yang\"\ndate: \"2025-03-02\"\ndate-modified: last-modified\ncategories: [bulk rna-seq, differential expression, batch correction, deseq2, limma, sva]\nformat:\n  html:\n    toc: true\n    toc-depth: 6\n    toc-location: left\n    fig-align: center\n    number-depth: 6\n    number-sections: true\n    fig-cap-location: bottom\n    fig-format: png\n    lightbox: true\n    tbl-cap-location: top\n    page-layout: full\n\nexecute:\n  warning: false\n  eval: false\n---\n\n\n\n\n## Introduction\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwork_dir <- \"/home/yangrui/mywd/wtt_proj\"\n\nsetwd(work_dir)\n```\n:::\n\n\n\n\n## Differential expression analysis with batch correction using DESeq2\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tximport)\nlibrary(DESeq2)\nlibrary(tidyverse)\nlibrary(vroom)\n\ninput_dir <- \"transcriptome/rsem_gene_results\"\noutput_dir <- \"transcriptome/merged_degs\"\nsample_file <- \"transcriptome/rsem_gene_results/genes.sample_sheet.merged.tsv\"\nmpt_file <- \"/data/biodatabase/species/mRatBN7/genome/anno/Rattus_norvegicus.mRatBN7.2.111.gff3.gz.gene_id_name_mapping_table.tsv\"\ntpm_file <- \"transcriptome/extracted_rsem_gene_results/gene.TPM.tsv.tsv\"\npadj_th <- 0.05\nlogfc_th <- 1\ntpm_th <- 1\n\ndir.create(output_dir, recursive = FALSE)\n\nfile_df <- tibble(\n    file = list.files(input_dir, pattern = \"_rsem\\\\.genes\\\\.results$\", full.names = TRUE, recursive = FALSE),\n    basename = basename(file)\n)\nsample_df <- vroom(sample_file) %>%\n    inner_join(file_df, by = \"basename\") %>%\n    mutate(\n        condition = factor(condition),\n        batch = factor(batch)\n    )\ntx.rsem <- tximport(\n    setNames(sample_df[[\"file\"]], sample_df[[\"sample\"]]),\n    type = \"rsem\", txIn = FALSE, txOut = FALSE\n)\n\n# filter out genes with lengths <= 0\nnon_zero_length <- apply(tx.rsem$length, 1, function(x) {\n    all(x > 0)\n})\n\ntx.rsem$abundance <- tx.rsem$abundance[non_zero_length, ]\ntx.rsem$counts <- tx.rsem$counts[non_zero_length, ]\ntx.rsem$length <- tx.rsem$length[non_zero_length, ]\n\n# create DESeqDatatSet\nddsTxi <- DESeqDataSetFromTximport(\n    txi = tx.rsem,\n    colData = sample_df,\n    design = ~ batch + condition\n)\n\n# keep rows that have at least N reads in total (this is just a simple filtering process and is optional)\nkeep <- rowSums(counts(ddsTxi)) >= 10\nddsTxi <- ddsTxi[keep, ]\n\ncondition_levels <- levels(sample_df[[\"condition\"]])\nde_ls <- list(raw = list(), na_filter = list(), unique_symbols = list(), only_degs = list())\nfor (ref in condition_levels) {\n    compara_levels <- c(ref, condition_levels[-which(condition_levels == ref)])\n\n    message(paste0(\"\\n\\nLevels: \", paste0(compara_levels, collapse = \", \")))\n    message(\"Baseline: \", ref, \"\\n\")\n\n    # set the reference sample\n    ddsTxi$condition <- factor(ddsTxi$condition, levels = compara_levels)\n    # DE analysis\n    ddsTxi <- DESeq(ddsTxi)\n\n    # get results table\n    res_tabs <- resultsNames(ddsTxi)\n    res_tabs <- res_tabs[str_detect(res_tabs, \"^condition_\")]\n    message(\"\\n\", paste0(res_tabs, collapse = \", \"))\n\n    # save pairwise comparisons\n    for (pair in res_tabs) {\n        res <- results(ddsTxi, name = pair)\n        res <- as.data.frame(res)\n        res[[\"gene_id\"]] <- row.names(res)\n        res[[\"pvalue\"]][res[[\"pvalue\"]] == 0] <- .Machine[[\"double.xmin\"]]\n        res[[\"padj\"]][res[[\"padj\"]] == 0] <- .Machine[[\"double.xmin\"]]\n        de_ls[[\"raw\"]][[gsub(\"^condition_\", \"\", pair)]] <- as_tibble(res)\n    }\n}\n\n# attach gene info\nmpt <- vroom(mpt_file)\nfor (pair in names(de_ls[[\"raw\"]])) {\n    de_ls[[\"raw\"]][[pair]] <- inner_join(mpt, de_ls[[\"raw\"]][[pair]],\n        by = \"gene_id\"\n    )\n}\n\n# filter rows containing NAs\nfor (pair in names(de_ls[[\"raw\"]])) {\n    pairs <- str_split(pair, fixed(\"_vs_\"))[[1]]\n    de_ls[[\"na_filter\"]][[pair]] <- de_ls[[\"raw\"]][[pair]] %>%\n        filter(!(is.na(baseMean) | is.na(log2FoldChange) | is.na(pvalue) | is.na(padj))) %>%\n        mutate(diff_flag = if_else(padj < padj_th,\n            if_else(abs(log2FoldChange) > logfc_th,\n                if_else(log2FoldChange > logfc_th,\n                    paste0(pairs[1], \" Up\"),\n                    paste0(pairs[2], \" Up\")\n                ),\n                \"NO\"\n            ),\n            \"NO\"\n        ))\n}\n\n# filter duplicated gene symbols\ntpm <- vroom(tpm_file)\nfor (pair in names(de_ls[[\"na_filter\"]])) {\n    # filtered by TPMs\n    pairs <- str_split(pair, fixed(\"_vs_\"))[[1]]\n    flag <- rep(FALSE, nrow(tpm))\n    for (s in pairs) {\n        tmp_df <- tpm[, filter(sample_df, condition == s) %>% pull(sample) %>% unique()]\n        if (ncol(tmp_df) == 0) {\n            stop(\"sample columns in TPM are not matched with those used to perform DE analysis\")\n        }\n        flag <- flag | (rowSums(tmp_df > tpm_th) == ncol(tmp_df))\n    }\n    tmp_df <- de_ls[[\"na_filter\"]][[pair]] %>%\n        filter(gene_id %in% tpm[[\"gene_id\"]][flag]) %>%\n        mutate(gene_name = if_else(is.na(gene_name), gene_id, gene_name))\n\n    # filtered by gene versions\n    if (\"gene_version\" %in% names(tmp_df)) {\n        tmp_df <- tmp_df %>%\n            group_by(gene_name) %>%\n            slice_max(gene_version) %>%\n            ungroup()\n    }\n\n    # filtered by baseMean, padj, log2FoldChange\n    # if still duplicated, sample one randomly\n    de_ls[[\"unique_symbols\"]][[pair]] <- tmp_df %>%\n        group_by(gene_name) %>%\n        slice_max(baseMean) %>%\n        slice_min(padj) %>%\n        slice_max(log2FoldChange) %>%\n        slice_sample(n = 1) %>%\n        ungroup()\n}\n\n# keep only DEGs\nfor (pair in names(de_ls[[\"unique_symbols\"]])) {\n    de_ls[[\"only_degs\"]][[pair]] <- de_ls[[\"unique_symbols\"]][[pair]] %>%\n        filter(diff_flag != \"NO\")\n}\n\n# save results to files\nfor (category in names(de_ls)) {\n    dir.create(file.path(output_dir, category), recursive = FALSE)\n    for (pair in names(de_ls[[category]])) {\n        vroom_write(de_ls[[category]][[pair]], file = file.path(file.path(output_dir, category), paste0(pair, \".tsv\")))\n    }\n}\n```\n:::\n\n\n\n\n## Batch correction using limma\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(limma)\nlibrary(vroom)\nlibrary(tidyverse)\nlibrary(magrittr)\nlibrary(FactoMineR)\nlibrary(ggforce)\nlibrary(ggrepel)\nlibrary(ggprism)\nlibrary(YRUtils)\n\ntpm_file <- \"transcriptome/extracted_rsem_gene_results/gene.TPM.tsv.tsv\"\nsample_file <- \"transcriptome/rsem_gene_results/genes.sample_sheet.merged.tsv\"\noutput_dir <- \"transcriptome/limma_batch_corrected\"\ntpm_th <- 1\n\ndir.create(output_dir, recursive = FALSE)\n\nsample_df <- vroom(sample_file) %>%\n    mutate(\n        condition = factor(condition),\n        batch = factor(batch)\n    )\ntpm <- vroom(tpm_file) %>%\n    select(all_of(c(\"gene_id\", sample_df[[\"sample\"]]))) %>%\n    as.data.frame() %>%\n    set_rownames(.[[\"gene_id\"]]) %>%\n    select(-gene_id)\nflag <- rep(FALSE, nrow(tpm))\nfor (g in unique(sample_df[[\"group\"]])) {\n    tmp_df <- tpm[, filter(sample_df, group == g) %>% pull(sample) %>% unique()]\n    if (ncol(tmp_df) == 0) {\n        stop(\"sample columns in TPM are not matched with those used to perform DE analysis\")\n    }\n    flag <- flag | (rowSums(tmp_df > tpm_th) == ncol(tmp_df))\n}\ntpm <- tpm[flag, ]\ntpm <- log(tpm + 1)\n\ntpm_corrected <- removeBatchEffect(tpm, batch = sample_df[[\"batch\"]], group = sample_df[[\"condition\"]])\n\nvroom_write(\n    tpm %>% mutate(gene_id = row.names(.)) %>% as_tibble(),\n    file = file.path(output_dir, \"tpm.th1_log1p.tsv\")\n)\nvroom_write(\n    tpm_corrected %>% as.data.frame() %>% mutate(gene_id = row.names(.)) %>% as_tibble(),\n    file = file.path(output_dir, \"tpm.th1_log1p.batch_corrected.tsv\")\n)\n\n# uncorrected\npca <- PCA(t(tpm), ncp = 10, scale.unit = TRUE, graph = FALSE)\n\npca_coord <- as.data.frame(pca$ind$coord)\npca_coord$sample <- row.names(pca_coord)\npca_coord <- inner_join(pca_coord, sample_df, by = \"sample\")\npca_eig <- as.data.frame(pca$eig)\n\np <- ggplot(pca_coord, aes(Dim.1, Dim.2)) +\n    geom_point(aes(color = group), size = 2) +\n    geom_text_repel(aes(label = sample),\n        size = 5, max.overlaps = 10000,\n        min.segment.length = 3,\n        family = \"Arial\"\n    ) +\n    xlab(paste0(\n        \"PC1 (\",\n        round(pca_eig[\"comp 1\", \"percentage of variance\"]),\n        \"%)\"\n    )) +\n    ylab(paste0(\n        \"PC2 (\",\n        round(pca_eig[\"comp 2\", \"percentage of variance\"]),\n        \"%)\"\n    ))\np <- p + geom_mark_ellipse(aes(fill = group), color = NA, alpha = 0.25)\np <- p + theme_prism(border = TRUE, base_family = \"Arial\", base_size = 16) +\n    theme(legend.title = element_text())\nppreview(p, file = file.path(output_dir, \"pca.uncorrected.pdf\"))\n\n# batch-corrected\npca_corrected <- PCA(t(tpm_corrected), ncp = 10, scale.unit = TRUE, graph = FALSE)\n\npca_coord_corrected <- as.data.frame(pca_corrected$ind$coord)\npca_coord_corrected$sample <- row.names(pca_coord_corrected)\npca_coord_corrected <- inner_join(pca_coord_corrected, sample_df, by = \"sample\")\npca_eig_corrected <- as.data.frame(pca_corrected$eig)\n\np <- ggplot(pca_coord_corrected, aes(Dim.1, Dim.2)) +\n    geom_point(aes(color = group), size = 2) +\n    geom_text_repel(aes(label = sample),\n        size = 5, max.overlaps = 10000,\n        min.segment.length = 3,\n        family = \"Arial\"\n    ) +\n    xlab(paste0(\n        \"PC1 (\",\n        round(pca_eig_corrected[\"comp 1\", \"percentage of variance\"]),\n        \"%)\"\n    )) +\n    ylab(paste0(\n        \"PC2 (\",\n        round(pca_eig_corrected[\"comp 2\", \"percentage of variance\"]),\n        \"%)\"\n    ))\np <- p + geom_mark_ellipse(aes(fill = group), color = NA, alpha = 0.25)\np <- p + theme_prism(border = TRUE, base_family = \"Arial\", base_size = 16) +\n    theme(legend.title = element_text())\nppreview(p, file = file.path(output_dir, \"pca.batch_corrected.pdf\"))\n```\n:::\n\n\n\n\n## Batch correction using sva\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sva)\nlibrary(vroom)\nlibrary(tidyverse)\nlibrary(magrittr)\nlibrary(FactoMineR)\nlibrary(ggforce)\nlibrary(ggrepel)\nlibrary(ggprism)\nlibrary(YRUtils)\n\ntpm_file <- \"transcriptome/extracted_rsem_gene_results/gene.TPM.tsv.tsv\"\nsample_file <- \"transcriptome/rsem_gene_results/genes.sample_sheet.merged.tsv\"\noutput_dir <- \"transcriptome/sva_batch_corrected\"\ntpm_th <- 1\n\ndir.create(output_dir, recursive = FALSE)\n\nsample_df <- vroom(sample_file) %>%\n    mutate(\n        condition = factor(condition),\n        batch = factor(batch)\n    )\ntpm <- vroom(tpm_file) %>%\n    select(all_of(c(\"gene_id\", sample_df[[\"sample\"]]))) %>%\n    as.data.frame() %>%\n    set_rownames(.[[\"gene_id\"]]) %>%\n    select(-gene_id)\nflag <- rep(FALSE, nrow(tpm))\nfor (g in unique(sample_df[[\"group\"]])) {\n    tmp_df <- tpm[, filter(sample_df, group == g) %>% pull(sample) %>% unique()]\n    if (ncol(tmp_df) == 0) {\n        stop(\"sample columns in TPM are not matched with those used to perform DE analysis\")\n    }\n    flag <- flag | (rowSums(tmp_df > tpm_th) == ncol(tmp_df))\n}\ntpm <- tpm[flag, ]\ntpm <- log(tpm + 1)\n\nbatch <- sample_df$batch\nmod <- model.matrix(~condition, data = sample_df)\ntpm_corrected <- ComBat(tpm, batch = batch, mod = mod)\n\nvroom_write(\n    tpm %>% mutate(gene_id = row.names(.)) %>% as_tibble(),\n    file = file.path(output_dir, \"tpm.th1_log1p.tsv\")\n)\nvroom_write(\n    tpm_corrected %>% as.data.frame() %>% mutate(gene_id = row.names(.)) %>% as_tibble(),\n    file = file.path(output_dir, \"tpm.th1_log1p.batch_corrected.tsv\")\n)\n\n# uncorrected\npca <- PCA(t(tpm), ncp = 10, scale.unit = TRUE, graph = FALSE)\n\npca_coord <- as.data.frame(pca$ind$coord)\npca_coord$sample <- row.names(pca_coord)\npca_coord <- inner_join(pca_coord, sample_df, by = \"sample\")\npca_eig <- as.data.frame(pca$eig)\n\np <- ggplot(pca_coord, aes(Dim.1, Dim.2)) +\n    geom_point(aes(color = group), size = 2) +\n    geom_text_repel(aes(label = sample),\n        size = 5, max.overlaps = 10000,\n        min.segment.length = 3,\n        family = \"Arial\"\n    ) +\n    xlab(paste0(\n        \"PC1 (\",\n        round(pca_eig[\"comp 1\", \"percentage of variance\"]),\n        \"%)\"\n    )) +\n    ylab(paste0(\n        \"PC2 (\",\n        round(pca_eig[\"comp 2\", \"percentage of variance\"]),\n        \"%)\"\n    ))\np <- p + geom_mark_ellipse(aes(fill = group), color = NA, alpha = 0.25)\np <- p + theme_prism(border = TRUE, base_family = \"Arial\", base_size = 16) +\n    theme(legend.title = element_text())\nppreview(p, file = file.path(output_dir, \"pca.uncorrected.pdf\"))\n\n# batch-corrected\npca_corrected <- PCA(t(tpm_corrected), ncp = 10, scale.unit = TRUE, graph = FALSE)\n\npca_coord_corrected <- as.data.frame(pca_corrected$ind$coord)\npca_coord_corrected$sample <- row.names(pca_coord_corrected)\npca_coord_corrected <- inner_join(pca_coord_corrected, sample_df, by = \"sample\")\npca_eig_corrected <- as.data.frame(pca_corrected$eig)\n\np <- ggplot(pca_coord_corrected, aes(Dim.1, Dim.2)) +\n    geom_point(aes(color = group), size = 2) +\n    geom_text_repel(aes(label = sample),\n        size = 5, max.overlaps = 10000,\n        min.segment.length = 3,\n        family = \"Arial\"\n    ) +\n    xlab(paste0(\n        \"PC1 (\",\n        round(pca_eig_corrected[\"comp 1\", \"percentage of variance\"]),\n        \"%)\"\n    )) +\n    ylab(paste0(\n        \"PC2 (\",\n        round(pca_eig_corrected[\"comp 2\", \"percentage of variance\"]),\n        \"%)\"\n    ))\np <- p + geom_mark_ellipse(aes(fill = group), color = NA, alpha = 0.25)\np <- p + theme_prism(border = TRUE, base_family = \"Arial\", base_size = 16) +\n    theme(legend.title = element_text())\nppreview(p, file = file.path(output_dir, \"pca.batch_corrected.pdf\"))\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
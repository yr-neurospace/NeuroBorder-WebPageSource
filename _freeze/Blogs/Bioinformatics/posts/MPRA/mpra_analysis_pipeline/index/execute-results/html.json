{
  "hash": "1c47e204f1e7a06648f30f93407d4f4d",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"MPRA analysis pipeline\"\nauthor: \"Rui Yang\"\ndate: \"2025-01-08\"\ndate-modified: last-modified\ncategories: [mpra]\nformat:\n  html:\n    toc: true\n    toc-depth: 6\n    toc-location: left\n    fig-align: center\n    number-depth: 6\n    number-sections: true\n    fig-cap-location: bottom\n    fig-format: png\n    lightbox: true\n    tbl-cap-location: top\n    page-layout: full\njupyter: julia-1.10\nexecute:\n  warning: false\n  eval: false\n---\n\n\n\n\n## Link barcodes to CREs\n\nBefore running any of the following steps, you should rename your FASTQ files according to [these rules](https://www.neuroborder.com/Blogs/Galaxy/posts/Galaxy/endcode_rna_seq_pipeline_in_galaxy/#copy-your-raw-fastq-data-to-a-new-directory-and-rename-them).\n\n::: {#8353abf9 .cell execution_count=1}\n``` {.julia .cell-code}\nwork_dir = \"/data/users/dell/mpra/link_barcode_to_cre/enzyme_v20241230\"\n\ncd(work_dir)\n```\n:::\n\n\n```{r}\nwork_dir <- \"/data/users/dell/mpra/link_barcode_to_cre/enzyme_v20241230\"\n\nsetwd(work_dir)\n```\n\n\n\n\n### MD5SUM check over raw FASTQ files\n\n::: {#3d99e32a .cell execution_count=2}\n``` {.julia .cell-code}\nusing YRUtils\n\nraw_fastq_dir = \"raw_fastq\"\nmd5_file = \"md5.txt\"\nmd5_check_file = \"md5_check.txt\"\n\ncd(raw_fastq_dir)\nYRUtils.BaseUtils.md5_check(md5_file, md5_check_file)\ncd(work_dir)\n```\n:::\n\n\n### FASTQC over raw FASTQ files\n\n::: {#6a1a0ce0 .cell execution_count=3}\n``` {.julia .cell-code}\nusing YRUtils\n\nraw_fastq_dir = \"raw_fastq\"\nraw_fastqc_dir = \"raw_fastqc\"\n\nmkpath(raw_fastqc_dir)\nraw_fastq_files = YRUtils.BaseUtils.list_files(raw_fastq_dir, r\"\\.(fastq|fq)\\.gz$\", recursive=false, full_name=true)\nYRUtils.BioUtils.fastqc(raw_fastq_files, raw_fastqc_dir;\n    fastqc_options=\"--threads 4\", multiqc_options=\"--zip-data-dir\", num_jobs=4)\n```\n:::\n\n\n### Quality trimming over raw FASTQ files\n\n::: {#3489d44e .cell execution_count=4}\n``` {.julia .cell-code}\nusing YRUtils\n\nraw_fastq_dir = \"raw_fastq\"\nclean_fastq_dir = \"clean_fastq\"\n\nmkpath(clean_fastq_dir)\nraw_fastq_files = YRUtils.BaseUtils.list_files(raw_fastq_dir, r\"\\.(fastq|fq)\\.gz$\", recursive=false, full_name=true)\ndict = YRUtils.BioUtils.auto_detect_fastq_read_type(raw_fastq_files)\nfiles_dict = if dict[\"paired\"][\"status\"] == \"yes\"\n    dict[\"paired\"][\"dict\"]\nelseif dict[\"single\"][\"status\"] == \"yes\"\n    dict[\"single\"][\"dict\"]\nelse\n    @error \"did not detect any paired-end or single-end files\"\nend\nfiles_read_type = if dict[\"paired\"][\"status\"] == \"yes\"\n    \"paired\"\nelseif dict[\"single\"][\"status\"] == \"yes\"\n    \"single\"\nelse\n    @error \"did not detect any paired-end or single-end files\"\nend\nYRUtils.BioUtils.trimgalore(files_dict, files_read_type, clean_fastq_dir;\n    trimgalore_options=\"--cores 4 --phred33 --quality 20 --length 30 --trim-n\",\n    num_jobs=1)\n```\n:::\n\n\n### FASTQC over clean FASTQ files\n\n::: {#a9213b12 .cell execution_count=5}\n``` {.julia .cell-code}\nusing YRUtils\n\nclean_fastq_dir = \"clean_fastq\"\nclean_fastqc_dir = \"clean_fastqc\"\n\nmkpath(clean_fastqc_dir)\nclean_fastq_files = YRUtils.BaseUtils.list_files(clean_fastq_dir, r\"\\.(fastq|fq)\\.gz$\", recursive=false, full_name=true)\nYRUtils.BioUtils.fastqc(clean_fastq_files, clean_fastqc_dir;\n    fastqc_options=\"--threads 4\", multiqc_options=\"--zip-data-dir\", num_jobs=4)\n```\n:::\n\n\n### Generate reference sequences\n\nWrite each reference sequence containing CRE as well as other necessary sequences and its ID into a FASTA file, which will be used later to build Bowtie2 reference index.\n\n::: {#4550a3a2 .cell execution_count=6}\n``` {.julia .cell-code}\nusing CSV, DataFrames\n\nleft_seq = \"TTCTCTGGCCTAACTGTCTAGACCTGCAGGAGGACCGGATCAACT\"\nright_seq = \"CATTGCGTGAACCGACACTAGAGGGTATATAATGGAAGCTCGACTTCCAGCTTGGCAATCCGGTACTGTGCAAAGTGAACACATCGCTAAGCGAAAGCTAAGNNNNNNNNNNNNNNNACCGGTCGCCACCATGGTGAGCAAGG\"\nmpra_test_file = \"ref/2w_library.165bp.no_enzyme_cutting_sites.tsv\"\nmpra_ctl_file = \"ref/null_sequences.tsv\"\noutput_mpra_test_file = \"ref/2w_library.165bp.no_enzyme_cutting_sites.dealed.tsv\"\noutput_mpra_ctl_file = \"ref/null_sequences.dealed.tsv\"\noutput_ref_fa_file = \"ref/mpra_ref.fa\"\n\nmpra_test = CSV.read(mpra_test_file, DataFrame)\nmpra_test = unique(mpra_test)\nmpra_test = transform(mpra_test, \"PSCE\", \"extended_mm10_seq\" => (x -> string.(left_seq, x, right_seq)) => \"attached_seq\")\nmpra_test = groupby(mpra_test, \"PSCE\")\nmpra_test = transform(mpra_test, nrow => \"num_per_PSCE\", eachindex => \"PSCE_sub_rank\")\nmpra_test = transform(mpra_test, [\"PSCE\", \"PSCE_sub_rank\", \"num_per_PSCE\"] => ByRow((x, y, z) -> begin\n    if z == 1\n        x\n    else\n        string.(x, \"_\", y)\n    end\nend) => \"PSCE_new_id\")\n\nCSV.write(output_mpra_test_file, mpra_test; delim=\"\\t\", append=false)\n\nmpra_ctl = CSV.read(mpra_ctl_file, DataFrame)\nmpra_ctl = unique(mpra_ctl)\nmpra_ctl = transform(mpra_ctl, eachindex => \"rank\")\nmpra_ctl = transform(mpra_ctl, \"rank\" => (x -> string.(\"CTL\", x)) => \"PSCE\", \"seq\" => (x -> string.(left_seq, x, right_seq)) => \"attached_seq\")\n\nCSV.write(output_mpra_ctl_file, mpra_ctl; delim=\"\\t\", append=false)\n\nref_fa = vcat(string.(\">\", mpra_test[!, \"PSCE_new_id\"], \"\\n\", mpra_test[!, \"attached_seq\"]),\n    string.(\">\", mpra_ctl[!, \"PSCE\"], \"\\n\", mpra_ctl[!, \"attached_seq\"]))\n\nopen(output_ref_fa_file, \"w\") do io\n    for line in ref_fa\n        println(io, line)\n    end\nend\n```\n:::\n\n\n### Build Bowtie2 index\n\n::: {#6e17f13b .cell execution_count=7}\n``` {.julia .cell-code}\nusing YRUtils\n\nref_fa = \"ref/mpra_ref.fa\"\nbowtie2_index_dir = \"bowtie2_index\"\nbowtie2_index_prefix = \"mpra_ref\"\nbowtie2_n_threads = 40\nlog_dir = \"log\"\ntmp_dir = \"tmp\"\n\nmkpath(bowtie2_index_dir)\nmkpath(log_dir)\nmkpath(tmp_dir)\nif !isnothing(match(r\"\\.gz$\", ref_fa))\n    new_ref_fa = joinpath(tmp_dir, replace(basename(ref_fa), r\"\\.gz$\" => \"\"))\n    YRUtils.ShellUtils.pigz(ref_fa, new_ref_fa; decompress=true, keep=true)\nelse\n    new_ref_fa = ref_fa\nend\ncmd = pipeline(Cmd(string.([\"bowtie2-build\", \"--threads\", bowtie2_n_threads, \"-f\", new_ref_fa, joinpath(bowtie2_index_dir, bowtie2_index_prefix)]));\n    stdout=joinpath(log_dir, \"build_bowtie2_index.log\"),\n    stderr=joinpath(log_dir, \"build_bowtie2_index.log\"))\n@info string(\"running \", cmd, \" ...\")\nrun(cmd; wait=true)\nif !isnothing(match(r\"\\.gz$\", ref_fa))\n    rm(new_ref_fa)\nend\n```\n:::\n\n\n### Align reads with Bowtie2\n\n::: {#7d086029 .cell execution_count=8}\n``` {.julia .cell-code}\nusing YRUtils\n\nclean_fastq_dir = \"clean_fastq\"\nbam_dir = \"bam\"\ntmp_dir = \"tmp\"\nlog_dir = \"log\"\nbowtie2_n_threads = 40\nbowtie2_index = \"bowtie2_index/mpra_ref\"\nsamtools_n_threads = 40\nsamtools_mem = \"768M\"\n\nmkpath(bam_dir)\nmkpath(log_dir)\nclean_fastq_files = YRUtils.BaseUtils.list_files(clean_fastq_dir, r\"\\.(fastq|fq)\\.gz$\", recursive=false, full_name=true)\ndict = YRUtils.BioUtils.auto_detect_fastq_read_type(clean_fastq_files)\nfiles_dict = if dict[\"paired\"][\"status\"] == \"yes\"\n    dict[\"paired\"][\"dict\"]\nelseif dict[\"single\"][\"status\"] == \"yes\"\n    dict[\"single\"][\"dict\"]\nelse\n    @error \"did not detect any paired-end or single-end files\"\nend\nfiles_read_type = if dict[\"paired\"][\"status\"] == \"yes\"\n    \"paired\"\nelseif dict[\"single\"][\"status\"] == \"yes\"\n    \"single\"\nelse\n    @error \"did not detect any paired-end or single-end files\"\nend\nif files_read_type == \"paired\"\n    for sample in keys(files_dict)\n        for replicate in keys(files_dict[sample])\n            r1_fq_files = files_dict[sample][replicate][\"R1\"]\n            r2_fq_files = files_dict[sample][replicate][\"R2\"]\n            bam_file = joinpath(bam_dir, string(sample, \"_\", replicate, \".chr_srt.bam\"))\n\n            if length(r1_fq_files) > 1\n                r1_fq_file = joinpath(tmp_dir, string(sample, \"_\", replicate, \".R1.fq.gz\"))\n                cmd = Cmd(string.([\"/usr/bin/bash\", \"-e\", \"-c\",\n                    string(\"zcat -f \", join(r1_fq_files, \" \"),\n                        \" | pigz -n -c > \",\n                        r1_fq_file)]))\n                @info string(\"running \", cmd, \" ...\")\n                run(cmd; wait=true)\n            else\n                r1_fq_file = r1_fq_files[1]\n            end\n            if length(r2_fq_files) > 1\n                r2_fq_file = joinpath(tmp_dir, string(sample, \"_\", replicate, \".R2.fq.gz\"))\n                cmd = Cmd(string.([\"/usr/bin/bash\", \"-e\", \"-c\",\n                    string(\"zcat -f \", join(r2_fq_files, \" \"),\n                        \" | pigz -n -c > \",\n                        r2_fq_file)]))\n                @info string(\"running \", cmd, \" ...\")\n                run(cmd; wait=true)\n            else\n                r2_fq_file = r2_fq_files[1]\n            end\n\n            cmd = pipeline(\n                Cmd(\n                    string.([\"/usr/bin/bash\", \"-e\", \"-c\",\n                        string(\"bowtie2 --np 0 -p \", bowtie2_n_threads, \" -x \", bowtie2_index, \" -1 \", r1_fq_file, \" -2 \", r2_fq_file,\n                            \" | samtools view -S -u - | samtools sort -@ \", samtools_n_threads, \" -m \", samtools_mem, \" - -o \", bam_file)]),\n                );\n                stdout=joinpath(log_dir, \"bowtie2_align.log\"),\n                stderr=joinpath(log_dir, \"bowtie2_align.log\"),\n                append=true)\n            @info string(\"running \", cmd, \" ...\")\n            open(io -> println(io, string(\"running \", cmd, \" ...\")),\n                joinpath(log_dir, \"bowtie2_align.log\"), \"a\")\n            run(cmd; wait=true)\n        end\n    end\nend\n\ncmd = Cmd(string.([\"/usr/bin/bash\", \"-e\", \"-c\", string(\"rm -rf \", joinpath(tmp_dir, \"*\"))]))\n@info string(\"running \", cmd, \" ...\")\nrun(cmd; wait=true)\n```\n:::\n\n\n### Remove reads unmapped and with low quality\n\n::: {#f24cbf3e .cell execution_count=9}\n``` {.julia .cell-code}\nusing YRUtils\n\nbam_dir = \"bam\"\nhigh_qual_bam_dir = \"high_qual_bam\"\nlog_dir = \"log\"\ntmp_dir = \"tmp\"\nsamtools_n_threads = 40\nsamtools_mem = \"768M\"\nmap_qual = 30\n\nmkpath(high_qual_bam_dir)\nbam_files = YRUtils.BaseUtils.list_files(bam_dir, r\"\\.bam$\", recursive=false, full_name=true)\nfor bam_file in bam_files\n    tmp_name_srt_bam_file = joinpath(tmp_dir, replace(basename(bam_file), r\"\\.\\w+\\.bam$\" => \".name_srt.bam\"))\n    cmd = pipeline(Cmd(string.([\"/usr/bin/bash\", \"-e\", \"-c\",\n            string(\"samtools view -u -F 1804 -f 2 -q \", map_qual, \" \", bam_file,\n                \" | samtools sort -n -@ \", samtools_n_threads, \" -m \", samtools_mem, \" - -o \", tmp_name_srt_bam_file)]));\n        stdout=joinpath(log_dir, \"reads_filter.log\"),\n        stderr=joinpath(log_dir, \"reads_filter.log\"),\n        append=true)\n    @info string(\"running \", cmd, \" ...\")\n    open(io -> println(io, string(\"running \", cmd, \" ...\")),\n        joinpath(log_dir, \"reads_filter.log\"), \"a\")\n    run(cmd; wait=true)\n\n    tmp_fixmate_bam_file = joinpath(tmp_dir, replace(basename(bam_file), r\"\\.\\w+\\.bam$\" => \".fixmate.bam\"))\n    cmd = pipeline(Cmd(string.([\"/usr/bin/bash\", \"-e\", \"-c\",\n            string(\"samtools fixmate -@ \", samtools_n_threads, \" -r \", tmp_name_srt_bam_file, \" \", tmp_fixmate_bam_file)]));\n        stdout=joinpath(log_dir, \"reads_filter.log\"),\n        stderr=joinpath(log_dir, \"reads_filter.log\"),\n        append=true)\n    @info string(\"running \", cmd, \" ...\")\n    open(io -> println(io, string(\"running \", cmd, \" ...\")),\n        joinpath(log_dir, \"reads_filter.log\"), \"a\")\n    run(cmd; wait=true)\n\n    filtered_bam_file = joinpath(high_qual_bam_dir, replace(basename(bam_file), r\"\\.\\w+\\.bam$\" => \".chr_srt.bam\"))\n    cmd = pipeline(Cmd(string.([\"/usr/bin/bash\", \"-e\", \"-c\",\n            string(\"samtools view -u -F 1804 -f 2 \", tmp_fixmate_bam_file,\n                \" | samtools sort -@ \", samtools_n_threads, \" -m \", samtools_mem, \" - -o \", filtered_bam_file)]));\n        stdout=joinpath(log_dir, \"reads_filter.log\"),\n        stderr=joinpath(log_dir, \"reads_filter.log\"),\n        append=true)\n    @info string(\"running \", cmd, \" ...\")\n    open(io -> println(io, string(\"running \", cmd, \" ...\")),\n        joinpath(log_dir, \"reads_filter.log\"), \"a\")\n    run(cmd; wait=true)\n\n    rm.([tmp_name_srt_bam_file, tmp_fixmate_bam_file])\nend\n```\n:::\n\n\n### Extract CRE-Barcode pairs\n\n::: {#dc411240 .cell execution_count=10}\n``` {.julia .cell-code}\nusing XAM, FASTX, CSV, DataFrames, YRUtils, Serialization\n\nfunction extract_cre_bc_pairs(bam_file::AbstractString, ref_dict::Dict{String,String};\n    barcode_length::Int=15, quality_scheme::Int=33)\n    valid_dna_bases = (\"A\", \"T\", \"C\", \"G\")\n\n    total_num_records = 0\n    xn_num_records = 0\n    complete_xn_num_records = 0\n    valid_xn_num_records = 0\n    typical_aln_vec_dict = Dict{String,Vector{String}}()\n\n    cre_bc_vec = Tuple{String,String}[]\n    reader = open(BAM.Reader, bam_file)\n    record = BAM.Record()\n    while !eof(reader)\n        empty!(record)\n        read!(reader, record)\n        total_num_records += 1\n        # The optional field XN:i:<N> reports the number of ambiguous reference characters (e.g. N) overlapped by an alignment\n        if haskey(record, \"XN\") && record[\"XN\"] == barcode_length\n            xn_num_records += 1\n            ref_name = BAM.refname(record)\n            # The leftmost mapping position\n            # BAM is 0-based, while SAM is 1-based\n            # BAM.position() gets the 1-based leftmost mapping position of record\n            ref_pos = BAM.position(record)\n            ref_seq = ref_dict[ref_name]\n            cigar_str = BAM.cigar(record)\n            query_seq = string(BAM.sequence(record))\n            query_qual_char_seq = join(Char.(BAM.quality(record) .+ quality_scheme))\n\n            aln_vec = collect(YRUtils.BioUtils.parse_cigar(cigar_str, ref_seq, query_seq, ref_pos; truncate_ref=false))\n            qual_aln_vec = collect(YRUtils.BioUtils.parse_cigar(cigar_str, ref_seq, query_qual_char_seq, ref_pos; truncate_ref=false))\n\n            ref_m = match(Regex(string(\"N{\", barcode_length, \"}\")), aln_vec[1])\n            if !isnothing(ref_m)\n                complete_xn_num_records += 1\n                extract_range = ref_m.offset:(ref_m.offset+barcode_length-1)\n                barcode_seq = aln_vec[2][extract_range]\n                barcode_qual_char_seq = qual_aln_vec[2][extract_range]\n                if all(split(barcode_seq, \"\") .∈ Ref(valid_dna_bases)) && all([Int(c) - quality_scheme for c in barcode_qual_char_seq] .>= base_qual)\n                    valid_xn_num_records += 1\n                    push!(cre_bc_vec, (ref_name, barcode_seq))\n                    typical_aln_vec_dict[string(ref_name, \":\", barcode_seq)] = aln_vec\n                end\n            end\n        end\n    end\n    close(reader)\n\n    cre_bc_gdf = groupby(DataFrame(cre_bc_vec, [:cre, :barcode]), [:cre, :barcode])\n    uniq_cre_bc_df = sort(combine(cre_bc_gdf, nrow => \"num\", proprow => \"prop\"), :num, rev=true)\n\n    open(replace(bam_file, r\"\\.bam$\" => \".extract_cre_bc_pairs.log\"), \"w\") do io\n        println(io, string(\n            \"The number of records in total: \", total_num_records, \"\\n\",\n            \"The number of records with XN field: \", xn_num_records, \"\\n\",\n            \"The number of records with complete barcode: \", complete_xn_num_records, \"\\n\",\n            \"The number of records passing base and quality check: \", valid_xn_num_records, \"\\n\",\n            \"The number of records non-redundant: \", nrow(uniq_cre_bc_df)\n        ))\n    end\n\n    return [uniq_cre_bc_df, typical_aln_vec_dict]\nend\n\nref_file = \"ref/mpra_ref.fa\"\nhigh_qual_bam_dir = \"high_qual_bam\"\nbase_qual = 20\n\n# Read in reference sequences\nref_dict = FASTAReader(open(ref_file, \"r\")) do reader\n    dict = Dict{String,String}()\n    for record in reader\n        dict[identifier(record)] = sequence(record)\n    end\n    return dict\nend\n\nbam_files = YRUtils.BaseUtils.list_files(high_qual_bam_dir, r\"\\.bam$\", recursive=false, full_name=true)\nfor bam_file in bam_files\n    # Extract CRE-Barcode pairs\n    cre_bc_res = extract_cre_bc_pairs(bam_file, ref_dict)\n\n    CSV.write(replace(bam_file, r\"\\.bam$\" => \".uniq_cre_bc_pairs.tsv\"),\n        cre_bc_res[1]; delim=\"\\t\", append=false, writeheader=true)\n\n    # obj = open(jls_file, \"r\") do io\n    #     deserialize(io)\n    # end\n    open(replace(bam_file, r\"\\.bam$\" => \".typical_cre_bc_aligned_sequences.jls\"), \"w\") do io\n        serialize(io, cre_bc_res[2])\n    end\n\n    rand_keys = rand(keys(cre_bc_res[2]), 100)\n    rand_dict = Dict(k => cre_bc_res[2][k] for k in rand_keys)\n    YRUtils.BioUtils.show_align(rand_dict,\n        replace(bam_file, r\"\\.bam$\" => \".typical_cre_bc_aligned_sequences.100.html\");\n        wrap_width=120)\nend\n```\n:::\n\n\n### Quality check\n\n\n\n\n```{r}\nlibrary(vroom)\nlibrary(tidyverse)\nlibrary(YRUtils)\nlibrary(ggprism)\n\ninput_dir <- \"high_qual_bam\"\n\ncre_bc_files <- list.files(input_dir, pattern = \"\\\\.tsv$\", full.names = TRUE, recursive = FALSE)\nfor (cre_bc_file in cre_bc_files) {\n    cre_bc_df <- vroom(cre_bc_file) %>%\n        select(cre, barcode) %>%\n        distinct()\n\n    cre_count_df <- count(cre_bc_df, cre) %>%\n        mutate(type = if_else(str_detect(cre, \"^CTL\"), \"CTL\", \"CRE\")) %>%\n        rename(cre_bc = cre)\n    bc_count_df <- count(cre_bc_df, barcode) %>%\n        mutate(type = \"BC\") %>%\n        rename(cre_bc = barcode)\n    count_df <- bind_rows(cre_count_df, bc_count_df)\n\n    cre_quantiles <- quantile(count_df$n[count_df$type %in% c(\"CTL\", \"CRE\")], probs = seq(0, 1, 0.1))\n    cre_only_quantiles <- quantile(count_df$n[count_df$type == \"CRE\"], probs = seq(0, 1, 0.1))\n    ctl_only_quantiles <- quantile(count_df$n[count_df$type == \"CTL\"], probs = seq(0, 1, 0.1))\n    bc_quantiles <- quantile(count_df$n[count_df$type == \"BC\"], probs = seq(0, 1, 0.1))\n    type_nums <- table(count_df$type)\n\n    paste0(\n        \"1. CRE/CTL quantiles (\", type_nums[\"CTL\"] + type_nums[\"CRE\"], \"): \\n\",\n        paste0(paste0(names(cre_quantiles), \"\\t\", cre_quantiles), collapse = \"\\n\"), \"\\n\\n\",\n        \"2. CRE only quantiles (\", type_nums[\"CRE\"], \"): \\n\",\n        paste0(paste0(names(cre_only_quantiles), \"\\t\", cre_only_quantiles), collapse = \"\\n\"), \"\\n\\n\",\n        \"3. CTL only quantiles (\", type_nums[\"CTL\"], \"): \\n\",\n        paste0(paste0(names(ctl_only_quantiles), \"\\t\", ctl_only_quantiles), collapse = \"\\n\"), \"\\n\\n\",\n        \"4. BC quantiles (\", type_nums[\"BC\"], \"): \\n\",\n        paste0(paste0(names(bc_quantiles), \"\\t\", bc_quantiles), collapse = \"\\n\")\n    ) %>% vroom_write_lines(file = gsub(\"\\\\.tsv$\", \"\\\\.quantiles.txt\", cre_bc_file))\n\n    p <- ggplot(count_df, aes(type, log2(n), fill = type, color = type)) +\n        geom_violin(scale = \"width\", alpha = 0.25, trim = TRUE) +\n        geom_boxplot(width = 0.2, outliers = FALSE, alpha = 0.25) +\n        scale_y_continuous(expand = expansion(mult = c(0.05, 0))) +\n        labs(\n            x = \"Sequence Type\",\n            y = \"log2(Count)\"\n        ) +\n        theme_prism(base_size = 20, base_family = \"Arial\", border = FALSE) +\n        theme(legend.position = \"none\")\n    ppreview(p, file = gsub(\"\\\\.tsv$\", \"\\\\.violin.pdf\", cre_bc_file))\n}\n```\n\n\n\n\n### Merge all CRE-Barcode pairs\n\n\n\n\n```{r}\nlibrary(vroom)\nlibrary(tidyverse)\n\ninput_dirs <- c(\n    \"/data/users/dell/mpra/link_barcode_to_cre/enzyme_v20241230/high_qual_bam\",\n    \"/data/users/dell/mpra/link_barcode_to_cre/enzyme_v20231027/high_qual_bam\",\n    \"/data/users/dell/mpra/link_barcode_to_cre/pcr_v20230922/high_qual_bam\"\n)\noutput_dir <- \"/data/users/dell/mpra/link_barcode_to_cre/final_result\"\n\nfiles <- list.files(input_dirs, pattern = \"\\\\.tsv$\", recursive = FALSE, full.names = TRUE)\ncre_bc_df <- tibble()\nfor (file in files) {\n    cre_bc_df <- bind_rows(\n        cre_bc_df,\n        vroom(file) %>% select(cre, barcode)\n    )\n}\ncre_bc_df <- distinct(cre_bc_df)\none_cre_barocdes <- cre_bc_df %>%\n    group_by(barcode) %>%\n    count() %>%\n    filter(n == 1) %>%\n    pull(barcode) %>%\n    unique()\none_cre_bc_df <- cre_bc_df %>%\n    filter(barcode %in% one_cre_barocdes) %>%\n    distinct()\n\nvroom_write(cre_bc_df, file = file.path(output_dir, \"redundant_cre_bc_pairs.tsv\"), col_names = TRUE, append = FALSE)\nvroom_write(one_cre_bc_df, file = file.path(output_dir, \"non_redundant_cre_bc_pairs.tsv\"), col_names = TRUE, append = FALSE)\n```\n\n\n\n\n## Count barcodes\n\nBefore running any of the following steps, you should rename your FASTQ files in this form: `ID_(RNA|DNA)_repN[_partN].R[123].(fq|fastq).gz` (`ID` can only contain `[a-zA-Z0-9]`; `N` can only contain `[0-9]`).\n\n::: {#cf7ebd47 .cell execution_count=11}\n``` {.julia .cell-code}\nwork_dir = \"/data/users/dell/mpra/count_barcode/15bp_v20240627\"\n\ncd(work_dir)\n```\n:::\n\n\n```{r}\nwork_dir <- \"/data/users/dell/mpra/count_barcode/15bp_v20240627\"\n\nsetwd(work_dir)\n```\n\n\n\n\n### MD5SUM check over raw FASTQ files\n\n::: {#f233a994 .cell execution_count=12}\n``` {.julia .cell-code}\nusing YRUtils\n\nraw_fastq_dir = \"raw_fastq\"\nmd5_file = \"md5.txt\"\nmd5_check_file = \"md5_check.txt\"\n\ncd(raw_fastq_dir)\nYRUtils.BaseUtils.md5_check(md5_file, md5_check_file)\ncd(work_dir)\n```\n:::\n\n\n### FASTQC over raw FASTQ files\n\n::: {#acab03c1 .cell execution_count=13}\n``` {.julia .cell-code}\nusing YRUtils\n\nraw_fastq_dir = \"raw_fastq\"\nraw_fastqc_dir = \"raw_fastqc\"\n\nmkpath(raw_fastqc_dir)\nraw_fastq_files = YRUtils.BaseUtils.list_files(raw_fastq_dir, r\"\\.(fastq|fq)\\.gz$\", recursive=false, full_name=true)\nYRUtils.BioUtils.fastqc(raw_fastq_files, raw_fastqc_dir;\n    fastqc_options=\"--threads 4\", multiqc_options=\"--zip-data-dir\", num_jobs=4)\n```\n:::\n\n\n### Count barcodes\n\n::: {#a7c3d1bb .cell execution_count=14}\n``` {.julia .cell-code}\nusing FASTX, DataFrames, CSV, YRUtils, CodecZlib\n\nraw_fastq_dir = \"/data/users/dell/mpra/count_barcode/15bp_v20240627/raw_fastq\"\ncre_bc_file = \"/data/users/dell/mpra/link_barcode_to_cre/final_result/redundant_cre_bc_pairs.tsv\"\nraw_bc_umi_dir = \"raw_bc_umi\"\nbase_qual = 20\nseqkit_nthreads = 40\n\nmkpath(raw_bc_umi_dir)\ncre_bc_df = CSV.read(cre_bc_file, DataFrame; header=true, delim=\"\\t\")\nuniq_barcodes = Set(cre_bc_df[:, :barcode])\n\nraw_fastq_file_name_pattern = r\".+/(?<id>[a-zA-Z0-9]+)_(?<type>RNA|DNA)_(?<rep>rep[0-9]+)(_(?<tech>part[0-9]+))?\\.(?<read>R[123])\\.(fq|fastq)\\.gz$\"\nraw_fastq_files = YRUtils.BioUtils.list_files(raw_fastq_dir, raw_fastq_file_name_pattern; recursive=false, full_name=true)\nraw_fastq_nums = YRUtils.BioUtils.fq_num(raw_fastq_files, seqkit_nthreads)\nms = match.(raw_fastq_file_name_pattern, raw_fastq_files)\nmetadata_vec = Vector{NTuple{7,String}}(undef, length(ms))\nfor i in 1:length(ms)\n    metadata_vec[i] = (ms[i].match, ms[i][\"id\"], ms[i][\"type\"], ms[i][\"rep\"], ms[i][\"tech\"], ms[i][\"read\"], string(raw_fastq_nums[ms[i].match]))\nend\ndf = unique(DataFrame(metadata_vec, [:file, :id, :type, :rep, :tech, :read, :num_seqs]))\ndf = transform(\n    df,\n    [:id, :type, :rep, :tech] => ByRow((id, type, rep, tech) -> join([id, type, rep, tech], \"_\")) => :tech_sample,\n    [:id, :type, :rep] => ByRow((id, type, rep) -> join([id, type, rep], \"_\")) => :rep_sample,\n    [:id, :type] => ByRow((id, type) -> join([id, type], \"_\")) => :type_sample\n)\ntech_gdf = groupby(df, :tech_sample)\nCSV.write(joinpath(raw_bc_umi_dir, \"fq_metadata.tsv\"), df; header=true, delim=\"\\t\", append=false)\n\ndf_dict = Dict(unique(read_df[:, :tech_sample])[1] => DataFrame() for read_df in tech_gdf)\nfor read_df in tech_gdf\n    # Read in reads\n    read_dict = Dict(read_type => Vector{Tuple{String,String,String}}(undef, parse(Int64, num_seqs)) for (read_type, num_seqs) in collect(zip(read_df[:, :read], read_df[:, :num_seqs])))\n    Threads.@threads for (read_type, num_seqs, fq_file) in collect(zip(read_df[:, :read], read_df[:, :num_seqs], read_df[:, :file]))\n        @info string(\"start parsing \", fq_file, \" with read type \", read_type, \" and the number of sequences \", num_seqs, \" ...\")\n        FASTQReader(GzipDecompressorStream(open(fq_file))) do reader\n            record = FASTQ.Record()\n            i = 0\n            while !eof(reader)\n                i += 1\n                empty!(record)\n                read!(reader, record)\n                read_dict[read_type][i] = (identifier(record), sequence(record), join(collect(quality_scores(record)), \"/\"))\n            end\n            @info string(\"read in \", i, \" sequences in total for \", fq_file)\n            if i != parse(Int64, num_seqs)\n                @error string(\"parsing file \", fq_file, \" failed!\")\n            end\n        end\n        @info string(\"parsing \", fq_file, \" with read type \", read_type, \" and the number of sequences \", num_seqs, \" done!\")\n    end\n\n    # Count qualified barcodes and their UMIs\n    len_vec = length.(values(read_dict))\n    # The three files should have the same number of lines\n    if length(unique(len_vec)) == 1\n        bc_umi_vec = Vector{Tuple{String,String,String,Vararg{Bool,9}}}(undef, len_vec[1])\n        Threads.@threads for i in 1:len_vec[1]\n            # Read IDs should be identical across R1, R2, and R3\n            if read_dict[\"R1\"][i][1] == read_dict[\"R2\"][i][1] == read_dict[\"R3\"][i][1]\n                bc_umi_vec[i] = (\n                    # Read 1\n                    read_dict[\"R1\"][i][2],\n                    # Read 2\n                    read_dict[\"R2\"][i][2],\n                    # UMI\n                    read_dict[\"R3\"][i][2],\n                    # Read sequences should only contain A, T, C, and G across R1, R2, and R3\n                    !occursin(\"N\", string(read_dict[\"R1\"][i][2], read_dict[\"R2\"][i][2], read_dict[\"R3\"][i][2])),\n                    # All base qualities >= base_qual across R1, R2, and R3\n                    all(parse.(Int, split(string(read_dict[\"R1\"][i][3], \"/\", read_dict[\"R2\"][i][3], \"/\", read_dict[\"R3\"][i][3]), \"/\")) .>= base_qual),\n                    # Read 1 and read 2 should be reverse and complementary\n                    YRUtils.BioUtils.rev_com_dna_seq(read_dict[\"R1\"][i][2]) == read_dict[\"R2\"][i][2],\n                    # Either read 1 or read 2 should be in the barcode library (not both in theory)\n                    # Read 1 in the barcode library?\n                    read_dict[\"R1\"][i][2] in uniq_barcodes,\n                    # Read 2 in the barcode library?\n                    read_dict[\"R2\"][i][2] in uniq_barcodes,\n                    # The reverse sequence of read 1 in the barcode library?\n                    YRUtils.BioUtils.rev_seq(read_dict[\"R1\"][i][2]) in uniq_barcodes,\n                    # The complementary sequence of read 1 in the barcode library?\n                    YRUtils.BioUtils.com_dna_seq(read_dict[\"R1\"][i][2]) in uniq_barcodes,\n                    # The reverse sequence of read 2 in the barcode library?\n                    YRUtils.BioUtils.rev_seq(read_dict[\"R2\"][i][2]) in uniq_barcodes,\n                    # The complementary sequence of read 2 in the barcode library?\n                    YRUtils.BioUtils.com_dna_seq(read_dict[\"R2\"][i][2]) in uniq_barcodes\n                )\n            else\n                @error \"read IDs are not identical across R1, R2, and R3\"\n            end\n        end\n    else\n        @error \"length(R1) == length(R2) == length(R3) is not true\"\n    end\n\n    # Write statistics\n    col4, col5, col6, col7, col8, col9, col10, col11, col12 = (\n        getindex.(bc_umi_vec, 4),\n        getindex.(bc_umi_vec, 5),\n        getindex.(bc_umi_vec, 6),\n        getindex.(bc_umi_vec, 7),\n        getindex.(bc_umi_vec, 8),\n        getindex.(bc_umi_vec, 9),\n        getindex.(bc_umi_vec, 10),\n        getindex.(bc_umi_vec, 11),\n        getindex.(bc_umi_vec, 12)\n    )\n    open(joinpath(raw_bc_umi_dir, \"fq_read_stats.txt\"), \"a\") do io\n        stat_str = string(\n            \"==> \", unique(read_df[:, :tech_sample])[1], \" <==\\n\",\n            \"1. The number of reads in total: \", len_vec[1], \"\\n\\n\",\n            \"2. % reads without Ns (\", sum(col4), \"): \", sum(col4) / len_vec[1], \"\\n\",\n            \"3. % reads with base qualities >= \", base_qual, \" (\", sum(col5), \"): \", sum(col5) / len_vec[1], \"\\n\",\n            \"4. % reads passing 2 and 3: (\", sum(col4 .&& col5), \"): \", sum(col4 .&& col5) / len_vec[1], \"\\n\\n\",\n            \"5. % reads (R1 and R2 are reverse and complementary) (\", sum(col6), \"): \", sum(col6) / len_vec[1], \"\\n\",\n            \"6. % reads passing 2, 3, and 5 (\", sum(col4 .&& col5 .&& col6), \"): \", sum(col4 .&& col5 .&& col6) / len_vec[1], \"\\n\\n\",\n            \"7. % reads of R1 in the library (\", sum(col7), \"): \", sum(col7) / len_vec[1], \"\\n\",\n            \"8. % reads passing 2, 3, 5 and 7 (\", sum(col4 .&& col5 .&& col6 .&& col7), \"): \", sum(col4 .&& col5 .&& col6 .&& col7) / len_vec[1], \"\\n\\n\",\n            \"9. % reads of R2 in the library (\", sum(col8), \"): \", sum(col8) / len_vec[1], \"\\n\",\n            \"10. % reads passing 2, 3, 5 and 9 (\", sum(col4 .&& col5 .&& col6 .&& col8), \"): \", sum(col4 .&& col5 .&& col6 .&& col8) / len_vec[1], \"\\n\\n\",\n            \"11. % reads (both R1 and R2 are in the library) (\", sum(col7 .&& col8), \"): \", sum(col7 .&& col8) / len_vec[1], \"\\n\",\n            \"12. % reads passing 2, 3, 5 and 11 (\", sum(col4 .&& col5 .&& col6 .&& col7 .&& col8), \"): \", sum(col4 .&& col5 .&& col6 .&& col7 .&& col8) / len_vec[1], \"\\n\\n\",\n            \"13. % reads (one of R1 and R2 in the library, not both) (\", sum(col7 .⊻ col8), \"): \", sum(col7 .⊻ col8) / len_vec[1], \"\\n\",\n            \"14. % reads passing 2, 3, 5 and 13 (\", sum(col4 .&& col5 .&& col6 .&& (col7 .⊻ col8)), \"): \", sum(col4 .&& col5 .&& col6 .&& (col7 .⊻ col8)) / len_vec[1], \"\\n\\n\",\n            \"15. % reverse reads of R1 in the library (\", sum(col9), \"): \", sum(col9) / len_vec[1], \"\\n\",\n            \"16. % reads passing 2, 3, 5 and 15 (\", sum(col4 .&& col5 .&& col6 .&& col9), \"): \", sum(col4 .&& col5 .&& col6 .&& col9) / len_vec[1], \"\\n\\n\",\n            \"17. % complementary reads of R1 in the library (\", sum(col10), \"): \", sum(col10) / len_vec[1], \"\\n\",\n            \"18. % reads passing 2, 3, 5 and 17 (\", sum(col4 .&& col5 .&& col6 .&& col10), \"): \", sum(col4 .&& col5 .&& col6 .&& col10) / len_vec[1], \"\\n\\n\",\n            \"19. % reverse reads of R2 in the library (\", sum(col11), \"): \", sum(col11) / len_vec[1], \"\\n\",\n            \"20. % reads passing 2, 3, 5 and 19 (\", sum(col4 .&& col5 .&& col6 .&& col11), \"): \", sum(col4 .&& col5 .&& col6 .&& col11) / len_vec[1], \"\\n\\n\",\n            \"21. % complementary reads of R2 in the library (\", sum(col12), \"): \", sum(col12) / len_vec[1], \"\\n\",\n            \"22. % reads passing 2, 3, 5 and 21 (\", sum(col4 .&& col5 .&& col6 .&& col12), \"): \", sum(col4 .&& col5 .&& col6 .&& col12) / len_vec[1], \"\\n\\n\\n\"\n        )\n        print(io, stat_str)\n    end\n\n    # Filter out invalid Barcode-UMI pairs\n    valid_bc_umi_vec = bc_umi_vec[col4.&&col5.&&col6.&&(col7.⊻col8)]\n    df_dict[unique(read_df[:, :tech_sample])[1]] = DataFrame(\n        [[(x[1], x[3]) for x in valid_bc_umi_vec[getindex.(valid_bc_umi_vec, 7)]]; [(x[2], x[3]) for x in valid_bc_umi_vec[getindex.(valid_bc_umi_vec, 8)]]],\n        [:barcode, :umi]\n    )\n    df_dict[unique(read_df[:, :tech_sample])[1]][!, :tech_sample] .= unique(read_df[:, :tech_sample])[1]\nend\nbc_umi_df = reduce(vcat, collect(values(df_dict)); cols=:setequal)\nCSV.write(joinpath(raw_bc_umi_dir, \"raw_bc_umi_pairs.tsv\"), bc_umi_df; header=true, delim=\"\\t\", append=false)\n```\n:::\n\n\n### Attach barcodes to CREs\n\n\n\n\n```{r}\nlibrary(vroom)\nlibrary(tidyverse)\nlibrary(ggprism)\nlibrary(YRUtils)\n\nraw_bc_umi_pairs_file <- \"raw_bc_umi/raw_bc_umi_pairs.tsv\"\n# Here, we only keep those CRE-Barcode pairs, where each barcode is assigned to only one CRE\ncre_bc_file <- \"/data/users/dell/mpra/link_barcode_to_cre/final_result/non_redundant_cre_bc_pairs.tsv\"\noutput_dir <- \"cre_bc_count\"\n\ndir.create(output_dir)\ncre_bc_df <- vroom(cre_bc_file)\nraw_bc_umi_pairs_df <- vroom(raw_bc_umi_pairs_file)\n\n# Count barcodes based on UMIs\nbiorep_bc_count_df <- raw_bc_umi_pairs_df %>%\n    mutate(rep_sample = gsub(\"_part[0-9]+$\", \"\", tech_sample)) %>%\n    select(-all_of(c(\"tech_sample\"))) %>%\n    distinct() %>%\n    group_by(rep_sample, barcode) %>%\n    # Count the number of occurrences of each barcode in each biological replicate\n    count(name = \"barcode_count\") %>%\n    ungroup() %>%\n    group_by(rep_sample) %>%\n    arrange(desc(barcode_count), .by_group = TRUE) %>%\n    ungroup()\nvroom_write(biorep_bc_count_df, file = file.path(output_dir, \"biorep_bc_count.tsv\"))\n\n# Attach CREs to barcodes\nbiorep_cre_bc_count_df <- biorep_bc_count_df %>%\n    inner_join(cre_bc_df, by = \"barcode\", relationship = \"many-to-many\") %>%\n    group_by(rep_sample) %>%\n    arrange(desc(barcode_count), .by_group = TRUE) %>%\n    ungroup()\nvroom_write(biorep_cre_bc_count_df, file = file.path(output_dir, \"biorep_cre_bc_count.tsv\"))\n\n# Count the number of unique barcodes detected in each biological replicate\nbc_num_each_biorep <- biorep_bc_count_df %>%\n    group_by(rep_sample) %>%\n    count(name = \"barcode_num\") %>%\n    ungroup()\nvroom_write(bc_num_each_biorep, file = file.path(output_dir, \"bc_num_each_biorep.tsv\"))\n\n# The distribution of the number of barcodes belonging to each CRE\n# The distribution of the number of CREs belonging to each barcode\nleft_cre_bc_df <- biorep_cre_bc_count_df %>%\n    select(barcode, cre) %>%\n    distinct()\nbc_count_df <- left_cre_bc_df %>%\n    group_by(barcode) %>%\n    count() %>%\n    rename(cre_bc = barcode) %>%\n    mutate(type = \"BC\")\ncre_count_df <- left_cre_bc_df %>%\n    group_by(cre) %>%\n    count() %>%\n    rename(cre_bc = cre) %>%\n    mutate(type = if_else(str_detect(cre_bc, \"^CTL\"), \"CTL\", \"CRE\"))\ncount_df <- bind_rows(cre_count_df, bc_count_df)\n\ncre_quantiles <- quantile(count_df$n[count_df$type %in% c(\"CTL\", \"CRE\")], probs = seq(0, 1, 0.1))\ncre_only_quantiles <- quantile(count_df$n[count_df$type == \"CRE\"], probs = seq(0, 1, 0.1))\nctl_only_quantiles <- quantile(count_df$n[count_df$type == \"CTL\"], probs = seq(0, 1, 0.1))\nbc_quantiles <- quantile(count_df$n[count_df$type == \"BC\"], probs = seq(0, 1, 0.1))\ntype_nums <- table(count_df$type)\n\npaste0(\n    \"1. CRE/CTL quantiles (\", type_nums[\"CTL\"] + type_nums[\"CRE\"], \"): \\n\",\n    paste0(paste0(names(cre_quantiles), \"\\t\", cre_quantiles), collapse = \"\\n\"), \"\\n\\n\",\n    \"2. CRE only quantiles (\", type_nums[\"CRE\"], \"): \\n\",\n    paste0(paste0(names(cre_only_quantiles), \"\\t\", cre_only_quantiles), collapse = \"\\n\"), \"\\n\\n\",\n    \"3. CTL only quantiles (\", type_nums[\"CTL\"], \"): \\n\",\n    paste0(paste0(names(ctl_only_quantiles), \"\\t\", ctl_only_quantiles), collapse = \"\\n\"), \"\\n\\n\",\n    \"4. BC quantiles (\", type_nums[\"BC\"], \"): \\n\",\n    paste0(paste0(names(bc_quantiles), \"\\t\", bc_quantiles), collapse = \"\\n\")\n) %>% vroom_write_lines(file = file.path(output_dir, \"quantiles.txt\"))\n\np <- ggplot(count_df, aes(type, log2(n), fill = type, color = type)) +\n    geom_violin(scale = \"width\", alpha = 0.25, trim = TRUE) +\n    geom_boxplot(width = 0.2, outliers = FALSE, alpha = 0.25) +\n    scale_y_continuous(expand = expansion(mult = c(0.05, 0))) +\n    labs(\n        x = \"Sequence Type\",\n        y = \"log2(Count)\"\n    ) +\n    theme_prism(base_size = 20, base_family = \"Arial\", border = FALSE) +\n    theme(legend.position = \"none\")\nppreview(p, file = file.path(output_dir, \"violin.pdf\"))\n```\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}
{
  "hash": "ef7470744d1b477cbad04e20cb69ef1b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"DE-related analysis for bulk proteomics\"\nauthor: \"Rui Yang\"\ndate: \"2025-01-16\"\ndate-modified: last-modified\ncategories: [bulk proteomics, differential expression]\nformat:\n  html:\n    toc: true\n    toc-depth: 6\n    toc-location: left\n    fig-align: center\n    number-depth: 6\n    number-sections: true\n    fig-cap-location: bottom\n    fig-format: png\n    lightbox: true\n    tbl-cap-location: top\n    page-layout: full\n\nexecute:\n  warning: false\n  eval: false\n---\n\n\n\n\n## Introduction\n\nAt present, this pipeline only allows two sample groups contained in your input files.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwork_dir <- \"/data/users/yangrui/lab_projs/lym_new\"\n\nsetwd(work_dir)\n```\n:::\n\n\n\n\n## Quality check\n\n1. `expr_file` must include two ID columns:\n\n- `protein_groups`: in which each row must be unique;\n\n- `gene_name`: in which each gene name may not be unique.\n\nIn addition, it should also contain a number of sample columns containing protein abundance levels.\n\nEach sample name must be in the form of `ID_N`, where `N` is the replicate number.\n\n2. `sample_file` must include the following three columns:\n\n- `sample`: with the same sample names as those in the abundance file above in the form of `ID_N`;\n\n- `group`: in the form of `ID`;\n\n- `replicate`: in the form of `N`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(vroom)\nlibrary(psych)\nlibrary(FactoMineR)\nlibrary(ggforce)\nlibrary(ggprism)\nlibrary(ggalign)\nlibrary(YRUtils)\n\nexpr_file <- \"input/BTN3A2_proteomic_quantification_data.tsv\"\nsample_file <- \"input/sample_sheet.tsv\"\nqc_dir <- \"qc\"\n# Keep those rows detected in at least N replicates in at least one group\nexpr_sample_num <- 2\n\ndir.create(qc_dir, showWarnings = FALSE, recursive = FALSE)\nsample_df <- vroom(sample_file) %>%\n    distinct()\nexpr_df <- vroom(expr_file) %>%\n    distinct()\ntable(duplicated(expr_df$protein_groups))\n\nfor (s in sample_df$sample) {\n    expr_df[[s]][is.na(expr_df[[s]])] <- 0\n}\n\nfilter_flag <- rep(F, nrow(expr_df))\nfor (g in unique(sample_df$group)) {\n    tmp_df <- expr_df[, filter(sample_df, group == g) %>% pull(sample) %>% unique(), drop = F]\n    filter_flag <- filter_flag | (rowSums(tmp_df > 0) >= expr_sample_num)\n}\nexpr_df <- expr_df[filter_flag, ]\n\nall_vs_none_expr_df <- tibble()\nsample_groups <- unique(sample_df$group)\nfor (g in sample_groups) {\n    tmp_df <- expr_df[rowSums(expr_df[, filter(sample_df, group == g) %>% pull(sample) %>% unique(), drop = F] > 0) == 0, ] %>%\n        mutate(diff_flag = paste0(sample_groups[sample_groups != g], \" Up\"))\n    all_vs_none_expr_df <- bind_rows(all_vs_none_expr_df, tmp_df)\n}\nboth_expr_df <- filter(expr_df, !(protein_groups %in% all_vs_none_expr_df$protein_groups))\nvroom_write(all_vs_none_expr_df,\n    file = gsub(\"\\\\.\\\\w+$\", \".all_vs_none.tsv\", expr_file),\n    col_names = TRUE, append = FALSE\n)\nvroom_write(both_expr_df,\n    file = gsub(\"\\\\.\\\\w+$\", \".both.tsv\", expr_file),\n    col_names = TRUE, append = FALSE\n)\nlog_expr_df <- log2(expr_df[, unique(sample_df$sample)] + 1)\n\n# Correlation\ncor_res <- corr.test(log_expr_df, use = \"pairwise\", method = \"pearson\", adjust = \"BH\")\n\np <- ggheatmap(\n    cor_res$r,\n    width = ncol(cor_res$r) * unit(10, \"mm\"),\n    height = nrow(cor_res$r) * unit(10, \"mm\")\n) +\n    scheme_align(free_spaces = \"t\") +\n    scale_fill_gradient2(\n        low = \"blue\", mid = \"white\", high = \"red\",\n        midpoint = 0, limits = c(-1, 1),\n        breaks = c(-1, -0.5, 0, 0.5, 1)\n    ) +\n    labs(fill = \"R\") +\n    guides(x = guide_axis(angle = 45)) +\n    theme(\n        text = element_text(size = 20, family = \"Arial\", color = \"black\"),\n        axis.text = element_text(size = 20, family = \"Arial\", color = \"black\")\n    ) +\n    anno_top() +\n    ggalign(\n        data = gsub(\"_\\\\d+$\", \"\", colnames(cor_res$r)),\n        size = unit(4, \"mm\")\n    ) +\n    geom_tile(aes(y = 1, fill = factor(value))) +\n    scale_y_continuous(breaks = NULL, name = NULL, expand = expansion(0)) +\n    labs(fill = \"Sample\") +\n    theme(\n        text = element_text(size = 20, family = \"Arial\", color = \"black\"),\n        axis.text = element_text(size = 20, family = \"Arial\", color = \"black\")\n    ) +\n    with_quad(scheme_align(guides = \"t\"), NULL)\nppreview(p, file = file.path(qc_dir, \"correlation.pdf\"))\n\n# PCA\npca <- PCA(t(log_expr_df), ncp = 10, scale.unit = TRUE, graph = FALSE)\n\npca_coord <- as.data.frame(pca$ind$coord)\npca_coord$sample <- row.names(pca_coord)\npca_coord$group <- factor(gsub(\"_\\\\d+$\", \"\", pca_coord$sample))\npca_eig <- as.data.frame(pca$eig)\n\np <- ggplot(pca_coord, aes(Dim.1, Dim.2)) +\n    geom_point(aes(color = group), size = 4) +\n    xlab(paste0(\"PC1 (\", round(pca_eig[\"comp 1\", \"percentage of variance\"]), \"%)\")) +\n    ylab(paste0(\"PC2 (\", round(pca_eig[\"comp 2\", \"percentage of variance\"]), \"%)\")) +\n    geom_mark_ellipse(aes(fill = group), color = NA, alpha = 0.25) +\n    theme_prism(base_family = \"Arial\", border = TRUE, base_size = 20)\nppreview(p, file = file.path(qc_dir, \"pca.pdf\"))\n```\n:::\n\n\n\n\n## Differential abundance analysis\n\nFor **spectra count** (MS2), the distribution of which can be approximated by a Poisson distribution. In this case, `DESeq2`, `edgeR`, etc. may be used.\n\nFor **signal intensity** (MS1), the distribution of which can be approximated by a Normal distribution. In this case, `limma` may be used.\n\n### DEP2 (`limma`-based method)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(DEP2)\nlibrary(patchwork)\nlibrary(ggplot2)\nlibrary(vroom)\nlibrary(tidyverse)\nlibrary(ggridges)\nlibrary(YRUtils)\n\nexpr_file <- \"input/BTN3A2_proteomic_quantification_data.both.tsv\"\nsample_file <- \"input/sample_sheet.tsv\"\noutput_dir <- \"de\"\n\ndir.create(output_dir, showWarnings = FALSE, recursive = FALSE)\nsample_df <- vroom(sample_file) %>%\n    distinct()\nexpr_df <- vroom(expr_file) %>%\n    distinct()\n\n\n### 1. Perform differential expression analysis over genes detected in both treatment and control\n# For duplicated IDs, add tailed numbers, delimiter is \".\"\nexpr_df <- make_unique(expr_df, names = \"gene_name\", ids = \"protein_groups\", delim = \";\")\n# Take expression columns\nexpr_cols <- which(names(expr_df) %in% sample_df$sample)\n\n\n## 1. Construct SummarizedExperiment object\nse <- make_se_parse(expr_df,\n    columns = expr_cols,\n    mode = \"delim\", sep = \"_\",\n    log2transform = T\n)\n\n\n## 2. Filtering\n# Filtering out reverse, contaminant, and low-quality features with many missing values\n# Allow up to N missing values in each condition\nmv_num <- 1\n\n# filter_se() also provides filtering options based on filter_formula,\n# which can be used to filter features based on given columns\nfilter_se <- filter_se(se, thr = mv_num)\n\np <- (plot_frequency(se) + ggtitle(\"Protein identifications overlap before filter\")) /\n    (plot_frequency(filter_se) + ggtitle(\"Protein identifications overlap after filter\"))\nppreview(p, file = file.path(output_dir, \"filter_freq_hists.pdf\"))\n\n# Even after filtering, a considerable proportion of missing values may still remain in the assay\nplot_missval(filter_se)\n\n\n## 3. Normalization\n# log1p --> variance stabilizing transformation (vst)\nnorm_se <- normalize_vsn(filter_se)\n\np <- plot_normalization(norm_se)\nppreview(p, file = file.path(output_dir, \"norm_boxplot.pdf\"))\n\n# Density and CumSum plots of intensities of proteins with and without missing values\nplot_detect(norm_se)\n\n## 4. Imputation\n# 1. Some may be suitable for missing at random\n# In this case, both small and large values may be missing,\n# so imputing relatively larger values is reasonable\n# 2. Some may be suitable for missing not at random\n# In this case, I think a large proportion of missing values are so small that they cannot be detected,\n# so using imputation with cautions, it may introduce unwanted bias\n# You should have a deep comprehension for the sources of missing values\n# c(\"QRILC\", \"bpca\", \"knn\", \"MLE\", \"MinDet\", \"MinProb\", \"man\", \"min\", \"zero\", \"mixed\", \"nbavg\", \"RF\", \"GSimp\")\n# It seems that \"MLE\" is really time-consuming\n# Remove method \"mixed\" because it needs specifying which rows are missing at random (the remaining rows are missing not at random), and specifying two methods for dealing with missing at random and missing not at random respectively\n# Remove method \"MLE\" because it seems that we need to adjust parameters more carefully otherwise the imputation values of NAs are much larger than the normal\nimpute_methods <- c(\"QRILC\", \"bpca\", \"knn\", \"MinDet\", \"MinProb\", \"man\", \"min\", \"zero\", \"nbavg\", \"RF\", \"GSimp\")\n\nnames(impute_methods) <- impute_methods\n# Keep only those sample-feature pairs having NAs\nnas_df <- assay(norm_se) %>%\n    as.data.frame() %>%\n    mutate(gene_name = row.names(.)) %>%\n    pivot_longer(cols = !gene_name, names_to = \"label\", values_to = \"value\") %>%\n    mutate(is_na = is.na(value)) %>%\n    filter(is_na) %>%\n    select(gene_name, label)\n# Keep only those sample-feature pairs not having NAs\nnon_nas <- nas_df %>%\n    mutate(id = paste0(label, \":\", gene_name)) %>%\n    pull(id) %>%\n    unique()\n# Try each imputation method\nimpute_se_ls <- lapply(impute_methods, function(x) {\n    message(paste0(\"\\n\\nrunning \", x, \" ...\"))\n    impute(norm_se, fun = x)\n})\n\nimps <- tibble()\nfor (m in names(impute_se_ls)) {\n    tmp_df <- assay(impute_se_ls[[m]]) %>%\n        as.data.frame() %>%\n        mutate(gene_name = row.names(.)) %>%\n        pivot_longer(cols = !gene_name, names_to = \"label\", values_to = \"value\") %>%\n        left_join(as.data.frame(colData(impute_se_ls[[m]])[, c(\"label\", \"condition\")]), by = \"label\") %>%\n        right_join(nas_df, by = c(\"gene_name\", \"label\")) %>%\n        mutate(method = m)\n    imps <- bind_rows(imps, tmp_df)\n}\nnon_imps <- assay(norm_se) %>%\n    as.data.frame() %>%\n    mutate(gene_name = row.names(.)) %>%\n    pivot_longer(cols = !gene_name, names_to = \"label\", values_to = \"value\") %>%\n    left_join(as.data.frame(colData(norm_se)[, c(\"label\", \"condition\")]), by = \"label\") %>%\n    mutate(id = paste0(label, \":\", gene_name), method = \"non_impute\") %>%\n    filter(!(id %in% non_nas)) %>%\n    select(!id)\n\n# Check the distribution of imputation values of NAs under each method\np <- ggplot(bind_rows(imps, non_imps), aes(x = value, y = factor(method, level = unique(method)))) +\n    geom_density_ridges(\n        fill = \"#027AD450\", scale = 1.2,\n        jittered_points = TRUE, position = position_points_jitter(height = 0),\n        point_shape = \"|\", point_size = 2, point_alpha = 1, alpha = 0.7\n    ) +\n    ylab(\"Impute method\") +\n    xlab(\"log2 Intensity\") +\n    theme_classic()\nppreview(p, file = file.path(output_dir, \"impute_density.pdf\"))\n\n\n## 5. Hypothesis testing\n# T-test using limma\n# Test all the other samples vs. control\ncontrol_sample <- \"Control\"\npadj_th <- 0.05\nlfc_th <- 1\n\ncontrast <- \"BTN3A2_vs_Control\"\n\npair <- strsplit(contrast, \"_vs_\")[[1]]\nfor (m in names(impute_se_ls)) {\n    impute_se <- impute_se_ls[[m]]\n\n    diff_se <- test_diff(impute_se, type = \"control\", control = control_sample, fdr.type = \"BH\")\n    sig_se <- add_rejections(diff_se, alpha = padj_th, lfc = lfc_th)\n    saveRDS(sig_se, file = file.path(output_dir, paste0(contrast, \"_\", m, \"_de.rds\")))\n\n    clean_degs <- as.data.frame(sig_se@elementMetadata)\n    names(clean_degs)[grep(\"_diff$\", names(clean_degs))] <- \"log2FoldChange\"\n    names(clean_degs)[grep(\"_p.adj$\", names(clean_degs))] <- \"padj\"\n    clean_degs <- clean_degs %>%\n        group_by(gene_name) %>%\n        slice_min(num_NAs) %>%\n        slice_max(sequence_number) %>%\n        slice_min(padj) %>%\n        slice_max(log2FoldChange) %>%\n        slice_sample(n = 1) %>%\n        ungroup() %>%\n        arrange(desc(log2FoldChange)) %>%\n        mutate(diff_flag = if_else(padj < padj_th,\n            if_else(abs(log2FoldChange) > lfc_th,\n                if_else(log2FoldChange > lfc_th,\n                    paste0(pair[1], \" Up\"),\n                    paste0(pair[2], \" Up\")\n                ),\n                \"NO\"\n            ),\n            \"NO\"\n        ))\n\n    vroom_write(clean_degs, file = file.path(output_dir, paste0(contrast, \"_\", m, \"_de.tsv\")))\n\n    p <- plot_volcano(sig_se, contrast = contrast, adjusted = T, add_threshold_line = \"intersect\", pCutoff = padj_th, fcCutoff = lfc_th, add_names = F)\n    ppreview(p, file = file.path(output_dir, paste0(contrast, \"_\", m, \"_volcano.pdf\")))\n\n    p <- plot_heatmap(sig_se, manual_contrast = contrast, kmeans = T, k = 2, split_order = c(2, 1), show_row_names = F, show_row_dend = F, heatmap_width = unit(6, \"cm\"), heatmap_height = unit(0.04, \"mm\") * nrow(sig_se@elementMetadata))\n    ppreview(p, file = file.path(output_dir, paste0(contrast, \"_\", m, \"_heatmap.pdf\")))\n}\n```\n:::\n\n\n\n\n### Only using `limma` package\n\nFor the following two methods, there must be two columns with names `protein_name` (which must be unique) and `gene_name` in the expression table file, in which all sample column names must be in the form `ID_repN`, which will be matched using the regular expression `[a-zA-Z0-9]+_rep[0-9]+`.\n\n1. Compare two samples at a time\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(vroom)\nlibrary(limma)\nlibrary(tidyverse)\nlibrary(magrittr)\n\nexpr_file <- \"expression_sheet.tsv\"\n# keep those proteins detected in at least N replicates in at least one sample\nmin_expr_num <- 2\npadj_th <- 0.05\nlogfc_th <- 1\n# the first is the control sample\ngroup_levels <- c(\"WT\", \"S541N\")\n\nexpr_df <- vroom(expr_file) %>%\n    as.data.frame() %>%\n    set_rownames(.[[\"protein_name\"]])\n\nsamples <- names(expr_df)[str_detect(names(expr_df), \"[a-zA-Z0-9]+_rep[0-9]+\")]\nnames(samples) <- gsub(\"_rep[0-9]+$\", \"\", samples)\n\nexpr_mat <- expr_df[, samples]\nexpr_mat[is.na(expr_mat)] <- 0\n\nflag <- rep(FALSE, nrow(expr_mat))\nfor (group in unique(names(samples))) {\n    flag <- flag | (rowSums(expr_mat[, samples[names(samples) == group]] > 0) >= min_expr_num)\n}\nexpr_mat <- expr_mat[flag, ]\n\nexpr_mat_long_df <- expr_mat %>%\n    mutate(protein_name = row.names(.)) %>%\n    pivot_longer(cols = -protein_name, names_to = \"sample\", values_to = \"value\") %>%\n    mutate(group = gsub(\"_rep[0-9]+$\", \"\", sample))\n\nmean_df <- expr_mat_long_df %>%\n    filter(value != 0) %>%\n    group_by(protein_name, group) %>%\n    reframe(mean = mean(value))\n\nexpr_mat_filled_df <- left_join(expr_mat_long_df, mean_df, by = c(\"protein_name\", \"group\")) %>%\n    mutate(value = if_else(!is.na(mean) & (value == 0), mean, value))\n\nexpr_mat <- expr_mat_filled_df %>%\n    select(-all_of(c(\"group\", \"mean\"))) %>%\n    pivot_wider(names_from = \"sample\", values_from = \"value\") %>%\n    as.data.frame() %>%\n    set_rownames(.[[\"protein_name\"]]) %>%\n    select(-protein_name)\n\nexpr_mat <- expr_mat[, samples]\nexpr_df <- inner_join(expr_df, expr_mat %>% mutate(protein_name = row.names(.)), suffix = c(\".raw\", \".mean_filled\"), by = \"protein_name\")\n\nexpr_mat <- log2(expr_mat + 1)\n\ngroup_list <- factor(names(samples), levels = group_levels)\ndesign <- model.matrix(~ 0 + group_list)\ncolnames(design) <- levels(group_list)\nrow.names(design) <- colnames(expr_mat)\n\ncontrasts <- t(combn(group_levels, 2)) %>%\n    as.data.frame() %>%\n    mutate(contrast = paste0(V2, \"-\", V1)) %>%\n    pull(contrast)\n\nfit <- lmFit(expr_mat, design)\ncontrast_matrix <- makeContrasts(contrasts = contrasts, levels = design)\nfit2 <- contrasts.fit(fit, contrast_matrix)\nfit2 <- eBayes(fit2, trend = TRUE, robust = TRUE)\n\n# check valid coefficients\ncolnames(fit2$coefficients)\n\ncoef <- \"S541N-WT\"\n\nres <- topTable(fit2, coef = coef, number = Inf) %>%\n    mutate(protein_name = row.names(.))\n\nres <- inner_join(expr_df, res, by = \"protein_name\") %>%\n    mutate(\n        P.Value = if_else(P.Value == 0, .Machine$double.xmin, P.Value),\n        adj.P.Val = if_else(adj.P.Val == 0, .Machine$double.xmin, adj.P.Val),\n        diff_flag = if_else(adj.P.Val < 0.05,\n            if_else(abs(logFC) > logfc_th,\n                if_else(logFC > logfc_th, paste0(strsplit(coef, \"-\")[[1]][1], \" Up\"), paste0(strsplit(coef, \"-\")[[1]][2], \" Up\")),\n                \"NO\"\n            ),\n            \"NO\"\n        )\n    ) %>%\n    arrange(diff_flag)\n\nvroom_write(res, file = paste0(coef, \".tsv\"), col_names = TRUE, append = FALSE)\n```\n:::\n\n\n\n\n2. Compare all possible pairs at a time\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(vroom)\nlibrary(limma)\nlibrary(tidyverse)\nlibrary(magrittr)\nlibrary(gtools)\n\nwork_dir <- \"test\"\nexpr_file <- \"xbf_expression_sheet.tsv\"\n# keep those proteins detected in at least N replicates in at least one sample\nmin_expr_num <- 2\npadj_th <- 0.05\nlogfc_th <- 1\n\nsetwd(work_dir)\n\nexpr_df <- vroom(expr_file) %>%\n    as.data.frame() %>%\n    set_rownames(.[[\"protein_name\"]])\n\nsamples <- names(expr_df)[str_detect(names(expr_df), \"[a-zA-Z0-9]+_rep[0-9]+\")]\nnames(samples) <- gsub(\"_rep[0-9]+$\", \"\", samples)\nsample_pair_combns <- permutations(length(unique(names(samples))), 2, v = unique(names(samples)))\n\nfor (i in seq_len(nrow(sample_pair_combns))) {\n    group_levels <- sample_pair_combns[i, ]\n    pair_samples <- samples[names(samples) %in% group_levels]\n\n    expr_mat <- expr_df[, pair_samples]\n    expr_mat[is.na(expr_mat)] <- 0\n\n    flag <- rep(FALSE, nrow(expr_mat))\n    for (group in group_levels) {\n        flag <- flag | (rowSums(expr_mat[, samples[names(samples) == group]] > 0) >= min_expr_num)\n    }\n    expr_mat <- expr_mat[flag, ]\n\n    expr_mat_long_df <- expr_mat %>%\n        mutate(protein_name = row.names(.)) %>%\n        pivot_longer(cols = -protein_name, names_to = \"sample\", values_to = \"value\") %>%\n        mutate(group = gsub(\"_rep[0-9]+$\", \"\", sample))\n\n    mean_df <- expr_mat_long_df %>%\n        filter(value != 0) %>%\n        group_by(protein_name, group) %>%\n        reframe(mean = mean(value))\n\n    expr_mat_filled_df <- left_join(expr_mat_long_df, mean_df, by = c(\"protein_name\", \"group\")) %>%\n        mutate(value = if_else(!is.na(mean) & (value == 0), mean, value))\n\n    expr_mat <- expr_mat_filled_df %>%\n        select(-all_of(c(\"group\", \"mean\"))) %>%\n        pivot_wider(names_from = \"sample\", values_from = \"value\") %>%\n        as.data.frame() %>%\n        set_rownames(.[[\"protein_name\"]]) %>%\n        select(-protein_name)\n\n    expr_mat <- expr_mat[, pair_samples]\n    expr_mat <- log2(expr_mat + 1)\n\n    group_list <- factor(names(pair_samples), levels = group_levels)\n    design <- model.matrix(~ 0 + group_list)\n    colnames(design) <- levels(group_list)\n    row.names(design) <- colnames(expr_mat)\n\n    contrasts <- t(combn(group_levels, 2)) %>%\n        as.data.frame() %>%\n        mutate(contrast = paste0(V2, \"-\", V1)) %>%\n        pull(contrast)\n\n    fit <- lmFit(expr_mat, design)\n    contrast_matrix <- makeContrasts(contrasts = contrasts, levels = design)\n    fit2 <- contrasts.fit(fit, contrast_matrix)\n    fit2 <- eBayes(fit2, trend = TRUE, robust = TRUE)\n\n    coef <- colnames(fit2$coefficients)\n\n    res <- topTable(fit2, coef = coef, number = Inf) %>%\n        mutate(protein_name = row.names(.))\n\n    res <- inner_join(expr_df[, c(\"protein_name\", \"gene_name\")], res, by = \"protein_name\") %>%\n        mutate(\n            P.Value = if_else(P.Value == 0, .Machine$double.xmin, P.Value),\n            adj.P.Val = if_else(adj.P.Val == 0, .Machine$double.xmin, adj.P.Val),\n            diff_flag = if_else(adj.P.Val < 0.05,\n                if_else(abs(logFC) > logfc_th,\n                    if_else(logFC > logfc_th, paste0(strsplit(coef, \"-\")[[1]][1], \" Up\"), paste0(strsplit(coef, \"-\")[[1]][2], \" Up\")),\n                    \"NO\"\n                ),\n                \"NO\"\n            )\n        ) %>%\n        arrange(diff_flag)\n\n    vroom_write(res, file = paste0(gsub(\"-\", \"_vs_\", coef), \".tsv\"), col_names = TRUE, append = FALSE)\n}\n```\n:::\n\n\n\n\n## Merge DE files\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(vroom)\nlibrary(tidyverse)\n\nfiles <- c(\n    \"input/BTN3A2_proteomic_quantification_data.all_vs_none.tsv\",\n    \"de/BTN3A2_vs_Control_bpca_de.tsv\"\n)\noutput_file <- \"de/BTN3A2_vs_Control_bpca_de.all_vs_none.tsv\"\n\ndf <- tibble()\nfor (file in files) {\n    df <- bind_rows(\n        df,\n        vroom(file) %>%\n            select(protein_name, gene_name, diff_flag) %>%\n            filter(diff_flag != \"NO\")\n    )\n}\ndf <- distinct(df) %>%\n    arrange(diff_flag)\n\nvroom_write(df, file = output_file, col_names = TRUE, append = FALSE)\n```\n:::\n\n\n\n\n## Retrieve sub-cellular location info from UniProt and Synaptome database\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(vroom)\nlibrary(glue)\nlibrary(tidyverse)\nlibrary(rvest)\nlibrary(stringr)\nlibrary(synaptome.db)\n\norganism_id <- 10116\nurl_template <- \"https://rest.uniprot.org/uniprotkb/search?query=(accession:{accession})%20AND%20(active:true)%20AND%20(organism_id:{organism_id})&fields=accession,gene_primary,organism_name,organism_id,protein_name,annotation_score,protein_existence,reviewed,ft_intramem,cc_subcellular_location,ft_topo_dom,ft_transmem,go,go_p,go_c,go_f&format=tsv\"\nde_file <- \"de/BTN3A2_vs_Control_bpca_de.all_vs_none.tsv\"\noutput_dir <- \"subcellular_location\"\nkeep_cols <- c(\"protein_name\", \"gene_name\", \"diff_flag\")\nkeep_de_types <- c(\"BTN3A2 Up\", \"Control Up\")\n\ndir.create(output_dir, showWarnings = FALSE, recursive = FALSE)\ndf <- vroom(de_file) %>%\n    select(all_of(keep_cols)) %>%\n    filter(diff_flag %in% keep_de_types)\n\nres_df <- tibble()\nfor (accession in unique(df$protein_name)) {\n    url_instance <- glue(url_template)\n    e <- try(item_raw_text <- read_html(url_instance) %>% html_text(), silent = T)\n    if (\"try-error\" %in% class(e)) {\n        message(\"invalid accession: \", accession)\n    } else {\n        item_df <- vroom(I(item_raw_text), delim = \"\\t\")\n        res_df <- bind_rows(res_df, item_df)\n    }\n}\nres_df <- distinct(res_df)\n\nres_df[[\"scl_secret\"]] <- grepl(\"secret\", res_df[[\"Subcellular location [CC]\"]], ignore.case = TRUE)\nres_df[[\"scl_membrane\"]] <- grepl(\"membrane\", res_df[[\"Subcellular location [CC]\"]], ignore.case = TRUE)\nres_df[[\"scl_secret_membrane\"]] <- res_df[[\"scl_secret\"]] | res_df[[\"scl_membrane\"]]\n\nres_df[[\"uniprot_scl_synapse\"]] <- str_extract_all(res_df[[\"Subcellular location [CC]\"]], regex(\"[\\\\w-]*synap[\\\\w-]*\", ignore_case = TRUE)) %>%\n    sapply(function(x) {\n        paste0(unique(na.omit(x)), collapse = \";\")\n    })\nres_df[[\"uniprot_go_synapse\"]] <- str_extract_all(res_df[[\"Gene Ontology (GO)\"]], regex(\"[\\\\w-]*synap[\\\\w-]*\", ignore_case = T)) %>%\n    sapply(function(x) {\n        paste0(unique(na.omit(x)), collapse = \";\")\n    })\nres_df <- left_join(res_df,\n    findGeneByCompartmentPaperCnt(cnt = 1) %>%\n        filter(RatName %in% res_df[[\"Gene Names (primary)\"]]) %>%\n        select(RatName, Localisation) %>%\n        distinct() %>%\n        group_by(RatName) %>%\n        reframe(synaptome_db_synapse = paste0(unique(Localisation), collapse = \";\")),\n    by = c(\"Gene Names (primary)\" = \"RatName\")\n)\nres_df[[\"final_synapse\"]] <- apply(res_df, 1, function(x) {\n    vec <- na.omit(c(x[\"uniprot_scl_synapse\"], x[\"uniprot_go_synapse\"], x[\"synaptome_db_synapse\"]))\n    paste0(vec[vec != \"\"], collapse = \";\")\n}, simplify = T)\nres_df[[\"scl_secret_membrane_final_synapse\"]] <- res_df[[\"scl_secret_membrane\"]] & (res_df[[\"final_synapse\"]] != \"\")\n\ntarget_res_df <- filter(res_df, scl_secret_membrane_final_synapse)\ntarget_res_df[[\"final_synapse_label\"]] <- sapply(target_res_df[[\"final_synapse\"]], function(x) {\n    vec <- NA\n    if (grepl(\"postsynap|post-synap\", x, ignore.case = TRUE)) {\n        vec <- c(vec, \"Postsynapse\")\n    }\n    if (grepl(\"presynap|pre-synap\", x, ignore.case = TRUE)) {\n        vec <- c(vec, \"Presynapse\")\n    }\n    if (grepl(\"synap\", x, ignore.case = TRUE)) {\n        vec <- c(vec, \"Synapse\")\n    }\n    if (grepl(\"Synaptic_Vesicle\", x, ignore.case = TRUE)) {\n        vec <- c(vec, \"Synaptic vesicle\")\n    }\n    vec <- na.omit(vec)\n    if (length(vec) == 0) {\n        stop(\"no matching\")\n    }\n    if (length(vec) > 1) {\n        vec <- vec[vec != \"Synapse\"]\n    }\n    paste0(sort(unique(vec)), collapse = \"/\")\n})\n\nres_df <- inner_join(df, res_df, by = c(\"protein_name\" = \"Entry\"))\ntarget_res_df <- inner_join(df, target_res_df, by = c(\"protein_name\" = \"Entry\"))\nvroom_write(res_df, file = file.path(output_dir, gsub(\"\\\\.\\\\w+$\", \".scl.raw.tsv\", basename(de_file))))\nvroom_write(target_res_df, file = file.path(output_dir, gsub(\"\\\\.\\\\w+$\", \".scl.target.tsv\", basename(de_file))))\n```\n:::\n\n\n\n\n## GO enrichment analysis\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(vroom)\nlibrary(tidyverse)\nlibrary(clusterProfiler)\nlibrary(AnnotationDbi)\n\ngo_db_file <- \"/data/biodatabase/species/mRatBN7/genome/anno/org.Rn.eg.db.sqlite\"\ndegs_file <- \"de/BTN3A2_vs_Control_bpca_de.all_vs_none.tsv\"\nroot_dir <- \"go\"\n\noutput_dir <- file.path(root_dir, gsub(\"\\\\.\\\\w+$\", \"\", basename(degs_file)))\ndir.create(output_dir, recursive = TRUE)\n\ndegs <- vroom(degs_file)\ngene_set_ls <- degs[, c(\"gene_name\", \"diff_flag\")] %>%\n    filter(diff_flag != \"NO\") %>%\n    split(.[[\"diff_flag\"]]) %>%\n    lapply(function(x) {\n        unique(na.omit(x[[\"gene_name\"]]))\n    })\n\norgdb <- loadDb(go_db_file)\nego <- compareCluster(gene_set_ls,\n    fun = \"enrichGO\",\n    keyType = \"SYMBOL\",\n    OrgDb = orgdb,\n    ont = \"ALL\",\n    pAdjustMethod = \"BH\",\n    minGSSize = 10,\n    maxGSSize = 1000,\n    pvalueCutoff = 0.05,\n    qvalueCutoff = 0.05,\n    readable = FALSE,\n    pool = FALSE\n)\nnrow(ego@compareClusterResult)\n\nsaveRDS(ego, file = file.path(output_dir, \"GO_ALL.rds\"))\nvroom_write(ego@compareClusterResult,\n    file = file.path(output_dir, \"GO_ALL.tsv\"),\n    col_names = TRUE, append = FALSE\n)\n```\n:::\n\n\n\n\n## Plot expression heatmap\n\nThe followings are just various examples:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ComplexHeatmap)\nlibrary(vroom)\nlibrary(tidyverse)\nlibrary(magrittr)\nlibrary(circlize)\nlibrary(YRUtils)\n\nsample_file <- \"/data/users/yangrui/lab_projs/lym_new/input/sample_sheet.tsv\"\ngene_file <- \"/data/users/yangrui/lab_projs/lym_new/de/BTN3A2_vs_Control_bpca_de.all_vs_none.tsv\"\nquant_file <- \"/data/users/yangrui/lab_projs/lym_new/input/BTN3A2_proteomic_quantification_data.tsv\"\nlabel_file <- \"/data/users/yangrui/lab_projs/lym_new/subcellular_location/BTN3A2_vs_Control_bpca_de.all_vs_none.scl.target.cys.tsv\"\noutput_dir <- \"/home/yangrui/temp\"\n\nsample_df <- vroom(sample_file)\ngene_df <- vroom(gene_file) %>%\n    filter(diff_flag == \"BTN3A2 Up\")\nlabel_df <- vroom(label_file)\n\nquant_df <- vroom(quant_file) %>%\n    select(all_of(c(\"protein_name\", sample_df$sample))) %>%\n    filter(protein_name %in% gene_df$protein_name) %>%\n    as.data.frame() %>%\n    set_rownames(.[[\"protein_name\"]]) %>%\n    select(-protein_name)\nquant_df[is.na(quant_df)] <- 0\nquant_mat <- scale(t(log2(quant_df + 1)))\n\ncol_fun <- colorRamp2(c(floor(min(quant_mat)), 0, ceiling(max(quant_mat))), c(\"skyblue\", \"white\", \"orange\"))\nrow_order <- c(\"BTN3A2_1\", \"BTN3A2_2\", \"BTN3A2_3\", \"Control_1\", \"Control_2\", \"Control_3\")\nrow_split <- gsub(\"_\\\\d+$\", \"\", row.names(quant_mat))\nrow_anno <- rowAnnotation(\n    Sample = gsub(\"_\\\\d+$\", \"\", row.names(quant_mat)),\n    show_legend = FALSE,\n    show_annotation_name = FALSE,\n    simple_anno_size = unit(3, \"mm\"),\n    col = list(Sample = c(\"BTN3A2\" = \"orange\", \"Control\" = \"skyblue\"))\n)\ncol_anno <- columnAnnotation(\n    Gene = anno_mark(\n        at = sapply(label_df$protein_name, function(x) {\n            which(colnames(quant_mat) == x)\n        },\n        simplify = TRUE, USE.NAMES = FALSE\n        ),\n        labels = label_df$gene_name\n    )\n)\n\np <- Heatmap(\n    quant_mat,\n    col = col_fun,\n    cluster_columns = TRUE,\n    cluster_column_slices = TRUE,\n    cluster_rows = FALSE,\n    cluster_row_slices = FALSE,\n    show_column_names = FALSE,\n    show_column_dend = FALSE,\n    show_row_names = FALSE,\n    row_order = row_order,\n    row_names_side = \"left\",\n    row_split = row_split,\n    row_gap = unit(0, \"mm\"),\n    left_annotation = row_anno,\n    top_annotation = col_anno,\n    heatmap_legend_param = list(title = \"Expression\")\n)\nppreview(p, file = file.path(output_dir, \"heatmap.pdf\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ComplexHeatmap)\nlibrary(vroom)\nlibrary(tidyverse)\nlibrary(magrittr)\nlibrary(circlize)\nlibrary(YRUtils)\n\nquant_file <- \"temp/S541N-WT.tsv\"\nlabeled_genes <- c(\"Ddx5\", \"Gapdh\", \"Actb\", \"Actg1\", \"Actn1\", \"Dhx9\", \"Draxin\", \"Pelp1\", \"Hnrnpa3\")\noutput_dir <- \"temp\"\n\nsample_df <- expand.grid(c(\"S541N\", \"WT\"), \"_rep\", 1:3, \".raw\") %>%\n    mutate(sample = paste0(Var1, Var2, Var3, Var4)) %>%\n    rename(group = Var1) %>%\n    select(group, sample)\nquant_df <- vroom(quant_file) %>%\n    filter(diff_flag == \"S541N Up\") %>%\n    select(all_of(c(\"protein_name\", \"gene_name\", sample_df$sample))) %>%\n    as.data.frame() %>%\n    set_rownames(.[[\"protein_name\"]])\n\nquant_mat <- quant_df %>%\n    select(-protein_name, -gene_name)\nquant_mat[is.na(quant_mat)] <- 0\nquant_mat <- scale(t(log2(quant_mat + 1)))\n\ncol_fun <- colorRamp2(c(floor(min(quant_mat)), 0, ceiling(max(quant_mat))), c(\"skyblue\", \"white\", \"orange\"))\nrow_order <- c(\"S541N_rep1.raw\", \"S541N_rep2.raw\", \"S541N_rep3.raw\", \"WT_rep1.raw\", \"WT_rep2.raw\", \"WT_rep3.raw\")\nrow_split <- gsub(\"_rep\\\\d+.raw$\", \"\", row.names(quant_mat))\nleft_anno <- rowAnnotation(\n    Sample = gsub(\"_rep\\\\d+.raw$\", \"\", row.names(quant_mat)),\n    show_legend = FALSE,\n    show_annotation_name = FALSE,\n    simple_anno_size = unit(3, \"mm\"),\n    col = list(Sample = c(\"S541N\" = \"#EE6A50\", \"WT\" = \"#76EEC6\"))\n)\n\nquant_df <- quant_df %>%\n    mutate(\n        group = if_else(is.na(gene_name), \"Other\",\n            if_else(str_detect(gene_name, \"^Rpl\"), \"Rpl\",\n                if_else(str_detect(gene_name, \"^Rps\"), \"Rps\",\n                    if_else(str_detect(gene_name, \"^Tuba\"), \"Tuba\",\n                        if_else(str_detect(gene_name, \"^Tubb\"), \"Tubb\", \"Other\")\n                    )\n                )\n            )\n        ),\n        group = factor(group, levels = c(\"Rpl\", \"Rps\", \"Tuba\", \"Tubb\", \"Other\"))\n    )\ncolumn_split <- quant_df$group\nbottom_anno <- columnAnnotation(\n    Group = quant_df$group,\n    show_legend = TRUE,\n    show_annotation_name = FALSE,\n    simple_anno_size = unit(3, \"mm\"),\n    col = list(Group = c(\"Rpl\" = \"#B23AEE\", \"Rps\" = \"#B4EEB4\", \"Tuba\" = \"#EE7600\", \"Tubb\" = \"#00B2EE\", \"Other\" = \"#EEA2AD\"))\n)\n\nlabel_df <- filter(quant_df, gene_name %in% labeled_genes) %>%\n    select(protein_name, gene_name)\ntop_anno <- columnAnnotation(\n    Gene = anno_mark(\n        at = sapply(label_df$protein_name, function(x) {\n            which(colnames(quant_mat) == x)\n        },\n        simplify = TRUE, USE.NAMES = FALSE\n        ),\n        labels = label_df$gene_name\n    )\n)\n\np <- Heatmap(\n    quant_mat,\n    col = col_fun,\n    cluster_columns = TRUE,\n    cluster_column_slices = FALSE,\n    cluster_rows = FALSE,\n    cluster_row_slices = FALSE,\n    show_column_names = FALSE,\n    show_column_dend = FALSE,\n    show_row_names = FALSE,\n    row_order = row_order,\n    row_names_side = \"left\",\n    row_split = row_split,\n    row_gap = unit(0, \"mm\"),\n    column_gap = unit(0, \"mm\"),\n    column_split = column_split,\n    left_annotation = left_anno,\n    top_annotation = top_anno,\n    bottom_annotation = bottom_anno,\n    column_title = NULL,\n    column_title_rot = 90,\n    column_title_side = \"bottom\",\n    heatmap_legend_param = list(title = \"scaled LFQ intensity\")\n)\n\nppreview(p, file = file.path(output_dir, \"heatmap.pdf\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ComplexHeatmap)\nlibrary(vroom)\nlibrary(tidyverse)\nlibrary(magrittr)\nlibrary(circlize)\nlibrary(YRUtils)\n\nquant_file <- \"temp/data.tsv\"\noutput_dir <- \"temp\"\n\nquant_df <- vroom(quant_file) %>%\n    as.data.frame() %>%\n    set_rownames(.[[\"protein\"]]) %>%\n    select(-protein)\n\ncol_fun <- colorRamp2(c(floor(min(quant_df) * 10) / 10, 1.0, ceiling(max(quant_df) * 10) / 10), c(\"skyblue\", \"white\", \"orange\"))\ncolumn_order <- c(\n    \"WT\",\n    \"P152A\", \"H70Q\", \"A200V\", \"Y48N\", \"A200T\",\n    \"D99G\", \"L04P\", \"N199I\", \"N199H\", \"L54P\", \"K217R\", \"R18K\", \"R198Q\", \"R213W\",\n    \"C203S\", \"C206F\", \"C206Y\", \"V63L\", \"L66H\", \"P201S\", \"K209N\", \"R112P\", \"Q82H\"\n)\ncolumn_order_df <- tibble(\n    cluster = c(\"WT\", rep(\"NO\", 5), rep(\"LOF\", 9), rep(\"GOF\", 9)),\n    protein = column_order\n) %>%\n    mutate(\n        cluster = factor(cluster, levels = c(\"WT\", \"NO\", \"LOF\", \"GOF\")),\n        protein = factor(protein, levels = colnames(quant_df))\n    ) %>%\n    arrange(protein)\nrow_order <- c(\"GluA1_rep1\", \"GluA1_rep2\", \"GluA1_rep3\", \"GluA2_rep1\", \"GluA2_rep2\", \"GluA2_rep3\", \"GABAARAlpha1_rep1\", \"GABAARAlpha1_rep2\", \"GABAARAlpha1_rep3\", \"GABAARBeta1_rep1\", \"GABAARBeta1_rep2\", \"GABAARBeta1_rep3\")\nrow_split <- gsub(\"_rep\\\\d+$\", \"\", row.names(quant_df))\nrow_split <- factor(row_split, levels = unique(row_split))\nleft_anno <- rowAnnotation(\n    Sample = gsub(\"_rep\\\\d+$\", \"\", row.names(quant_df)),\n    show_legend = FALSE,\n    show_annotation_name = FALSE,\n    simple_anno_size = unit(3, \"mm\"),\n    col = list(Sample = c(\"GluA1\" = \"#76EEC6\", \"GluA2\" = \"#EEAEEE\", \"GABAARAlpha1\" = \"#9F79EE\", \"GABAARBeta1\" = \"#EE799F\"))\n)\ntop_anno <- columnAnnotation(\n    Type = column_order_df$cluster,\n    show_legend = FALSE,\n    show_annotation_name = FALSE,\n    simple_anno_size = unit(3, \"mm\"),\n    col = list(Type = c(\"WT\" = \"#BEBEBE\", \"NO\" = \"#EED8AE\", \"LOF\" = \"#EE8262\", \"GOF\" = \"#BCD2EE\"))\n)\nfont_family <- \"Arial\"\n\n# `gpar()` is used to handle grid graphical parameters\n# for how to use `gpar()`, see `?gpar`\n# for ComplexHeatmap, you can set some parameters globally using `ht_opt`\n# e.g. `ht_opt$legend_title_gp <- gpar(fontfamily = \"Times New Roman\")`\np <- Heatmap(\n    quant_df,\n    col = col_fun,\n    cluster_columns = FALSE,\n    cluster_column_slices = FALSE,\n    cluster_rows = FALSE,\n    cluster_row_slices = FALSE,\n    show_column_names = TRUE,\n    show_column_dend = FALSE,\n    show_row_names = FALSE,\n    show_row_dend = FALSE,\n    column_order = column_order,\n    column_split = column_order_df$cluster,\n    row_order = row_order,\n    row_split = row_split,\n    row_gap = unit(0.8, \"mm\"),\n    column_gap = unit(0.8, \"mm\"),\n    left_annotation = left_anno,\n    top_anno = top_anno,\n    height = nrow(quant_df) * unit(5, \"mm\"),\n    width = ncol(quant_df) * unit(5, \"mm\"),\n    column_title_rot = 90,\n    row_title_rot = 0,\n    heatmap_legend_param = list(\n        title = \"normalized expression level\",\n        title_gp = gpar(fontfamily = font_family),\n        labels_gp = gpar(fontfamily = font_family)\n    ),\n    row_names_gp = gpar(fontfamily = font_family),\n    column_names_gp = gpar(fontfamily = font_family),\n    row_title_gp = gpar(fontfamily = font_family),\n    column_title_gp = gpar(fontfamily = font_family)\n)\nppreview(p, file = file.path(output_dir, \"heatmap.pdf\"))\n```\n:::\n\n\n\n\n## Some examples about usages of UniProt and STRING APIs\n\n1. Retrieve subcellular locations and interactions from UniProt\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(vroom)\nlibrary(glue)\nlibrary(tidyverse)\nlibrary(rvest)\nlibrary(stringr)\n\nwork_dir <- \"test\"\norganism_id <- 9606\nurl_template <- \"https://rest.uniprot.org/uniprotkb/search?query=(accession:{accession})%20AND%20(active:true)%20AND%20(organism_id:{organism_id})&fields=accession,gene_primary,organism_name,organism_id,protein_name,annotation_score,protein_existence,reviewed,ft_intramem,cc_subcellular_location,ft_topo_dom,ft_transmem,go,go_p,go_c,go_f,cc_interaction&format=tsv\"\nde_file <- \"degs/xbfGlia_vs_xbfAstro.tsv\"\noutput_dir <- \"subcellular_locations_and_interactions\"\n\nsetwd(work_dir)\ndir.create(output_dir, showWarnings = FALSE, recursive = FALSE)\n\ndf <- vroom(de_file) %>%\n    select(all_of(c(\"protein_name\", \"gene_name\", \"diff_flag\"))) %>%\n    filter(diff_flag != \"NO\")\n\nres_df <- tibble()\nfor (accession in unique(df$protein_name)) {\n    url_instance <- glue(url_template)\n    e <- try(item_raw_text <- read_html(url_instance) %>% html_text(), silent = T)\n    if (\"try-error\" %in% class(e)) {\n        message(\"invalid accession: \", accession)\n    } else {\n        item_df <- vroom(I(item_raw_text), delim = \"\\t\") %>%\n            mutate(\n                `Organism (ID)` = as.integer(`Organism (ID)`),\n                Annotation = as.integer(Annotation)\n            )\n        res_df <- bind_rows(res_df, item_df)\n    }\n}\nres_df <- distinct(res_df)\n\nres_df[[\"scl_secret\"]] <- grepl(\"secret\", res_df[[\"Subcellular location [CC]\"]], ignore.case = TRUE)\nres_df[[\"scl_membrane\"]] <- grepl(\"membrane\", res_df[[\"Subcellular location [CC]\"]], ignore.case = TRUE)\nres_df[[\"scl_extracellular\"]] <- grepl(\"extracellular\", res_df[[\"Subcellular location [CC]\"]], ignore.case = TRUE)\nres_df[[\"scl_pass\"]] <- res_df[[\"scl_secret\"]] | res_df[[\"scl_membrane\"]] | res_df[[\"scl_extracellular\"]]\n\nres_df <- filter(res_df, scl_pass)\nnrow(res_df)\n\nres_df <- inner_join(df, res_df, by = c(\"protein_name\" = \"Entry\")) %>%\n    arrange(diff_flag)\nvroom_write(res_df, file = file.path(output_dir, gsub(\"\\\\.(txt|tsv)$\", \".secreted.tsv\", basename(de_file))), col_names = TRUE, append = FALSE)\n\nres_df <- res_df %>%\n    separate_rows(all_of(\"Interacts with\"), sep = \"; \") %>%\n    mutate(\n        interacted_protein = `Interacts with`,\n        interacted_protein = if_else(\n            str_detect(interacted_protein, \".*\\\\[[a-zA-Z0-9-]+\\\\]$\"),\n            str_extract(interacted_protein, \"(?<=\\\\[)[a-zA-Z0-9-]+(?=\\\\])\"),\n            interacted_protein\n        ),\n        interacted_protein = gsub(\"-[0-9]+$\", \"\", interacted_protein)\n    ) %>%\n    filter(!is.na(interacted_protein))\n\ninteract_res_df <- tibble()\nfor (accession in unique(res_df[[\"interacted_protein\"]])) {\n    url_instance <- glue(url_template)\n    e <- try(item_raw_text <- read_html(url_instance) %>% html_text(), silent = T)\n    if (\"try-error\" %in% class(e)) {\n        message(\"invalid accession: \", accession)\n    } else {\n        item_df <- vroom(I(item_raw_text), delim = \"\\t\") %>%\n            mutate(\n                `Organism (ID)` = as.integer(`Organism (ID)`),\n                Annotation = as.integer(Annotation)\n            )\n        interact_res_df <- bind_rows(interact_res_df, item_df)\n    }\n}\ninteract_res_df <- distinct(interact_res_df)\n\ninteract_res_df[[\"scl_secret\"]] <- grepl(\"secret\", interact_res_df[[\"Subcellular location [CC]\"]], ignore.case = TRUE)\ninteract_res_df[[\"scl_membrane\"]] <- grepl(\"membrane\", interact_res_df[[\"Subcellular location [CC]\"]], ignore.case = TRUE)\ninteract_res_df[[\"scl_extracellular\"]] <- grepl(\"extracellular\", interact_res_df[[\"Subcellular location [CC]\"]], ignore.case = TRUE)\ninteract_res_df[[\"scl_pass\"]] <- interact_res_df[[\"scl_secret\"]] | interact_res_df[[\"scl_membrane\"]] | interact_res_df[[\"scl_extracellular\"]]\n\ninteract_res_df <- filter(interact_res_df, scl_pass) %>%\n    mutate(interact_database = \"UniProt\")\nnrow(interact_res_df)\n\nfinal_res_df <- inner_join(res_df, interact_res_df, by = c(\"interacted_protein\" = \"Entry\"), suffix = c(\".dep\", \".interacted\"))\nvroom_write(final_res_df, file = file.path(output_dir, gsub(\"\\\\.(txt|tsv)$\", \".interacted.uniprot.tsv\", basename(de_file))), col_names = TRUE, append = FALSE)\n```\n:::\n\n\n\n\n2. Retrieve protein interactions from STRING\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(vroom)\nlibrary(glue)\nlibrary(tidyverse)\nlibrary(rvest)\nlibrary(stringr)\nlibrary(jsonlite)\n\nwork_dir <- \"test\"\norganism_id <- 9606\nurl_template <- \"https://rest.uniprot.org/uniprotkb/search?query=(accession:{accession})%20AND%20(active:true)%20AND%20(organism_id:{organism_id})&fields=accession,gene_primary,organism_name,organism_id,protein_name,annotation_score,protein_existence,reviewed,ft_intramem,cc_subcellular_location,ft_topo_dom,ft_transmem,go,go_p,go_c,go_f,cc_interaction&format=tsv\"\nsubmit_cmd <- \"curl --request POST 'https://rest.uniprot.org/idmapping/run' --form 'ids=\\\"{ids}\\\"' --form 'from=\\\"UniProtKB_AC-ID\\\"' --form 'to=\\\"UniProtKB\\\"'\"\nstatus_cmd <- \"curl -i 'https://rest.uniprot.org/idmapping/status/{submit_cmd_instance_response_job_id}'\"\nresult_cmd <- \"curl -s 'https://rest.uniprot.org/idmapping/results/{submit_cmd_instance_response_job_id}'\"\nmax_length <- 20\nnetwork_file <- \"string_db/9606.protein.physical.links.full.v12.0.txt.gz\"\ninfo_file <- \"string_db/9606.protein.info.v12.0.txt.gz\"\nalias_file <- \"string_db/9606.protein.aliases.v12.0.txt.gz\"\nsecret_file <- \"subcellular_locations_and_interactions/xbfGlia_vs_xbfAstro.secreted.tsv\"\noutput_dir <- \"subcellular_locations_and_interactions\"\n\nsetwd(work_dir)\ndir.create(output_dir, showWarnings = FALSE, recursive = FALSE)\n\ninfo_df <- vroom(info_file) %>%\n    select(all_of(c(\"#string_protein_id\", \"preferred_name\"))) %>%\n    distinct()\n\nsecret_df <- vroom(secret_file) %>%\n    inner_join(info_df, by = c(\"gene_name\" = \"preferred_name\"))\n\nnetwork_df <- vroom(network_file) %>%\n    filter(protein1 %in% secret_df[[\"#string_protein_id\"]]) %>%\n    inner_join(info_df, by = c(\"protein2\" = \"#string_protein_id\"))\n\nsource_levels <- c(\"Ensembl_HGNC_uniprot_ids\", \"UniProt_ID\", \"UniProt_AC\")\nalias_df <- vroom(alias_file) %>%\n    filter((`#string_protein_id` %in% network_df$protein2) & (source %in% source_levels)) %>%\n    mutate(source = factor(source, levels = source_levels)) %>%\n    group_by(`#string_protein_id`) %>%\n    slice_min(source) %>%\n    slice_sample(n = 1) %>%\n    ungroup()\n\nnetwork_df <- inner_join(network_df, alias_df, by = c(\"protein2\" = \"#string_protein_id\"))\n\nuniq_ids <- unique(network_df$alias)\nmpt_df <- tibble()\nfor (id_vec in split(uniq_ids, ceiling(seq_along(uniq_ids) / max_length))) {\n    ids <- paste0(id_vec, collapse = \",\")\n\n    submit_cmd_instance <- glue(submit_cmd)\n    submit_cmd_instance_response <- system(submit_cmd_instance, intern = TRUE, ignore.stdout = FALSE, ignore.stderr = FALSE, wait = TRUE)\n    submit_cmd_instance_response_ls <- fromJSON(submit_cmd_instance_response)\n    submit_cmd_instance_response_job_id <- submit_cmd_instance_response_ls$jobId\n\n    status_cmd_instance <- glue(status_cmd)\n    while (TRUE) {\n        status_cmd_instance_response <- system(status_cmd_instance, intern = TRUE, ignore.stdout = FALSE, ignore.stderr = FALSE, wait = TRUE)\n        status_cmd_instance_response <- trimws(status_cmd_instance_response)\n        status_cmd_instance_response_ls <- fromJSON(status_cmd_instance_response[length(status_cmd_instance_response)])\n        if ((status_cmd_instance_response[1] == \"HTTP/2 303\") && (status_cmd_instance_response_ls$jobStatus == \"FINISHED\")) {\n            message(\"results can be retrieved!\")\n            break\n        }\n        Sys.sleep(3)\n    }\n\n    result_cmd_instance <- glue(result_cmd)\n    result_cmd_instance_response <- system(result_cmd_instance, intern = TRUE, ignore.stdout = FALSE, ignore.stderr = FALSE, wait = TRUE)\n    result_cmd_instance_response_ls <- fromJSON(result_cmd_instance_response)\n    if (length(result_cmd_instance_response_ls$results) == 0) {\n        stop(\"no ID was mapped successfully\")\n    }\n    tmp_df <- result_cmd_instance_response_ls$results\n    mpt_df <- bind_rows(mpt_df, tmp_df)\n}\nmpt_df <- distinct(mpt_df)\n\nnetwork_df <- inner_join(network_df, mpt_df, by = c(\"alias\" = \"from\"))\n\ninteract_res_df <- tibble()\nfor (accession in unique(network_df$to)) {\n    url_instance <- glue(url_template)\n    e <- try(item_raw_text <- read_html(url_instance) %>% html_text(), silent = T)\n    if (\"try-error\" %in% class(e)) {\n        message(\"invalid accession: \", accession)\n    } else {\n        item_df <- vroom(I(item_raw_text), delim = \"\\t\") %>%\n            mutate(\n                `Organism (ID)` = as.integer(`Organism (ID)`),\n                Annotation = as.integer(Annotation)\n            )\n        interact_res_df <- bind_rows(interact_res_df, item_df)\n    }\n}\ninteract_res_df <- distinct(interact_res_df)\n\ninteract_res_df[[\"scl_secret\"]] <- grepl(\"secret\", interact_res_df[[\"Subcellular location [CC]\"]], ignore.case = TRUE)\ninteract_res_df[[\"scl_membrane\"]] <- grepl(\"membrane\", interact_res_df[[\"Subcellular location [CC]\"]], ignore.case = TRUE)\ninteract_res_df[[\"scl_extracellular\"]] <- grepl(\"extracellular\", interact_res_df[[\"Subcellular location [CC]\"]], ignore.case = TRUE)\ninteract_res_df[[\"scl_pass\"]] <- interact_res_df[[\"scl_secret\"]] | interact_res_df[[\"scl_membrane\"]] | interact_res_df[[\"scl_extracellular\"]]\n\ninteract_res_df <- filter(interact_res_df, scl_pass) %>%\n    mutate(interact_database = \"STRING\")\nnrow(interact_res_df)\n\nfinal_res_df <- inner_join(secret_df, network_df, by = c(\"#string_protein_id\" = \"protein1\")) %>%\n    inner_join(interact_res_df, by = c(\"to\" = \"Entry\"), suffix = c(\".dep\", \".interacted\"))\nvroom_write(final_res_df, file = file.path(output_dir, gsub(\"\\\\.secreted\\\\.(txt|tsv)$\", \".interacted.string.tsv\", basename(secret_file))), col_names = TRUE, append = FALSE)\n```\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
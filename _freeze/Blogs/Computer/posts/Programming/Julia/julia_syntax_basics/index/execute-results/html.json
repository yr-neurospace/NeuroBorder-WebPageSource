{
  "hash": "684a9ca7075e2c04dd78242eb7b941d5",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Julia syntax basics\"\nauthor: \"Rui Yang\"\ndate: \"2024-09-22\"\ndate-modified: last-modified\ncategories: [syntax, julia]\nformat:\n  html:\n    toc: true\n    toc-depth: 6\n    toc-location: left\n    fig-align: center\n    number-depth: 6\n    number-sections: true\n    fig-cap-location: bottom\n    fig-format: png\n    lightbox: true\n    tbl-cap-location: top\n    page-layout: full\n\nexecute:\n  warning: false\n\njupyter: julia-1.10\n---\n\n\n## Julia pros and cons\n\n### Pros\n\n-   Interactive programming\n\nJulia is a dynamically typed language, in contrast with statically typed languages.\n\n-   High performance\n\nJulia uses just-in-time compilation (JIT), compilation at run time.\n\nTypically, JIT continuously analyses the code being executed and identifies parts of the code where the speedup gained from compilation or recompilation would outweigh the overhead of compiling that code.\n\nTherefore, JIT combines advantages of ahead-of-time compilation (AOT, compilation before execution) and interpretation.\n\nDue to the ecosystem of packages, Julia is really suitable for scientific computing, but it can also be used as a general-purpose programming language.\n\n### Cons\n\nJulia starts more slowly than Python, R, etc. but begins to run faster once the JIT compiler has converted critical parts of the code to machine code; thus it's not suitable for:\n\n-   Programming small, short-running scripts.\n\n-   Real-time systems (Julia implements automatic garbage collection, which tends to introduce small random delays).\n\n-   System programming (it needs detailed control of resource usage).\n\n-   Embedded systems with limited memory.\n\n## Basics\n\n### Arithmetic operations and number types\n\n#### Arithmetic operations\n\nAddition, subtraction, multiplication, division, and power: `+ - * / ^`.\n\n#### Number types\n\n-   Signed integers: `Int8`, `Int16`, `Int32`, `Int64` (default), `Int128`, `BigInt`.\n\n-   Unsigned integers: `UInt8`, `UInt16`, `UInt32`, `UInt64`, `UInt128`.\n\nYou can check the minimum and maximum values of a certain integer type with `typemin()` and `typemax()`.\n\nYou can check the type of the input argument with `typeof()`.\n\nJulia defaults to showing all signed integers in decimal format, and all unsigned integers in hexadecimal format.\n\nIn fact, what is stored in memory is no difference. The only difference is how to interpret it. You can use the `reinterpret()` function to see how the exactly same bits in memory can be interpreted differently.\n\n-   Floating-point numbers: `Float16`, `Float32`, `Float64` (default).\n\nYou can type a `Float32` number by suffixing `f0`: `3.14f0`.\n\n-   `Rational` type: `2 // 5` represents a rational number $\\frac{2}{5}$.\n\n-   `Complex` type: `1 + 2im`.\n\n#### Arithmetic operations for integers\n\n-   `/` always gives floating-point number\n\n::: {#b3b78617 .cell execution_count=1}\n``` {.julia .cell-code}\n4 / 2\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n2.0\n```\n:::\n:::\n\n\n-   `÷` or `div()` gives the quotient\n\n::: {#c6e0f426 .cell execution_count=2}\n``` {.julia .cell-code}\n5 ÷ 3\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n1\n```\n:::\n:::\n\n\n::: {#3e54f8c6 .cell execution_count=3}\n``` {.julia .cell-code}\ndiv(5, 3)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n1\n```\n:::\n:::\n\n\n-   `%` or `rem()` gives the remainder\n\n::: {#01c02151 .cell execution_count=4}\n``` {.julia .cell-code}\n5 % 3\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n2\n```\n:::\n:::\n\n\n::: {#0ad2df63 .cell execution_count=5}\n``` {.julia .cell-code}\nrem(5, 3)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n2\n```\n:::\n:::\n\n\n-   `divrem()` gives both quotient and remainder\n\n::: {#9dfe318e .cell execution_count=6}\n``` {.julia .cell-code}\ndivrem(5, 3)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n(1, 2)\n```\n:::\n:::\n\n\n::: callout-caution\nTypically, operations on the same type of values always give the same type of value, even though overflow may occur.\n\nEven though overflow will occur, Julia won't give any prompt.\n:::\n\n### Variables\n\nIn julia, identifiers can be used to give names to constants, variables, types, and functions.\n\nVariables defining memory addresses where values are stored, are only references to values, because Julia allocates memory based on values, not variables.\n\nIn comparison with this, statically typed languages allocate memory based on variables, so you must first decalre the type of a variable (e.g., `int`) before using it, which will allocate a predefined size (which depends on the type of the variable) in a predefined location in memory to this variable. As a consequence, you should never attempt to assign a value that cannot fit inside the memory slot set aside for the variable to this variable.\n\n1.  The equal sign (`=`) operator is used to assign values to variables (i.e., let a variable point to a value):\n\n::: {#02bce111 .cell execution_count=7}\n``` {.julia .cell-code}\nx = 1\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n1\n```\n:::\n:::\n\n\n2.  Allowed variable names:\n\n-   Leading characters: letters, underscore, Unicode code points greater than 00A0.\n\n-   Subsequent characters: other Unicode code points.\n\n-   Variable names containing only underscores can only be assigned values, which are immediately discarded.\n\n-   Explicitly disallowed variable names: built-in keywords.\n\n::: callout-tip\nTo type many special characters, like Unicode math symbols, you can type the backslashed LaTeX symbol name followed by tab.\n\nIf you find a symbol elsewhere, which you don't know how to type, the REPL help will tell you: just type ? and then paste the symbol.\n:::\n\n3.  My own rules for clarity:\n\n-   Can only contain letters, underscore, and numbers.\n\n-   Can only start with letters.\n\n4.  Two special variables:\n\n-   Constants: defined with the `const` keyword.\n\n::: {#c27e3ecd .cell execution_count=8}\n``` {.julia .cell-code}\nconst my_pi = 3.14\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n3.14\n```\n:::\n:::\n\n\n::: callout-note\nYou can still assign a new value **with the same type as the original one** to a constant, but a warning is printed.\n:::\n\n-   The `ans` variable: in interactive mode, Julia REPL assigns the value of the last expression to the `ans` (answer) variable.\n\n5.  Literal coefficient\n\nIn mathematics, `3×x + 2×y` may be written as `3x + 2y`. Julia lets you write a multiplication in the same manner. We refer to this as literal coefficient, which is a shorthand for multiplication between **a number literal** and **a constant or variable**:\n\n::: {#1a662fd4 .cell execution_count=9}\n``` {.julia .cell-code}\nx = 3\n2x\n\n2*(3+2)\n2(3+2)\n\n2*π\n2π\n```\n:::\n\n\n### Relation and logical operations\n\n#### Relation operations\n\n`==, != or ≠, <, >, <= or ≤, >= or ≥`\n\nThe operation result is `true` or `false`, which is `Bool` type.\n\n#### Logical operations\n\n`&&, ||, !`\n\nThe logical evaluation is lazy.\n\nSuppose `i = 10`, and then `1 <= i <= 100` is equivalent to `i >= 1 && i <= 100`.\n\n### Control flow\n\n#### Comment\n\nIn Julial, you can give an inline comment by using `#`, or multiline comment by using `#=...=#`.\n\n#### Compound expressions\n\nTo have a single expression which evaluates several subexpressions in order, returning the value of the last subexpression as its value.\n\n1.  `;` chain\n\nPut all subexpressions separated by `;` inside parentheses.\n\n::: {#630aa74e .cell execution_count=10}\n``` {.julia .cell-code}\nz = (x = 1; y = 2; x + y)\n\n# or\nz = (x = 1;\n     y = 2;\n     x + y)\n\nz\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n3\n```\n:::\n:::\n\n\n2.  `begin` block\n\nPut all subexpressions separated by a newline character between `begin` and `end` keywords.\n\nYou can also put all subexpressions in one line by separating them with `;`.\n\n::: {#bec7de4c .cell execution_count=11}\n``` {.julia .cell-code}\nz = begin\n    x = 1\n    y = 2\n    x + y\n    end\n\n# or\nz = begin x = 1; y = 2; x + y end\n\nz\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n3\n```\n:::\n:::\n\n\nThis is quite useful for the inline function definition.\n\n::: callout-note\nFor multiple statements, you can put them in one line and separate them with `;`, which is not the same thing as compound expressions:\n\n::: {#5999c5d0 .cell execution_count=12}\n``` {.julia .cell-code}\nx = 1 + 2; println(\"x=$x\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx=3\n```\n:::\n:::\n\n\n:::\n\n#### Short-circuit evaluation\n\n1.  `cond && expr`: evaluate `expr` if and only if `cond` is `true`.\n\n2.  `cond || expr`: evaluate `expr` if and only if `cond` is `false`.\n\n#### Conditional evaluation\n\n::: {#f1926d5c .cell execution_count=13}\n``` {.julia .cell-code}\nif cond1\n    statements\nelseif cond2\n    statements\n...\nelse\n    statements\nend\n```\n:::\n\n\n::: callout-note\nTernary operator: `cond ? expr1 : expr2`, which is closely equivalent to `if cond expr1 else expr2`.\n:::\n\n#### Looping\n\n1.  `while`\n\n::: {#75263896 .cell execution_count=14}\n``` {.julia .cell-code}\nwhile cond\n    statements\nend\n```\n:::\n\n\n2.  'for'\n\n::: {#b65dc3bb .cell execution_count=15}\n``` {.julia .cell-code}\nfor var in iterable\n    statements\nend\n```\n:::\n\n\nFor `for` loop, `var in iterable`, `var ∈ iterable`, and `var = iterable` are equivalent to one another!\n\n::: {#nte-memberoperator .callout-note title=\"Member operator `in` or `∈`\"}\n1.  `in(collection)` or `∈(collection)` creates a function which checks whether its argument is in collection:\n\n::: {#6ef1288f .cell execution_count=16}\n``` {.julia .cell-code}\nf = in(1:10)\n\nf(1)\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\ntrue\n```\n:::\n:::\n\n\nNote: `start:stop` will generate a number sequence with step 1; `start:step:stop` with step `step`.\n\n2.  `in(item, collection)` or `∈(item, collection)` determines whether an item is in the given collection:\n\n::: {#7ee3f06f .cell execution_count=17}\n``` {.julia .cell-code}\nin(1, 1:10)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\ntrue\n```\n:::\n:::\n\n\n3.  Sets check whether the item is equal to one of the elements:\n\n::: {#7bccc719 .cell execution_count=18}\n``` {.julia .cell-code}\n1 in Set(1:10)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\ntrue\n```\n:::\n:::\n\n\n4.  Dicts look for `key=>value` pairs:\n\n::: {#d2ee511a .cell execution_count=19}\n``` {.julia .cell-code}\n(1=>10) in Dict(1=>10, 2=>20)\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\ntrue\n```\n:::\n:::\n\n\n5.  `in.(items, collection)` or `items .∈ collection` checks whether each value in `items` and each value in `collection` at the corresponding position are the same one:\n\nIf either `items` or `collection` contains only one element, it will be broadcasted to the same length as the longer.\n\n::: {#24a17ae4 .cell execution_count=20}\n``` {.julia .cell-code}\nin.([1, 3, 2], [1, 4, 2])\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n3-element BitVector:\n 1\n 0\n 1\n```\n:::\n:::\n\n\n6.  `in.(items, Ref(collection))` or `items .∈ Ref(collection)` checks whether each value in `items` is in `collection`:\n\n`Ref(collection)` can also be written as `(collection,)` (i.e. wrap `collection` in a tuple or a `Ref`).\n\nNote: create a tuple containing only one element with `(1,)`.\n\n::: {#32a3d7c6 .cell execution_count=21}\n``` {.julia .cell-code}\nin.([1, 3, 2], Ref([8, 6, 1, 4, 3, 2]))\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\n3-element BitVector:\n 1\n 1\n 1\n```\n:::\n:::\n\n\n`in.` does not support infix form!\n\n`in`, `∈`, and `.∈` support both forms!\n\nIn contrary to `∈` (`\\in<tab>`), `∋` (`\\ni<tab>`), and `.∈`, we have, `∉` (`\\notin<tab>`), `∌` (`\\nni<tab>`), and `.∉`.\n:::\n\n#### Jump out of loops\n\n1.  `break`: jump out of the loop in which `break` is.\n\n2.  `continue`: stop an iteration and move on to the next one.\n\n3.  `@goto name` and `@label name`: `@goto name` unconditionally jumps to the statement at the location `@label name`.\n\n### Functions\n\n#### Inline functions\n\n`<function name>(<parameters>) = <expression>`:\n\n::: {#570bdf54 .cell execution_count=22}\n``` {.julia .cell-code}\ncylinder_volume(r, h) = π*r^2*h\n\ncylinder_volume(5, 3)\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n235.61944901923448\n```\n:::\n:::\n\n\n#### Multiline functions\n\n::: {#db7f1222 .cell execution_count=23}\n``` {.julia .cell-code}\nfunction <function name>(parameters)\n    ...\nend\n```\n:::\n\n\nIn Julia, `return <value>` is not necessary. **It is only used when you need to exit a function early; otherwise the value of the last expression will always be returned.**\n\n::: callout-note\nFunctions are central to Julia! Various interfaces are achieved by functions even though they don't look like functions.\n\n-   Infix form\n\n::: {#1b419133 .cell execution_count=24}\n``` {.julia .cell-code}\n5 + 3\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\n8\n```\n:::\n:::\n\n\n-   Prefix form\n\n::: {#e8973d08 .cell execution_count=25}\n``` {.julia .cell-code}\n+(5 + 3 + 5)\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\n13\n```\n:::\n:::\n\n\nIf a function with a symbol name takes two arguments, we can use it by infix form:\n\n::: {#72233da2 .cell execution_count=26}\n``` {.julia .cell-code}\n↔(x, y) = x^2 + y^2\n\n6 ↔ 6\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\n72\n```\n:::\n:::\n\n\n:::\n\n#### Argument passing behaviour\n\nPass-by-sharing!\n\n#### Specify the type of return value\n\nYou can specify the type of return value of a function in the form `FuncName(parameters)::ReturnType`.\n\nIf the type of return value is not the given type, a conversion is attempted with `convert()`.\n\n::: {#91a3ac4b .cell execution_count=27}\n``` {.julia .cell-code}\nfoo(x::Int64) :: Int32 = 2x\n\ntypeof(foo(6))\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\nInt32\n```\n:::\n:::\n\n\n#### Multiple assignments and multiple return values\n\n1.  Multiple assignments\n\nAchieved by using (named) tuples.\n\n::: {#5103343d .cell execution_count=28}\n``` {.julia .cell-code}\n(a, b, c) = 1:3  # Assign each variable a value; parentheses are optional\n\n_, _, a = 1:3  # Use _ to discard unwanted values\n\na, b..., c = 1:6  # a -> 1, b -> 2:5, c -> 6; b... indicates that b is a collection (b doesn't need to be the final one)\n\n(; b, a) = (a=1, b=2, c=3)  # Assign values to variables based on names\n```\n:::\n\n\n2.  Multiple return values\n\n#### Parameter types\n\n1.  Positional parameters: non-optional; optional with defaults.\n\n2.  Keyword parameters: non-optional; optional with defaults.\n\n::: {#e723902e .cell execution_count=29}\n``` {.julia .cell-code}\n(a, b = 1; c, d = 2)  # Keyword arguments are defined after ;\n\n# Positional arguments: a, b (optional)\n# Keyword arguments: c, d (optional)\n\n# When you pass arguments, either will be fine:\n(1, 2; c = 3, d = 4)  # Separated by ;\n(1, 2, c = 3, d = 4)  # Separated by ,\n```\n:::\n\n\n::: callout-important\nMultiple dispatch only considers **positional arguments**.\n:::\n\n#### Anonymous functions\n\nAnonymous functions play an important role in functional programming.\n\nAn anonymous function can be defined in two ways:\n\n1.  Inline style: `(<parameters>) -> <expression>` (`()` can be omitted if it only has a single parameter).\n\n2.  Multiline style:\n\n::: {#043a93e0 .cell execution_count=30}\n``` {.julia .cell-code}\nfunction (<parameters>)\n    ...\nend\n```\n:::\n\n\n##### `do` blocks\n\nWe can use `do` blocks to create mutiline anonymous functions.\n\nThe following two statements are equivalent:\n\n::: {#5aec78dc .cell execution_count=31}\n``` {.julia .cell-code}\nmap(x -> begin\n              if x < 0 && iseven(x)\n                  return 0\n              elseif x == 0\n                  return 1\n              else\n                  return x\n              end\n         end,\n    [-2, 0, 2])\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\n3-element Vector{Int64}:\n 0\n 1\n 2\n```\n:::\n:::\n\n\n::: {#d46f5f88 .cell execution_count=32}\n``` {.julia .cell-code}\nmap([-2, 0, 2]) do x\n    if x < 0 && iseven(x)\n        return 0\n    elseif x == 0\n        return 1\n    else\n        return x\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\n3-element Vector{Int64}:\n 0\n 1\n 2\n```\n:::\n:::\n\n\nIn the above example, the `do x` syntax creates an anonymous function with argument `x` and passes it as the first argument to `map()`.\n\nSimilarly, `do x, y` will create a two-argument anonymous function but `do (x, y)` will create a one-argument anonymous function, whose argument is a tuple.\n\n**In a word, we can use `do` blocks to create anonymous functions which are passed as the first argument to some higher-order functions, the first argument of which must be the `Function` type.**\n\n#### The splat operator `...`\n\nThe splat operator can be used to turn arrays or tuples into function arguments.\n\ne.g. `foo([1, 2, 3]...)` is the same as `foo(1, 2, 3)`.\n\nYou can define a parameter which accepts a variable number of arguments by using the splat operator:\n\n::: {#ee72b474 .cell execution_count=33}\n``` {.julia .cell-code}\n# All arguments except the 1st will be stored in a tuple, assigned to args\nfunction var_f(x, args...)\n    ...\nend\n```\n:::\n\n\n#### Closure\n\nA *closure* is a function that has captured some external state not supplied as an argument since the inner scope can use variables defined in an outter scope.\n\nAnonymous functions are frequently used as closures.\n\n::: {#cc2579cf .cell execution_count=34}\n``` {.julia .cell-code}\nfunction make_pow(n::Real)  # Outer function\n    function (x::Real)  # Inner function\n        x^n  # The inner function uses n defined outside it and n is not passed as an argument to it\n    end\nend\n\npow2 = make_pow(2)  # The returned function with n=2 is assigned to variable pow2\npow3 = make_pow(3)\n\npow2(2), pow3(2)\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\n(4, 8)\n```\n:::\n:::\n\n\n::: {.callout-tip title=\"Performance of captured variable\"}\nFor the consideration of performance, if the type of a captured variable is already known, you would better **add a type annotation to it**. In addition, if the value of this captured variable need not be changed after the closure is created, **you can indicate it with a `let` block**:\n\n::: {#fc10d42d .cell execution_count=35}\n``` {.julia .cell-code}\nfunction abmult(r::Int)\n    r1::Int = r  # Type annotation\n    if r1 < 0\n        r1 = -r1\n    end\n    f = let r1 = r1  # Fix it\n            x -> x * r1\n        end\n    return f\nend\n\nf = abmult(10)\nf(10)\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\n100\n```\n:::\n:::\n\n\n:::\n\n#### Partial function application\n\nPartial function application refers to the process of fixing a number of arguments to a function, producing another function accepting fewer arguments.\n\nObviously, closure is a way to achieve the partial function application.\n\n#### Function composition, vectorization and piping\n\n##### Function composition\n\nThe concept of function composition in Julia is the very concept of function composition in mathematics and the operation symbol is the same one: `∘`, typed using `\\circ<tab>` (e.g. `(f ∘ g)(args...)` is the same as `f(g(args...))`).\n\n::: {#e7ecffe3 .cell execution_count=36}\n``` {.julia .cell-code}\n(sqrt ∘ +)(3, 6)  # Equivalent to sqrt(+(3, 6))\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\n3.0\n```\n:::\n:::\n\n\n##### Dot syntax for vectorizing functions\n\nIn Julia, vectorized functions are not required for performance, and indeed it is often beneficial to write your own loops, but they can still be convenient.\n\nYou can add a dot `.` **after regular function names** (e.g. `f`) or **before special operators** (e.g. `+`) to get their vectorized versions.\n\n1.  Operating on a single array:\n\n::: {#8bb96da1 .cell execution_count=37}\n``` {.julia .cell-code}\nA = 1:3\n\nsin.(A)  # Which is equivalent to map(sin, A) or broadcast(sin, A)\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\n3-element Vector{Float64}:\n 0.8414709848078965\n 0.9092974268256817\n 0.1411200080598672\n```\n:::\n:::\n\n\n2.  Operating on multiple arrays (even of different shapes), or a mix of arrays and scalars:\n\n::: {#beaf7062 .cell execution_count=38}\n``` {.julia .cell-code}\nfp(x, y) = 3x + 4y\n\nA = 1:3\nB = 4:6\n\nfp.(pi, A)\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n```\n3-element Vector{Float64}:\n 13.42477796076938\n 17.42477796076938\n 21.42477796076938\n```\n:::\n:::\n\n\n::: {#b1e44537 .cell execution_count=39}\n``` {.julia .cell-code}\nfp.(A, B)\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```\n3-element Vector{Int64}:\n 19\n 26\n 33\n```\n:::\n:::\n\n\n3.  Keyword arguments are not broadcasted over, but are simply passed through to each of the function.\n\n4.  Nested `f.(args...)` calls are fused into a single broadcast loop.\n\n::: {#b1ed2f76 .cell execution_count=40}\n``` {.julia .cell-code}\nX = 1:6\n\nsin.(cos.(X))  # Equivalent to broadcast(x -> sin(cos(x)), X)\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```\n6-element Vector{Float64}:\n  0.5143952585235492\n -0.4042391538522658\n -0.8360218615377305\n -0.6080830096407656\n  0.2798733507685274\n  0.819289219220601\n```\n:::\n:::\n\n\nHowever, the fusion stops as soon as a \"non-dot\" function call is encountered (e.g. `sin.(sort(cos.(X)))`).\n\n5.  The maximum efficiency is typically achieved when the output array of a vectorized operation is pre-alllocated.\n\n::: {#72e2795f .cell execution_count=41}\n``` {.julia .cell-code}\nX = 1:10000\n\n@time sin.(X)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  0.000052 seconds (3 allocations: 78.203 KiB)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=33}\n```\n10000-element Vector{Float64}:\n  0.8414709848078965\n  0.9092974268256817\n  0.1411200080598672\n -0.7568024953079282\n -0.9589242746631385\n -0.27941549819892586\n  0.6569865987187891\n  0.9893582466233818\n  0.4121184852417566\n -0.5440211108893698\n -0.9999902065507035\n -0.5365729180004349\n  0.4201670368266409\n  ⋮\n -0.9534986003597155\n -0.26156028858731495\n  0.6708553462651908\n  0.9864896695694187\n  0.39514994010172155\n -0.5594888219681838\n -0.9997361413354392\n -0.5208306628783247\n  0.4369241250954582\n  0.9929728874353159\n  0.6360869563962336\n -0.30561438888825215\n```\n:::\n:::\n\n\n::: {#60eb3460 .cell execution_count=42}\n``` {.julia .cell-code}\nY = Vector{Float64}(undef, 10000)  # Construct an uninitialized (undef) Vector{Float64} of length 10000\n\n@time Y .= sin.(X)  # Overwrite Y with sin.(X) in-place\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  0.007350 seconds (9.57 k allocations: 711.680 KiB, 99.11% compilation time)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=34}\n```\n10000-element Vector{Float64}:\n  0.8414709848078965\n  0.9092974268256817\n  0.1411200080598672\n -0.7568024953079282\n -0.9589242746631385\n -0.27941549819892586\n  0.6569865987187891\n  0.9893582466233818\n  0.4121184852417566\n -0.5440211108893698\n -0.9999902065507035\n -0.5365729180004349\n  0.4201670368266409\n  ⋮\n -0.9534986003597155\n -0.26156028858731495\n  0.6708553462651908\n  0.9864896695694187\n  0.39514994010172155\n -0.5594888219681838\n -0.9997361413354392\n -0.5208306628783247\n  0.4369241250954582\n  0.9929728874353159\n  0.6360869563962336\n -0.30561438888825215\n```\n:::\n:::\n\n\n6.  Using the `@.` macro to convert every function call, operation, and assignment in an expression into the \"dotted\" version.\n\n::: {#c7ff9e72 .cell execution_count=43}\n``` {.julia .cell-code}\nX = [1.0, 2.0, 3.0]\n\nY = similar(X)  # Pre-allocate the output array\n\n@. Y = sin(cos(X))\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n```\n3-element Vector{Float64}:\n  0.5143952585235492\n -0.4042391538522658\n -0.8360218615377305\n```\n:::\n:::\n\n\n7.  Using vectorized piping operator.\n\n::: {#a6cdd6b0 .cell execution_count=44}\n``` {.julia .cell-code}\n1:6 .|> [x -> x-1, inv, x -> 2*x, -, isodd, iseven]\n```\n\n::: {.cell-output .cell-output-display execution_count=36}\n```\n6-element Vector{Real}:\n    0\n    0.5\n    6\n   -4\n true\n true\n```\n:::\n:::\n\n\n::: {.callout-note title=\"`broadcast(f, As...)`\"}\nBroadcast the function `f` over the arrays, tuples, collections, Refs, and/or scalars `As`.\n:::\n\n::: {.callout-note title=\"Pre-allocating outputs\"}\n\n::: {#d525c3a9 .cell execution_count=45}\n``` {.julia .cell-code}\nVector{Int}(undef, 10)  # Construct an uninitialized Vector{Int} of length 10\n```\n\n::: {.cell-output .cell-output-display execution_count=37}\n```\n10-element Vector{Int64}:\n               0\n               0\n               0\n               0\n               0\n 140265967167120\n 140262402246488\n              32\n          563204\n              32\n```\n:::\n:::\n\n\n::: {#2aedbdfe .cell execution_count=46}\n``` {.julia .cell-code}\nMatrix{Float64}(undef, 3, 3)  # Construct an uninitialized Matrix{Float64} of 3 by 3\n```\n\n::: {.cell-output .cell-output-display execution_count=38}\n```\n3×3 Matrix{Float64}:\n 2.3e-322  5.0e-324     5.0e-324\n 7.4e-323  2.7826e-318  6.92988e-310\n 7.4e-323  5.0e-324     0.0\n```\n:::\n:::\n\n\n:::\n\n##### Function piping\n\nThe pipe operator is `|>`, which is used to chain together functions taking **single** arguments as inputs.\n\n::: {#128898b5 .cell execution_count=47}\n``` {.julia .cell-code}\n1:10 |> sum |> sqrt\n```\n\n::: {.cell-output .cell-output-display execution_count=39}\n```\n7.416198487095663\n```\n:::\n:::\n\n\n### Exception\n\nUsage:\n\n::: {#ee2f2e65 .cell execution_count=48}\n``` {.julia .cell-code}\ntry\n    <some code which may raise some errors>\ncatch <exception variable>\n    <some code dealing with exceptions>\nelse\n    <some code to be executed when no error occurs>\nfinally\n    <some code to be executed anyway>\nend\n```\n:::\n\n\nYou can use `throw()` to raise a given type of exception or use `error()` to raise an `ErrorException` directly.\n\nThen you can use `isa()` to check whether the error type raised is the expected.\n\ne.g.\n\n::: {#7e6ad615 .cell execution_count=49}\n``` {.julia .cell-code}\nx = [2, -2, 'a']\n\nfor i in x\n    try\n        y = sqrt(i)\n        println(\"√\", i, \" = \", y)\n    catch e\n        if isa(e, DomainError)\n            println(\"√\", i, \": $(i) is out of domain\")\n        else\n            println(\"√\", i, \": $(i) is an unsopported type\")\n        end\n    end\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n√2 = 1.4142135623730951\n√-2: -2 is out of domain\n√a: a is an unsopported type\n```\n:::\n:::\n\n\n### Metaprogramming\n\n::: {.callout-note title=\"Key concepts\"}\n1.  Abstract Syntax Tree (AST): a data structure used in computer science to represent the structure of a program or code snippet.\n2.  Higher-order functions: functions taking one or more functions as arguments and returning a function. All other functions are called first-order functions.\n3.  Closure: a function that has captured some external state not supplied as arguments to it since the inner scope can refer to variables defined in its outer scopes.\n4.  Reflection: the ability of a process to examine, introspect, and modify its own structure and behavior.\n:::\n\n#### Program representation\n\nIn a word, each Julia program starts its life as a string, which then is parsed into an object called expression of type `Expr`. The key point is that **Julia code is internally represented as a data structure that is accessible from the language itself**. It means that we can generate, examine, and modify Julia code like manipulating ordinary Julia objects within Julia.\n\n#### Expressions and evaluation\n\nThe next questions are how to construct expressions of type `Expr`, and how to execute (evaluate) them?\n\n##### Expressions\n\nThere are several ways to construct expressions:\n\n1.  From strings via `Meta.parse()`.\n\n::: {#7f664d2d .cell execution_count=50}\n``` {.julia .cell-code}\nprog = \"1 + 1\"\nex1 = Meta.parse(prog)\n```\n\n::: {.cell-output .cell-output-display execution_count=41}\n```\n:(1 + 1)\n```\n:::\n:::\n\n\n::: {#6e2838cb .cell execution_count=51}\n``` {.julia .cell-code}\ntypeof(ex1)\n```\n\n::: {.cell-output .cell-output-display execution_count=42}\n```\nExpr\n```\n:::\n:::\n\n\n::: callout-note\n`Expr` objects contain two fields:\n\n1.  `head`: a `Symbol` identifying the kind of expression.\n2.  `args`: the expression arguments, which may be symbols, expressions, or literal values.\n:::\n\n2.  Use `Expr()` constructor.\n\n::: {#05595589 .cell execution_count=52}\n``` {.julia .cell-code}\nex2 = Expr(:call, :+, 1, 1)\n```\n\n::: {.cell-output .cell-output-display execution_count=43}\n```\n:(1 + 1)\n```\n:::\n:::\n\n\n::: {#e4b3f3eb .cell execution_count=53}\n``` {.julia .cell-code}\nex1 == ex2\n```\n\n::: {.cell-output .cell-output-display execution_count=44}\n```\ntrue\n```\n:::\n:::\n\n\n3.  Quoting single/multiple statements of Julia code.\n\nThe usual representation of a quote form in an AST is an `Expr` with `head` `:quote`.\n\n-   Quoting single statement of Julia code using `:` character, followed by paired parentheses:\n\n::: {#a00966dd .cell execution_count=54}\n``` {.julia .cell-code}\n:(a + b * c + 1) |> typeof\n```\n\n::: {.cell-output .cell-output-display execution_count=45}\n```\nExpr\n```\n:::\n:::\n\n\n-   Quoting multiple statements of Julia code using `quote ... end` blocks:\n\n::: {#40ae8f36 .cell execution_count=55}\n``` {.julia .cell-code}\nex = quote\n    x = 1\n    y = 2\n    x + y\nend\ntypeof(ex)\n```\n\n::: {.cell-output .cell-output-display execution_count=46}\n```\nExpr\n```\n:::\n:::\n\n\n::: {.callout-important title=\"Interpolation\"}\nIn contrast with expressions constructed using `Meta.parse()` or `Expr()`, expressions constructed by quoting single/multiple statements of Julia code allow us to interpolate literals or expressions into, quite similar with string interpolation:\n\n::: {#632034d1 .cell execution_count=56}\n``` {.julia .cell-code}\na = 1\n:($a + b)  # literals\n```\n\n::: {.cell-output .cell-output-display execution_count=47}\n```\n:(1 + b)\n```\n:::\n:::\n\n\n::: {#272771fd .cell execution_count=57}\n``` {.julia .cell-code}\n:(a in $:((1,2,3)))  # expressions\n```\n\n::: {.cell-output .cell-output-display execution_count=48}\n```\n:(a in (1, 2, 3))\n```\n:::\n:::\n\n\n**Splatting interpolation:** you have an array of expressions and need them all to become arguments of the surrounding expression. This can be done with the syntax `$(xs...)`:\n\n::: {#b3d4853a .cell execution_count=58}\n``` {.julia .cell-code}\nargs = [:x, :y, :z]\n:(f(1, $(args...)))\n```\n\n::: {.cell-output .cell-output-display execution_count=49}\n```\n:(f(1, x, y, z))\n```\n:::\n:::\n\n\n:::\n\n-   Nested quote and interpolation:\n\nNaturally, it is possible for quote expressions to contain other quote expressions.\n\nUnderstanding how interpolation works in these cases can be a bit tricky.\n\nThe basic principle is that `$x` works similarly to `eval(:x)`.\n\n::: {#91bb2f19 .cell execution_count=59}\n``` {.julia .cell-code}\njulia> x = 100\n# 100\n\njulia> quote $x end  # x will be evaluated in a non-nested quote (this should be natrual for interpolation introduced above)\n# quote\n#     #= REPL[13]:1 =#\n#     100\n# end\n\njulia> quote quote $x end end  # x won't be evaluated yet, because it belongs to the inner quote, not the outer quote\n# quote\n#     #= REPL[14]:1 =#\n#     $(Expr(:quote, quote\n#     #= REPL[14]:1 =#\n#     $(Expr(:$, :x))\n# end))\n# end\n\njulia> quote quote $x end end |> eval  # the inner quote will be evaluated and x will too as a consequence\n# quote\n#     #= REPL[15]:1 =#\n#     100\n# end\n\njulia> quote quote $$x end end  # the outer quote can interpolate values inside $ in the inner quote with multiple $s, which means x will be evaluated in this case\n# quote\n#     #= REPL[16]:1 =#\n#     $(Expr(:quote, quote\n#     #= REPL[16]:1 =#\n#     $(Expr(:$, 100))\n# end))\n# end\n\njulia> quote quote quote $$x end end end  # x won't be evaluated here, because the outer $ belongs to the innermost quote, and the inner $ belongs to the second quote\n# quote\n#     #= REPL[17]:1 =#\n#     $(Expr(:quote, quote\n#     #= REPL[17]:1 =#\n#     $(Expr(:quote, quote\n#     #= REPL[17]:1 =#\n#     $(Expr(:$, :($(Expr(:$, :x)))))\n# end))\n# end))\n# end\n```\n:::\n\n\n-   `QuoteNode`:\n\nIn some situations, it is necessary to quote code without performing interpolation. This kind of quoting does not yet have syntax, but is represented internally as an object of type `QuoteNode`:\n\n::: {#5ddaef9f .cell execution_count=60}\n``` {.julia .cell-code}\njulia> quote quote $x end end |> eval  # with interpolation\n# quote\n#     #= REPL[34]:1 =#\n#     100\n# end\n\njulia> quote quote $x end end |> QuoteNode |> eval  # wihout interpolation\n# quote\n#     #= REPL[36]:1 =#\n#     $(Expr(:quote, quote\n#     #= REPL[36]:1 =#\n#     $(Expr(:$, :x))\n# end))\n# end\n```\n:::\n\n\n**Note:** the parser yields `QuoteNode`s for simple quoted items like symbols:\n\n::: {#94eb6b5e .cell execution_count=61}\n``` {.julia .cell-code}\ndump(Meta.parse(\":x\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nQuoteNode\n  value: Symbol x\n```\n:::\n:::\n\n\n::: {.callout-note title=\"Show expressions elegantly\"}\n\n::: {#a32e8157 .cell execution_count=62}\n``` {.julia .cell-code}\ndump(Meta.parse(\"1 + 1\"))\n\nMeta.show_sexpr(Meta.parse(\"(4 + 4) / 2\"))  # shows that Expr objects can be nested\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nExpr\n  head: Symbol call\n  args: Array{Any}((3,))\n    1: Symbol +\n    2: Int64 1\n    3: Int64 1\n(:call, :/, (:call, :+, 4, 4), 2)\n```\n:::\n:::\n\n\n:::\n\n::: {.callout-note title=\"Symbols\"}\nA `Symbol` is an interned string, used as one building block of expressions.\n\nA `Symbol` can be constructed in two ways:\n\n::: {#fed9100e .cell execution_count=63}\n``` {.julia .cell-code}\n# using : character from valid identifiers\ns = :foo\ntypeof(s)\n```\n\n::: {.cell-output .cell-output-display execution_count=52}\n```\nSymbol\n```\n:::\n:::\n\n\n::: {#07dc3022 .cell execution_count=64}\n``` {.julia .cell-code}\n# using Symbol() constructor from any number of arguments by concatenating their string representations together\nSymbol(:var, \"_\", \"sym\")\n```\n\n::: {.cell-output .cell-output-display execution_count=53}\n```\n:var_sym\n```\n:::\n:::\n\n\n::: {#0f35ad1b .cell execution_count=65}\n``` {.julia .cell-code}\n# sometimes extra parentheses around the argument to : are needed to avoid ambiguity in parsing\n:(::)\n```\n\n::: {.cell-output .cell-output-display execution_count=54}\n```\n:(::)\n```\n:::\n:::\n\n\n**Note:** in the context of an expression, symbols are used to indicate access to variables; when an expression is evaluated, a symbol is replaced with the value bound to that symbol in the appropriate scope.\n:::\n\n##### Evaluation\n\nGiven an expression object, one can cause Julia to evaluate (execute) it at **global scope** using `eval()` (for code block, use `@eval begin ... end`).\n\nEvery `module` has its own `eval()` function that evaluates expressions in its global scope.\n\nNote the behaviors of variable `a` and symbol :`b` in the following code:\n\n::: {#15603ce7 .cell execution_count=66}\n``` {.julia .cell-code}\na = 1\nex = Expr(:call, :+, a, :b)  # The value of the variable a at expression construction time is uesd as an immediate value in the expression; on the other hand, the symbol :b is used in the expression construction, so the value of the variable b at that time is irrelevant. Only when the expression is evaluated is the symbol :b resolved by looking up the value of the variable b.\na, b = 0, 2\neval(ex)\n```\n\n::: {.cell-output .cell-output-display execution_count=55}\n```\n3\n```\n:::\n:::\n\n\n#### Code generation\n\nBy means of expressions along with its interpolation, and evaluation, one extremely useful feature of Julia is the capability to generate and manipulate Julia code within Julia itself. Such as defining functions returning `Expr` objects, defining methods programmatically, etc.\n\n::: {#c9ae5f9d .cell execution_count=67}\n``` {.julia .cell-code}\nstruct MyNumber\n    x::Float64\nend\n\nfor op = (:sin, :cos, :tan, :log, :exp)\n    eval(quote\n        Base.$op(a::MyNumber) = MyNumber($op(a.x))\n    end)\nend\n\nx = MyNumber(π)\nprintln(sin(x))\nprintln(cos(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMyNumber(1.2246467991473532e-16)\nMyNumber(-1.0)\n```\n:::\n:::\n\n\n#### Macros\n\nMacros provide a mechanism to include generated code in the final body of a program.\n\nA macro maps a tuple of arguments (including symbols, literal values, and expressions, which hints that all the other arguments passed to a macro are considered as expressions, except symbols and literal values) to a returned expression, which is compiled directly rather than requiring a runtime `eval()` call. This means that the returned expression is compiled **at parse time**. This is why we can include generated code in the final body of a program using macros.\n\n1.  **Defining macros:**\n\n::: {#9d6efe8c .cell execution_count=68}\n``` {.julia .cell-code}\nmacro <NAME>(<arguments>)\n    body  # return an expression at last\nend\n```\n:::\n\n\nFor example,\n\n::: {#dca1f0a0 .cell execution_count=69}\n``` {.julia .cell-code}\nmacro sayhello(name)\n    return :(println(\"Hello, \", $name))\nend\n\n@sayhello(\"human\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello, human\n```\n:::\n:::\n\n\nWhen `@sayhello` is encountered, the quoted expression is expanded to interpolate the value of the argument into the final expression. Then, the compiler will replace all instances of `@sayhello` with `:(Main.println(\"Hello, \", \"human\"))`. When `@sayhello` is entered in the REPL, the expression executes immediately, thus we only see the evaluation result. We can view the returned expression using the function `macroexpand()` or macro `@macroexpand`:\n\n::: {#841a07a6 .cell execution_count=70}\n``` {.julia .cell-code}\n@macroexpand @sayhello(\"human\")  # equivalent to macroexpand(Main, :(@sayhello(\"human\")))\n```\n\n::: {.cell-output .cell-output-display execution_count=58}\n```\n:(Main.println(\"Hello, \", \"human\"))\n```\n:::\n:::\n\n\n2.  **Why macros?**\n\nMacros are necessary because they execute when code is parsed; therefore, macros allow the programmer to generate and include fragments of customized code before the full program is run.\n\n::: {#efb0b794 .cell execution_count=71}\n``` {.julia .cell-code}\nmacro twostep(arg)\n    println(\"I execute at parse time. The argument is: \", arg)\n    return :(println(\"I execute at runtime. The argument is: \", $arg))\nend\n\nex = @macroexpand @twostep :(1, 2, 3)\nprintln(typeof(ex))\nprintln(repr(ex))  # equivalent to show(ex), because repr() actually calls show() and then returns a string\neval(ex)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nI execute at parse time. The argument is: :((1, 2, 3))\nExpr\n:(Main.println(\"I execute at runtime. The argument is: \", $(Expr(:copyast, :($(QuoteNode(:((1, 2, 3)))))))))\nI execute at runtime. The argument is: (1, 2, 3)\n```\n:::\n:::\n\n\n3.  **Macro invocation**\n\n::: {#a140f547 .cell execution_count=72}\n``` {.julia .cell-code}\n# separated by white space\n@name expr1 expr2 ...\n# separated by ,\n@name(expr1, expr2, ...)\n```\n:::\n\n\n**Note:**\n\n::: {#22c5411d .cell execution_count=73}\n``` {.julia .cell-code}\n# there is only an argument here - a tuple\n@name (expr1, expr2, ...)\n\n@name[a b] * c  # no space and parenthesis between the macro name and the argument, which is the unique argument to this macro\n# is equivalent to\n@name([a b]) * c\n```\n:::\n\n\n**Note:** again, macros receive their arguments as expressions, literals, and symbols. You can explore the macro arguments using the `show()` function within the macro body.\n\n**Note:** in addition to the given argument list, every macro is passed extra two arguments named `__source__`, and `__module__`.\n\n-   `__source__` argument provides information if the form of a `LineNumberNode` object about the parser location of the `@` sign **from the macro invocation**. The location information can be accessed by referencing `__source__.line`, and `__source__.file`. It can also be used for other useful purposes, such as implementing the `@__LINE__`, `@__FILE__`, and `@__DIR__` macros.\n\n-   `__module__` argument provides information in the form of a `Module` object about the expansion context of the macro invocation. This allows macros to look up contextual information, such as existing bindings.\n\n4.  **Hygiene**\n\nHow to resolve variables within a macro result in an appropriate scope?\n\nIn short, we have several concerns:\n\n-   Macros must ensure that the variables they introduce in their returned expressions do not accidentally clash with existing variables in the surrounding code they expand into.\n\n-   Conversely, the expressions that are passed into a macro as arguments are often expected to evaluate in the context of the surrounding code, interacting with and modifying the existing variables.\n\n-   In addition, a macro may be called in a different module from where it was defined. In this case we need to ensure that all global variables are resolved in the correct module.\n\nJulia's macro expander solves these problems in the following way:\n\n-   First, variables within a macro result are classified as either local or global. A variable is considered local if and only if **it is assigned to declared local**, or **used as a function argument name**. Otherwise, it is considered global. Local variables are then **renamed to be unique** via `gensym()` function, and global variables are resolved **within the macro definition environment**.\n\nThe above rules can meet the following expectations:\n\n::: {#841583ad .cell execution_count=74}\n``` {.julia .cell-code}\n# here, we want t0, t1, and val to be private temporary variables,\n# and we want time_ns() and println() refer to the time_ns() and println() functions in Julia Base,\n# not to any time_ns() and println() functions the user might have\nmacro time(ex)\n    return quote\n        local t0 = time_ns()\n        local val = $ex\n        local t1 = time_ns()\n        println(\"elapsed time: \", (t1-t0)/1e9, \" seconds\")\n        val\n    end\nend\n```\n:::\n\n\n-   But sometimes, we want some variables **in the user expression** to be resolved **in the macro call environment**. To achieve this goal, we can put the user expression in the `esc()` function, which means \"escaping\". An expression wrapped in this manner is left alone by the macro expander and simply pasted into the output verbatim. Therefore it will be resolved in the macro call environment.\n\nThe above rules can meet the following expectations:\n\n::: {#eb8cfdb9 .cell execution_count=75}\n``` {.julia .cell-code}\n# suppose that the user has already defined a time_ns() function, different from the time_ns() function in the Julia Base,\n# and he call @time in this way:\n\n@time time_ns()\n\n# obviously, we just want time_ns() contained in the user expression to be resolved in the macro call environment, instead of the macro definition environment.\n# so this is why we need esc().\n```\n:::\n\n\n5.  **Macro dispatch**\n\nMacro dispatch is based on **the types of AST** that are handed to the macro, not the types that AST evaluates to at runtime.\n\nFor example:\n\n-   `Expr`: contains many different `head`s.\n\n-   `Symbol`\n\n-   Literal values: `Int64`, `Float64`, `String`, `Char`, etc.\n\n-   `QuoteNode`\n\n-   `LineNumberNode`\n\nand so on.\n\n#### Non-standard string and command literals\n\n1.  Standard string literals\n\nFor example, `\"abc\"`, `\"\"\"abc\"\"\"`.\n\n2.  Non-standard string literals\n\nTo provide some convenient methods to generate some special objects using non-standard string literals.\n\n::: {#ebea2ea0 .cell execution_count=76}\n``` {.julia .cell-code}\nmacro r_str(pattern, flags...)\n    Regex(pattern, flags...)\nend\n\np = r\"^http\"  # equivalent to call @r_str \"^http\" to produce a regular expression object rather than a string\n\n# how to define a non-standard string literal\nmacro <name>_str(str)  # affixing _str after the formal macro name\n    ...\nend\n\n# add a flag\nmacro <name>_str(str, flag)  # flag is also a String type\n    ...  # the return value may depend on the flag content (different flags with different return values)\nend\n\n# how to call\nname\"str\"flag\n```\n:::\n\n\n3.  Standard command literals\n\nFor example, `` `echo hello, world` ``.\n\n::: {#9e807769 .cell execution_count=77}\n``` {.julia .cell-code}\n# generate a Cmd from the str string which represents the shell command(s) to be executed\nmacro cmd(str)\n    cmd_ex = shell_parse(str, special=shell_special, filename=String(__source__.file))[1]\n    return :(cmd_gen($(esc(cmd_ex))))\nend\n\n# if you want to call shell_parse() and cmd_gen(), you need do it in the forms of Base.shell_parse() and Base.cmd_gen(), respectively\n```\n:::\n\n\n4.  Non-standard command literals\n\n::: {#d4d70ed7 .cell execution_count=78}\n``` {.julia .cell-code}\nmacro echo_cmd(str)\n    cmd_str = string(\"echo \", str)\n    return :(@cmd $cmd_str)\nend\n\nc = echo`hello, world`\ntypeof(c)\nshow(c)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n`echo hello, world`\n```\n:::\n:::\n\n\n#### Generated functions\n\nHow to generate specialized code depending on only **the types of their arguments** using **generated functions** (argument names refer to types, and the code should return an expression)?\n\nThe capability of multiple dispatch can also be achieved by using generated functions, which is defined by prefixing `@generated` before a normal function definition, but we'd better obey some rules when defining generated functions.\n\nOf course, we can define an optionally-generated function containing a generated version and a normal version by using `if @generated ... else ...` in a normal function body. Statements after `if @generated` is the generated one and after `else` the normal one. The compiler may use the generated one if convenient; otherwise it may choose to use the normal implementation instead.\n\n### Types\n\n#### Basics\n\nIn Julia, all are objects having a type, and types are first-class objects.\n\n-   You can use `typeof()` to get the type of any object.\n\n-   You can find the supertype of any type with `supertype()`: the root of type hierarchy is `Any`.\n\n-   You can find the subtypes of any type with `subtypes()`: if there is no subtype for a given type, it will return `Type[]`.\n\n-   You can check whether a type is a subtype of the other with the `<:` operator (e.g. `String <: Any`).\n\n-   Seeing that you created an empty array with the type `Integer`, then you can only add elements with the type `Integer` or its subtypes to this array.\n\n::: {.callout-note title=\"Primitive and composite types\"}\nWe can roughly divide all types into primitive types (concrete types whose data consists of plain old bits) and composite types (derived from primitive types or other composite types). On the other hand, we can also devide all types into abstract types (with zero fields) and concrete types (with fields).\n\nIn Julia, there are three primitive types: integers, floating-point numbers and characters. You can use the function `isprimitivetype()` to check whether a type is a primitive type (e.g. `isprimitivetype(Int8)`).\n\nIt's possible to define new primitive types in Julia by using `primitive type ... end`.\n:::\n\nYou can create composite types from primitive types or composite types:\n\n-   Definition of an **immutable** composite type:\n\n::: {#f57b2ee8 .cell execution_count=79}\n``` {.julia .cell-code}\nstruct TypeName\n    # Defining typed fields here\nend\n```\n:::\n\n\ne.g.\n\n::: {#27783a48 .cell execution_count=80}\n``` {.julia .cell-code}\nstruct Archer\n    name::String\n    health::Int\n    arrows::Int\nend\n\n# Once the composite type Archer is defined, you can instantiate the Archer object\nwilliam = Archer(\"William Tell\", 30, 24)\n\n# Then access the values of fileds by using dot operator\nwilliam.name, william.health, william.arrows\n```\n:::\n\n\n::: callout-note\nIn Julia, `::` is used to annotate variables and expression with types.\n\n`x::T` means variable `x` should have type `T`.\n:::\n\n-   Definition of a **mutable** composite type:\n\n::: {#ae02d1ce .cell execution_count=81}\n``` {.julia .cell-code}\nmutable struct TypeName\n    # Defining typed fields here\nend\n```\n:::\n\n\n-   Definition of abstract type: `abstract type TypeName end`.\n\nObviously, the type created by using `struct` is a concrete type.\n\nYou can create objects of a concrete type but not of an abstract type.\n\nAn abstract type cannot have any fields. Only concrete types can have fields or a value.\n\nThe purpose of abstract types is to facilitate the construction of type hierarchy.\n\nA **composite** type is a concrete type with fields; a **primitive** type is a concrete type with a single value.\n\n-   You can use the subtype operator `<:` to create a **concrete** or **abstract** subtype of an **abstract** type.\n\n::: {#16a9fa23 .cell execution_count=82}\n``` {.julia .cell-code}\nabstract type Warrior end\n\n# Archer is a subtype of Warrior\nstruct ArcherSoldier <: Warrior\n    name::String\n    health::Int\n    arrows::Int\nend\n\nsupertype(ArcherSoldier)\n```\n\n::: {.cell-output .cell-output-display execution_count=61}\n```\nWarrior\n```\n:::\n:::\n\n\n::: callout-note\nDifferent with object-oriented languages, composite types in Julia **can only have fields**, and **cannot have methods bound to them**.\n:::\n\nAfter creating concrete types, you can make objects of them (i.e. instantiate them) with arguments.\n\n::: callout-note\nYou can only make objects of **concrete types**!\n:::\n\ne.g.\n\n::: {#3a7b4452 .cell execution_count=83}\n``` {.julia .cell-code}\nmutable struct TestType\n    a::Int64\n    b::Float64\nend\n\nt1 = TestType(1, 10.5)\n```\n\n::: {.cell-output .cell-output-display execution_count=62}\n```\nTestType(1, 10.5)\n```\n:::\n:::\n\n\nYou can instantiate objects of `TestType` in this way `t1 = TestType(1, 10.5)`, because Julia automatically creates a special function called **constructor** with the same name as your type. A constructor is responsible for making an instance (object) of the type it is associated with. Julia adds **two methods** to the constructor function, which takes the same number of arguments as you have fields. **One method uses type annotations for its arguments, as specified for each field in the `struct`**. **The other takes arguments of `Any` type**.\n\n::: {#9ab2ee27 .cell execution_count=84}\n``` {.julia .cell-code}\nmethods(TestType)\n```\n\n::: {.cell-output .cell-output-display execution_count=63}\n```{=html}\n# 2 methods for type constructor:<ul><li> TestType(a::<b>Int64</b>, b::<b>Float64</b>) in Main at In[62]:2</li> <li> TestType(a, b) in Main at In[62]:2</li> </ul>\n```\n:::\n:::\n\n\n::: {#b7df62bc .cell execution_count=85}\n``` {.julia .cell-code}\nfunction TestType(a::Int64)\n    TestType(a, a)\nend\n\nmethods(TestType)\n```\n\n::: {.cell-output .cell-output-display execution_count=64}\n```{=html}\n# 3 methods for type constructor:<ul><li> TestType(a::<b>Int64</b>) in Main at In[64]:1</li> <li> TestType(a::<b>Int64</b>, b::<b>Float64</b>) in Main at In[62]:2</li> <li> TestType(a, b) in Main at In[62]:2</li> </ul>\n```\n:::\n:::\n\n\n::: {#0297d5cc .cell execution_count=86}\n``` {.julia .cell-code}\nTestType(100)\n```\n\n::: {.cell-output .cell-output-display execution_count=65}\n```\nTestType(100, 100.0)\n```\n:::\n:::\n\n\nSurely, you can add methods to this constructor function outside of `struct` in the same manner as any other fucntion, called **outer constructor**.\n\nIn addition, you can define accessors (getters and setters) as well as other functions accepted arguments of this type to achieve some tasks.\n\nYou can only provide types without concrete parameters to define a function tied to types (this type of function are usually used to get some properties of a type, independent of its objects):\n\n::: {#3fdf54d7 .cell execution_count=87}\n``` {.julia .cell-code}\ntoy(::TestType) = 100\n\nt = TestType(100)\ntoy(t)\n```\n\n::: {.cell-output .cell-output-display execution_count=66}\n```\n100\n```\n:::\n:::\n\n\nIn functions (including outer constructors) you defined outside of `struct`, you can easily check whether user-provided arguments are valid or not. But how can we check this when instantiating objects of a concrete type by using constructors Julia created?\n\nTo solve this problem, we need to define the constructor inside of `struct`, called **inner constructor**. Once you do this, you tell Julia that you don't want it to create constructor methods automatically (i.e. disable this manner). Then, users can only use the constructor you defined to instantiate objects of a concrete type.\n\n::: {#f4e3476b .cell execution_count=88}\n``` {.julia .cell-code}\nmutable struct TempType\n    a::Int64\n    b::Float64\n    diff::Float64\n\n    function TempType(a::Int64, b::Float64)\n        new(a, b, b - a)  # We don't want users to provide the value of diff, which is defined as the difference of b and a\n    end\nend\n```\n:::\n\n\n::: callout-note\nIn inner constructor, you need use `new()` (which is only available inside an inner constructor) to instantiate objects of a concrete type, which accepts **zero or more** arguments **but never more aguments than the number of fields in your composite type**, because creating an inner constructor removes all constructor methods created by Julia. Feilds with missing values will be set to random values.\n:::\n\n::: {#3747d055 .cell execution_count=89}\n``` {.julia .cell-code}\nmethods(TempType)\n```\n\n::: {.cell-output .cell-output-display execution_count=68}\n```{=html}\n# 1 method for type constructor:<ul><li> TempType(a::<b>Int64</b>, b::<b>Float64</b>) in Main at In[67]:6</li> </ul>\n```\n:::\n:::\n\n\n::: {#c0b9758e .cell execution_count=90}\n``` {.julia .cell-code}\nTempType(1, 10.5)\n```\n\n::: {.cell-output .cell-output-display execution_count=69}\n```\nTempType(1, 10.5, 9.5)\n```\n:::\n:::\n\n\n::: {#d14d7a65 .cell execution_count=91}\n``` {.julia .cell-code}\n# This will raise an error\nTempType(1, 10.5, 9.5)\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>MethodError: no method matching TempType(::Int64, ::Float64, ::Float64)\n\nClosest candidates are:\n  TempType(::Int64, ::Float64)\n<span class=\"ansi-bright-black-fg\">   @</span> <span class=\"ansi-magenta-fg\">Main</span> <span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">In[67]:6</span>\n\n\nStacktrace:\n [1] top-level scope\n   @ In[70]:3</pre>\n```\n:::\n\n:::\n:::\n\n\n#### Multiple dispatch\n\n##### How does multiple dispatch work\n\n::: {#bc8f0196 .cell execution_count=92}\n``` {.julia .cell-code}\nfunction myadd(x::Int, y::Int)\n    print(\"The sum is: \")\n    printstyled(x + y, \"\\n\", bold = true, color = :red)\nend\n\nfunction myadd(x::String, y::String)\n    print(\"The concatenated string is: \")\n    printstyled(join([x, y]), \"\\n\", bold = true, color = :red)\nend\n\nfunction myadd(x::Char, y::Char)\n    print(\"The character is: \")\n    printstyled(Char(Int(x) + Int(y)), \"\\n\", bold = true, color = :red)\nend\n\nmyadd(1, 1)\nmyadd(\"abc\", \"def\")\nmyadd('W', 'Y')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe sum is: 2\nThe concatenated string is: abcdef\nThe character is: °\n```\n:::\n:::\n\n\nHow does Julia know which function should be called in this situation?\n\n-   In fact, we defined three **methods**, attached to the function `myadd`, instead of three **functions** above.\n\n-   In Julia, functions are just names. Without attached methods, they cannot do anything. **Code is always stored inside methods**. **The type of arguments** determines which method will get executed **at runtime**.\n\n-   You can use `methods()` to check how many methods a function contains (e.g. `methods(myadd)`).\n\n-   If some parameters without types specified, the type will be `Any` (i.e. accept all types of values).\n\n-   You can only define functions without methods:\n\n::: {#d26564cc .cell execution_count=93}\n``` {.julia .cell-code}\nfunction func_no_method end\n\nfunc_no_method(1, 1)  # Attempt to call a function with no methods\n```\n\n::: {.cell-output .cell-output-error}\n```\nLoadError: MethodError: no method matching func_no_method(::Int64, ::Int64)\nMethodError: no method matching func_no_method(::Int64, ::Int64)\n\nStacktrace:\n [1] top-level scope\n   @ In[72]:3\n```\n:::\n:::\n\n\n::: {#2290128d .cell execution_count=94}\n``` {.julia .cell-code}\nfunc_not_defined(1, 1)  # Attempt to call a function not defined\n```\n\n::: {.cell-output .cell-output-error}\n```\nLoadError: UndefVarError: `func_not_defined` not defined\nUndefVarError: `func_not_defined` not defined\n\nStacktrace:\n [1] top-level scope\n   @ In[73]:2\n```\n:::\n:::\n\n\n##### The way Julia selects the correct method of a function for each situation\n\nInternally, Julia has a list of functions. Every function enters another list containing the methods, which deals with different argument type combinations.\n\n1.  First, Julia matches the function name (i.e. the called function should be defined).\n\n2.  Then, Julia matches the type combination of arguments and parameters (i.e. the combination of types of arguments passed = the combination of types of parameters defined in a method).\n\nIn contrast with multiple dispatch, what method is used is decided only by the type of the first argument in single dispatch or object-oriented languages (i.e. in `a.join(b)`, the function (method) used is only decided by the object `a`, not decided by both `a` and `b`, because in object-oriented languages, various attributes and fuctions (methods) are bound to objects of a class). If you defined a function multiple times with arguments of different types in object-oriented languages, the previous will be overwritten by the latter.\n\nIn statically typed languages which allows you to define a function multiple times with arguments of different types, when the code gts compiled, the compiler will pick the right function. But the selection process can only be done during compilation, it cannot be done during execution, which Julia can do.\n\ni.e. statically typed languages cannot deal with such a situation:\n\n::: {#d8126b04 .cell execution_count=95}\n``` {.julia .cell-code}\nfunction f1(a::Warrior, b::Warrior)\n    f2(a, b)\n    # Some other statements\nend\n```\n:::\n\n\nIn the function `f1`, defined above, `a` and `b` must be subtypes of the `Warrior` type. Suppose that the function `f1` is designed to allow accepting and dealing with these `a` and `b` with differnt subtypes of `Warrior`. When compiling the method `f1`, it only knows that `a` and `b` must be subtypes of `Warrior` but cannot know what concrete types they have. Then it won't pick up the right method of `f2` (suppose `f2` has at least two methods bound to it).\n\n#### Conversion and promotion\n\n##### Why do we need type promotion\n\nInside a microprocessor, mathematical operations are always performed **between identical types of numbers**.\n\nThus, when dealing with expressions composed of different number types, all higher-level programming languages have to convert all arguments in the expression **to the same number type**.\n\nBut **what should this common number type be**? Figuring out this common type if what promotion is all about.\n\nIn most mainstream languages, the mechanisms and rules governing number promotion are hardwired into the language and detaild in the specifications of the language.\n\nBut Julia promotion rules are defined in the standard library, not in the internals of the Julia JIT compiler. This allows you to **extend** the existing system, **not modifying it**.\n\n::: callout-tip\nYou can use the `@edit` macro to explore the Julia source code.\n\nBy prefixing with the `@edit` macro, Julia jumps to the definition of the function called to handled the expression (e.g. `@edit 1+1`).\n\nBefore using this, you may need to set the environment variable `JULIA_EDITOR` in your OS.\n:::\n\n##### How does type promotion work\n\nJulia performs type promotion by calling the `promote()` function, which promotes all arguments to a least common denominator.\n\ne.g. every arithmetic operation on some `Number` in Julia first calls `promote()` before performing the actual arithmetic operation.\n\ne.g. here, `promote()` promotes an integer and a floating-point number to floating-point numbers.\n\n::: {#15a689ed .cell execution_count=96}\n``` {.julia .cell-code}\npromote(1, 2.5)  # It returns a tuple\n```\n\n::: {.cell-output .cell-output-display execution_count=74}\n```\n(1.0, 2.5)\n```\n:::\n:::\n\n\n##### How does conversion work\n\n::: callout-caution\nConversion means converting from one type to another **related** type.\n\nThis is totally different from **parsing a text string to produce a number**, because a string and a number are not related types.\n:::\n\nFor number type conversion, it is recommended to use the constructor of the type you want to convert to.\n\n::: {#db735a64 .cell execution_count=97}\n``` {.julia .cell-code}\nInt8(32)  # Convert a number of Int64 to Int8\n```\n\n::: {.cell-output .cell-output-display execution_count=75}\n```\n32\n```\n:::\n:::\n\n\nDifferent from using type constructors, Julia calls the `convert()` function to achieve this.\n\n::: {#787174bc .cell execution_count=98}\n``` {.julia .cell-code}\nconvert(Int8, 32)\n```\n\n::: {.cell-output .cell-output-display execution_count=76}\n```\n32\n```\n:::\n:::\n\n\nThe first argument of `convert()` is a type object (we know that all are objects in Julia).\n\nActually, the type of `Int64` is `Type{Int64}`.\n\n::: {#574e4edb .cell execution_count=99}\n``` {.julia .cell-code}\nInt64 isa Type{Int64}\n```\n\n::: {.cell-output .cell-output-display execution_count=77}\n```\ntrue\n```\n:::\n:::\n\n\nYou can regard `Type` as a function, accepting a type argument `T`, and then returning the type of `T` - `Type{T}`.\n\n##### An example extending the type system\n\nHere we give an example of defining units for angles (redian/degree) and related operations.\n\n###### Defining unit types and constructors\n\n::: {#cead714d .cell execution_count=100}\n``` {.julia .cell-code}\nabstract type Angle end  # The super type of Radian and Degree\n\nstruct Radian <: Angle\n    radians::Float64\n\n    # Defining customized constructor\n    function Radian(radians::Number=0.0)\n        new(radians)\n    end\nend\n\n# 1 degree = 60 minutes\n# 1 minute = 60 seconds\n# degrees, minutes, seconds (DMS)\nstruct DMS <: Angle\n    seconds::Int\n\n    # Defining customized constructor\n    function DMS(degrees::Integer=0, minutes::Integer=0, seconds::Integer=0)\n        new(degrees * 60 * 60 + minutes * 60 + seconds)\n    end\nend\n```\n:::\n\n\n###### Defining accessors\n\n::: {#94558729 .cell execution_count=101}\n``` {.julia .cell-code}\nradians(radian::Radian) = radian.radians\n\nseconds(dms::DMS) = dms.seconds % 60\n\nminutes(dms::DMS) = (dms.seconds ÷ 60) % 60\n\ndegrees(dms::DMS) = (dms.seconds ÷ 60) ÷ 60\n```\n\n::: {.cell-output .cell-output-display execution_count=79}\n```\ndegrees (generic function with 1 method)\n```\n:::\n:::\n\n\n###### Displaying angles\n\nThe Julia REPL environment uses the `show(io::IO, data)` to display data of some specific type to the user.\n\n::: {#7a07e56f .cell execution_count=102}\n``` {.julia .cell-code}\nimport Base: show\n\nfunction show(io::IO, radian::Radian)\n    print(io, radians(radian), \"rad\")\nend\n\nfunction show(io::IO, dms::DMS)\n    print(io, degrees(dms), \"° \", minutes(dms), \"' \", seconds(dms), \"''\")\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=80}\n```\nshow (generic function with 610 methods)\n```\n:::\n:::\n\n\n::: callout-caution\nHere, we only want to attach new methods to the `show()` function, which is already defined in the Base package.\n\nSo we need to first import the `show()` function from the Base package; otherwise, it will automatically create a new function named `show`, which belongs to the namespace of Main, instead of Base, and then attach the newly defined method to this function.\n:::\n\n###### Defining type conversions\n\n::: {#6810fd29 .cell execution_count=103}\n``` {.julia .cell-code}\nimport Base: convert\n\nRadian(dms::DMS) = Radian(deg2rad(dms.seconds / 3600))\nDMS(radian::Radian) = DMS(floor(Int, rad2deg(radian.radians) * 3600))\n\nconvert(::Type{Radian}, dms::DMS) = Radian(dms)\nconvert(::Type{DMS}, radian::Radian) = DMS(radian)\n```\n\n::: {.cell-output .cell-output-display execution_count=81}\n```\nconvert (generic function with 673 methods)\n```\n:::\n:::\n\n\n###### Defining type promotions\n\nIn fact, `promote()` does its job by calling the `promote_rule()` function.\n\n::: {#e3de0cf5 .cell execution_count=104}\n``` {.julia .cell-code}\nimport Base: promote_rule\n\n# If an expression contains both Radian and DMS, convert DMS into Radian\npromote_rule(::Type{Radian}, ::Type{DMS}) = Radian\n```\n\n::: {.cell-output .cell-output-display execution_count=82}\n```\npromote_rule (generic function with 210 methods)\n```\n:::\n:::\n\n\n###### Defining arithmetic operations\n\n::: {#8cb69307 .cell execution_count=105}\n``` {.julia .cell-code}\nimport Base: +, -\n\n# If an expression contains both Radian and DMS, convert DMS into Radian, and then perform arithmetic operations of Radian\n+(θ::Angle, α::Angle) = +(promote(θ, α)...)\n-(θ::Angle, α::Angle) = -(promote(θ, α)...)\n\n+(θ::Radian, α::Radian) = Radian(θ.radians + α.radians)\n-(θ::Radian, α::Radian) = Radian(θ.radians - α.radians)\n\n+(θ::DMS, α::DMS) = DMS(θ.seconds + α.seconds)\n-(θ::DMS, α::DMS) = DMS(θ.seconds - α.seconds)\n```\n\n::: {.cell-output .cell-output-display execution_count=83}\n```\n- (generic function with 335 methods)\n```\n:::\n:::\n\n\n###### Making pretty literals by using literal coefficients\n\n::: {#da2f05dc .cell execution_count=106}\n``` {.julia .cell-code}\nimport Base: *, /\n\n*(coeff::Number, dms::DMS) = DMS(0, 0, coeff * dms.seconds)\n*(dms::DMS, coeff::Number) = coeff * dms\n/(dms::DMS, denom::Number) = DMS(0, 0, dms.seconds / denom)\n\n*(coeff::Number, radian::Radian) = Radian(coeff * radian.radians)\n*(radian::Radian, coeff::Number) = coeff * radian\n/(radian::Radian, denom::Number) = Radian(radian.radians / denom)\n\nconst ° = DMS(1)\nconst rad = Radian(1.0)\n```\n\n::: {.cell-output .cell-output-display execution_count=84}\n```\n1.0rad\n```\n:::\n:::\n\n\n###### Overriding standard `sin()` and `cos()` functions to only accept `DMS` and `Radian`\n\n::: callout-caution\nIn the following code snippet, we do not import `sin()` and `cos()` from the Base package, instead of overriding them (i.e. create a function and then attach the newly defined method to it).\n:::\n\n::: {#5c11c1c3 .cell execution_count=107}\n``` {.julia .cell-code}\n# The standard sin() and cos() only accept numbers regarded as the radian\nsin(rad::Radian) = Base.sin(rad.radians)\ncos(rad::Radian) = Base.cos(rad.radians)\n\nsin(dms::DMS) = sin(Radian(dms))\ncos(dms::DMS) = cos(Radian(dms))\n```\n:::\n\n\n#### Representing unknown values\n\n1.  `nothing`: indicates something not existed.\n\nThe `nothing` object is an instance of the type `Nothing`, which is a composite type without any fields.\n\n::: callout-note\nEvery instance of a composite type with zero fields is the same obeject.\n\n::: {#61456d92 .cell execution_count=108}\n``` {.julia .cell-code}\nstruct MyNothing\n    # No fields defined here\nend\n\nobj1 = MyNothing()\nobj2 = MyNothing()\n\nobj1 == obj2\n```\n\n::: {.cell-output .cell-output-display execution_count=85}\n```\ntrue\n```\n:::\n:::\n\n\nInstances of different composite types with zero fields are different.\n\n::: {#cb5b77e7 .cell execution_count=109}\n``` {.julia .cell-code}\nstruct AgainNothing\n    # No fields defined here\nend\n\nobj1 = MyNothing()\nobj2 = AgainNothing()\n\nobj1 == obj2\n```\n\n::: {.cell-output .cell-output-display execution_count=86}\n```\nfalse\n```\n:::\n:::\n\n\n:::\n\n2.  `missing`: indicates something, which should have existed, but missing due to some reason (i.e. unlike `nothing`, missing data actually exists in the real world, but we don't know what it is).\n\nThe concept of `missing`, which is of type `Missing`, a composite type with zero fields, is the same as that in statistics.\n\n::: callout-caution\nAny expression containing `missing` will be evaluated to `missing`!\n\nYou can use `skipmissing()` to filter `missing` out.\n:::\n\n3.  `NaN`: indicates something, which is **Not a Number**.\n\n**Similarly, `NaN` also propagates through all calculations.**\n\nThe only difference of the propagation behaviour between `NaN` and `missing` is that `NaN` always returns `false` when `NaN` is used in a comparison expression, where `missing` always returns `missing`:\n\n::: {#9380fecf .cell execution_count=110}\n``` {.julia .cell-code}\nmissing < 10, NaN < 10\n```\n\n::: {.cell-output .cell-output-display execution_count=87}\n```\n(missing, false)\n```\n:::\n:::\n\n\n::: callout-caution\n`0/0` returns `NaN`.\n\nIn other words, `0/0` may be a valid number somewhere else, but now it doesn't belong to any number we have already defined; thus it is regarded as `NaN`.\n:::\n\n4.  `#undef`: indicates something undefined (i.e. a variable was not instantiated to a known value).\n\ne.g. Julia allows the construction of composite objects with uninitialized fields; however, it will throw an exception if you try to access an uninitialized field:\n\n::: callout-note\nBoth `firstname` and `lastname` in the type `Person` have no type annotations. If you define them with type annotations, Julia will automatically instantiate them to some values based on their types.\n\nIn other words, if some fields have no type annotations, then Julia has no way of guessing what the fields should be initialized to.\n:::\n\n::: {#af1554be .cell execution_count=111}\n``` {.julia .cell-code}\nstruct Person\n    firstname\n    lastname\n    Person(firstname::String, lastname::String) = new(firstname, lastname)  # This allows you to instantiate instances of Person with arguments\n    Person() = new()  # This allows you to instantiate instances of Person without arguments\nend\n\nfriend = Person()\n\nfriend\n```\n\n::: {.cell-output .cell-output-display execution_count=88}\n```\nPerson(#undef, #undef)\n```\n:::\n:::\n\n\n::: {#7aa67571 .cell execution_count=112}\n``` {.julia .cell-code}\nfriend.firstname\n```\n\n::: {.cell-output .cell-output-error}\n```\nLoadError: UndefRefError: access to undefined reference\nUndefRefError: access to undefined reference\n\nStacktrace:\n [1] getproperty(x::Person, f::Symbol)\n   @ Base ./Base.jl:37\n [2] top-level scope\n   @ In[89]:2\n```\n:::\n:::\n\n\n##### To solve infinite chain of initialization using parametric type\n\nA parametric type can be regarded as a function which accepts type parameters, and then returns a new type.\n\ne.g. if `P` is a parametric type, and `T` is a type, then `P{T}` returns a new type.\n\nYou can think of a parametric type as a template to make an actual type:\n\n::: {#d6f0e81d .cell execution_count=113}\n``` {.julia .cell-code}\ntypeof(1:3)  # Equivalent to UnitRange(1, 3)\n```\n\n::: {.cell-output .cell-output-display execution_count=90}\n```\nUnitRange{Int64}\n```\n:::\n:::\n\n\n::: {#f6d663dc .cell execution_count=114}\n``` {.julia .cell-code}\nFloatRange = UnitRange{Float64}\n```\n\n::: {.cell-output .cell-output-display execution_count=91}\n```\nUnitRange{Float64}\n```\n:::\n:::\n\n\n::: {#b9f977d3 .cell execution_count=115}\n``` {.julia .cell-code}\nFloatRange(1, 3)\n```\n\n::: {.cell-output .cell-output-display execution_count=92}\n```\n1.0:3.0\n```\n:::\n:::\n\n\nWe can use the `Union` parametric type to solve infinite chain of initialization. `Union` accetps one or more type parameters, and then return a new type which can serve as placeholders for any of the types listed as type parameters.\n\n::: {#636b56fe .cell execution_count=116}\n``` {.julia .cell-code}\nf1(x::Union{Int, String}) = x^3\n```\n\n::: {.cell-output .cell-output-display execution_count=93}\n```\nf1 (generic function with 1 method)\n```\n:::\n:::\n\n\n::: {#e6f7f1d7 .cell execution_count=117}\n``` {.julia .cell-code}\nf1(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=94}\n```\n27\n```\n:::\n:::\n\n\n::: {#74440e03 .cell execution_count=118}\n``` {.julia .cell-code}\nf1(\"hello\")\n```\n\n::: {.cell-output .cell-output-display execution_count=95}\n```\n\"hellohellohello\"\n```\n:::\n:::\n\n\n::: {#b326b3aa .cell execution_count=119}\n``` {.julia .cell-code}\nf1(1.1)\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>MethodError: no method matching f1(::Float64)\n\nClosest candidates are:\n  f1(<span class=\"ansi-bright-red-fg\">::Union{Int64, String}</span>)\n<span class=\"ansi-bright-black-fg\">   @</span> <span class=\"ansi-magenta-fg\">Main</span> <span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">In[93]:1</span>\n\n\nStacktrace:\n [1] top-level scope\n   @ In[96]:2</pre>\n```\n:::\n\n:::\n:::\n\n\nNow let's solve the problem of infinite chain of initialization using parametric type:\n\n::: {#52ad9b6b .cell execution_count=120}\n``` {.julia .cell-code}\nstruct Wagon\n    cargo::Float64\n    next::Union{Wagon, Nothing}  # next can be an object of either Wagon or Nothing\nend\n\n# Calculate the total tons of cargo in the train\ncargo(w::Wagon) = w.cargo + cargo(w.next)\ncargo(::Nothing) = 0.0\n\ntrain = Wagon(6, Wagon(8, Wagon(10, nothing)))\n\ncargo(train)\n```\n\n::: {.cell-output .cell-output-display execution_count=97}\n```\n24.0\n```\n:::\n:::\n\n\n### Collections\n\nCollections are objects that store and organize other objects.\n\n#### Strings\n\nIn computer memory, everything is a number, including characters.\n\n-   A character (`Char` type) is quoted by `''`.\n\n::: {#b088a51f .cell execution_count=121}\n``` {.julia .cell-code}\nInt8('A')\n```\n\n::: {.cell-output .cell-output-display execution_count=98}\n```\n65\n```\n:::\n:::\n\n\n::: {#ee3bb297 .cell execution_count=122}\n``` {.julia .cell-code}\nChar(65)\n```\n\n::: {.cell-output .cell-output-display execution_count=99}\n```\n'A': ASCII/Unicode U+0041 (category Lu: Letter, uppercase)\n```\n:::\n:::\n\n\nYou can add a number to a character, which returns a new character corresponding to the sum:\n\n::: {#38e36d01 .cell execution_count=123}\n``` {.julia .cell-code}\n'A' + 3\n```\n\n::: {.cell-output .cell-output-display execution_count=100}\n```\n'D': ASCII/Unicode U+0044 (category Lu: Letter, uppercase)\n```\n:::\n:::\n\n\n-   A string is quoted by `\"\"` or \\``\"\"\"\"\"\"`.\n\nLong lines in strings can be broken up by preceding the newline with a backslash (`\\`):\n\n::: {#2b0370ef .cell execution_count=124}\n``` {.julia .cell-code}\n\"This is a long \\\nline\"\n```\n\n::: {.cell-output .cell-output-display execution_count=101}\n```\n\"This is a long line\"\n```\n:::\n:::\n\n\nMerging elements into a string by `join()`:\n\n::: {#96bba3c9 .cell execution_count=125}\n``` {.julia .cell-code}\nchars = 'A':'Z'\n\njoin(chars)\n```\n\n::: {.cell-output .cell-output-display execution_count=102}\n```\n\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n```\n:::\n:::\n\n\nSplitting a string into characters by `collect()`:\n\n::: {#be360d2b .cell execution_count=126}\n``` {.julia .cell-code}\ncollect(\"HELLO\")\n```\n\n::: {.cell-output .cell-output-display execution_count=103}\n```\n5-element Vector{Char}:\n 'H': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)\n 'E': ASCII/Unicode U+0045 (category Lu: Letter, uppercase)\n 'L': ASCII/Unicode U+004C (category Lu: Letter, uppercase)\n 'L': ASCII/Unicode U+004C (category Lu: Letter, uppercase)\n 'O': ASCII/Unicode U+004F (category Lu: Letter, uppercase)\n```\n:::\n:::\n\n\nIn fact, you can `collect()` any iterable objects into an array.\n\n##### Unicode and UTF-8\n\nText strings in Julia are Unicode, encoded in UTF-8 format.\n\nIn Unicode, each character is given a number (**code point**), encoded by several bytes (**code units**) in computer.\n\nUTF-8 is the current Unicode scheme used, which uses a variable number of bytes (1-4 bytes) per character to encode characters in computer.\n\nYou can use `codepoint()` to get the code point of a character, and `ncodeunits()` to get the code units of a character.\n\nIn addition, UTF-8 is backward compatible with ASCII (encoding each character with 1 byte). You can use `isascii()` to check whether a character is a ASCII character.\n\n::: {#810e6ab7 .cell execution_count=127}\n``` {.julia .cell-code}\ncodepoint('A'), ncodeunits('A'), isascii('A')\n```\n\n::: {.cell-output .cell-output-display execution_count=104}\n```\n(0x00000041, 1, true)\n```\n:::\n:::\n\n\nAs a consequence, you can type a character by typing either the character itself or its code point.\n\n::: {#fb8a7d88 .cell execution_count=128}\n``` {.julia .cell-code}\n'A', '\\U41', Char(0x00000041)\n```\n\n::: {.cell-output .cell-output-display execution_count=105}\n```\n('A', 'A', 'A')\n```\n:::\n:::\n\n\n##### String indexing\n\nYou can use subscript index to index each character in a string, but the step between indices is not always 1. It may be an integer greater than 1.\n\nYou can combine the following functions to get correct indices for each character in a string:\n\n-   `firstindex()`: return the first index in a string.\n\n-   `lastindex()`: return the last index in a string.\n\n-   `nextind(s, i)`: return the next index of the element following index `i` in `s`.\n\n-   `eachindex()`: return the indices of each element.\n\n-   Using `for` loop to iterate a string.\n\n::: {#9ea115ac .cell execution_count=129}\n``` {.julia .cell-code}\ns = \"123一二三\"\n\ni = firstindex(s)\nwhile i <= lastindex(s)\n    println((i, s[i]))\n    i = nextind(s, i)\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(1, '1')\n(2, '2')\n(3, '3')\n(4, '一')\n(7, '二')\n(10, '三')\n```\n:::\n:::\n\n\n::: {#86acb168 .cell execution_count=130}\n``` {.julia .cell-code}\nfor i in s\n    println(i)\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n2\n3\n一\n二\n三\n```\n:::\n:::\n\n\n::: {#49f8408d .cell execution_count=131}\n``` {.julia .cell-code}\nfor i in eachindex(s)\n    println((i, s[i]))\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(1, '1')\n(2, '2')\n(3, '3')\n(4, '一')\n(7, '二')\n(10, '三')\n```\n:::\n:::\n\n\n##### String operations\n\n1.  Splitting strings\n\n::: {#c8826e60 .cell execution_count=132}\n``` {.julia .cell-code}\nsplit(\"abc_def_ghi\", \"_\")\n```\n\n::: {.cell-output .cell-output-display execution_count=109}\n```\n3-element Vector{SubString{String}}:\n \"abc\"\n \"def\"\n \"ghi\"\n```\n:::\n:::\n\n\n::: {#1ef87674 .cell execution_count=133}\n``` {.julia .cell-code}\nsplit(\"abcAdefBghi\", isuppercase)\n```\n\n::: {.cell-output .cell-output-display execution_count=110}\n```\n3-element Vector{SubString{String}}:\n \"abc\"\n \"def\"\n \"ghi\"\n```\n:::\n:::\n\n\n2.  Converting letters between uppercases and lowercases\n\n::: {#5e589b24 .cell execution_count=134}\n``` {.julia .cell-code}\nmap(uppercasefirst, split(\"abc_def_ghi\", \"_\"))\n```\n\n::: {.cell-output .cell-output-display execution_count=111}\n```\n3-element Vector{String}:\n \"Abc\"\n \"Def\"\n \"Ghi\"\n```\n:::\n:::\n\n\n::: {#83b31f20 .cell execution_count=135}\n``` {.julia .cell-code}\nisuppercase('A')  # Check whether a single letter is in the form of uppercase\n```\n\n::: {.cell-output .cell-output-display execution_count=112}\n```\ntrue\n```\n:::\n:::\n\n\n3.  Joining substrings\n\n::: {#e4661291 .cell execution_count=136}\n``` {.julia .cell-code}\njoin([\"abc\", \"def\", \"ghi\"], \"_\")\n```\n\n::: {.cell-output .cell-output-display execution_count=113}\n```\n\"abc_def_ghi\"\n```\n:::\n:::\n\n\n4.  Reading from and writing to the clipboard\n\n::: {#ca993ef2 .cell execution_count=137}\n``` {.julia .cell-code}\n# Write to the clipboard\nclipboard(\"Hello, world!\")\n\n# Read from the clipboard\nclipboard()\n```\n\n::: {.cell-output .cell-output-display execution_count=114}\n```\n\"Hello, world!\\n\"\n```\n:::\n:::\n\n\nOn Linux, `clipboard()` works only when you have installed the `xsel` or `xclip` commands.\n\n5.  Finding whether a substring is existed in a string by using `find*` functions\n\n::: {#423f6f1b .cell execution_count=138}\n``` {.julia .cell-code}\nfindall(\"abc\", \"abc_def_abc\")\n```\n\n::: {.cell-output .cell-output-display execution_count=115}\n```\n2-element Vector{UnitRange{Int64}}:\n 1:3\n 9:11\n```\n:::\n:::\n\n\n::: {#eff252a2 .cell execution_count=139}\n``` {.julia .cell-code}\nfindall(isuppercase, \"AaBbCc\")\n```\n\n::: {.cell-output .cell-output-display execution_count=116}\n```\n3-element Vector{Int64}:\n 1\n 3\n 5\n```\n:::\n:::\n\n\n6.  Converting between numbers and strings\n\n::: {#44e75b44 .cell execution_count=140}\n``` {.julia .cell-code}\nparse(Float64, \"3.14\")  # The default base is 10\n```\n\n::: {.cell-output .cell-output-display execution_count=117}\n```\n3.14\n```\n:::\n:::\n\n\n::: {#b7dfde3b .cell execution_count=141}\n``` {.julia .cell-code}\nparse(Int, \"1010101\", base = 2)\n```\n\n::: {.cell-output .cell-output-display execution_count=118}\n```\n85\n```\n:::\n:::\n\n\n::: {#d3105259 .cell execution_count=142}\n``` {.julia .cell-code}\nstring(100)  # The default base is 10\n```\n\n::: {.cell-output .cell-output-display execution_count=119}\n```\n\"100\"\n```\n:::\n:::\n\n\n::: {#73e28801 .cell execution_count=143}\n``` {.julia .cell-code}\nstring(100, base = 2)\n```\n\n::: {.cell-output .cell-output-display execution_count=120}\n```\n\"1100100\"\n```\n:::\n:::\n\n\n7.  String concatenation\n\n::: {#0e143935 .cell execution_count=144}\n``` {.julia .cell-code}\nfruit = \"apple\"\n\nstring(\"This is a(an) \", fruit, \", made in China.\")\n```\n\n::: {.cell-output .cell-output-display execution_count=121}\n```\n\"This is a(an) apple, made in China.\"\n```\n:::\n:::\n\n\n::: {#69db7594 .cell execution_count=145}\n``` {.julia .cell-code}\n\"This is a(an) \" * fruit * \", made in China.\"\n```\n\n::: {.cell-output .cell-output-display execution_count=122}\n```\n\"This is a(an) apple, made in China.\"\n```\n:::\n:::\n\n\n8.  String interpolation\n\n::: {#3778a846 .cell execution_count=146}\n``` {.julia .cell-code}\n\"This is a(an) $fruit, made in China.\"\n```\n\n::: {.cell-output .cell-output-display execution_count=123}\n```\n\"This is a(an) apple, made in China.\"\n```\n:::\n:::\n\n\n::: {#17388b79 .cell execution_count=147}\n``` {.julia .cell-code}\n\"This is a(an) $(fruit), made in China.\"\n```\n\n::: {.cell-output .cell-output-display execution_count=124}\n```\n\"This is a(an) apple, made in China.\"\n```\n:::\n:::\n\n\n9.  String formatting\n\nYou can use macros `@printf` and `@sprintf` to perform string formatting. These two macros are defined in the Printf module.\n\nIn Julia, macros are distinguished from functions with the `@` prefix.\n\nA macro is akin to a code generator; the call site of a macro gets replaced with other code.\n\n-   `@printf` outputs the result to the console:\n\n::: {#c05a1820 .cell execution_count=148}\n``` {.julia .cell-code}\nusing Printf\n\n@printf(\"π = %0.2f\", pi)  # Output pi (floating-point number) with two digits\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nπ = 3.14\n```\n:::\n:::\n\n\n-   `@sprintf` returns the result as a string.\n\n::: {#ea46ffa1 .cell execution_count=149}\n``` {.julia .cell-code}\n@sprintf(\"π = %0.2f\", pi)\n```\n\n::: {.cell-output .cell-output-display execution_count=126}\n```\n\"π = 3.14\"\n```\n:::\n:::\n\n\nFor a systematic specification of the format, see [here](https://cplusplus.com/reference/cstdio/printf).\n\n##### Nonstandard string literals\n\nIn Julia, you cannot express very large numbers as number literals, so you have to express them as strings that get parsed later.\n\ne.g.\n\n::: {#715da403 .cell execution_count=150}\n``` {.julia .cell-code}\n3.14e600\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>ParseError:\n<span class=\"ansi-bright-black-fg\"># Error @ </span>]8;;file:///home/yangrui/mywd/NeuroBorder/Blogs/Computer/posts/Programming/Julia/julia_syntax_basics/In[127]#2:1\\<span class=\"ansi-bright-black-fg\">In[127]:2:1</span>]8;;\\\n\n<span style=\"background-color:rgb(120,70,70)\">3.14e600</span>\n<span class=\"ansi-bright-black-fg\">└──────┘ ── </span><span class=\"ansi-bright-red-fg\">overflow in floating point literal</span>\n\nStacktrace:\n [1] top-level scope\n   @ In[127]:2</pre>\n```\n:::\n\n:::\n:::\n\n\n::: {#fa3e8c61 .cell execution_count=151}\n``` {.julia .cell-code}\nx = parse(BigFloat, \"3.14e600\")\n```\n\n::: {.cell-output .cell-output-display execution_count=128}\n```\n3.140000000000000000000000000000000000000000000000000000000000000000000000000003e+600\n```\n:::\n:::\n\n\n::: {#f04beed5 .cell execution_count=152}\n``` {.julia .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-display execution_count=129}\n```\nBigFloat\n```\n:::\n:::\n\n\nIf you put such a expression into a loop, then it will be run at least once in each loop:\n\n::: {#0e3c12c3 .cell execution_count=153}\n``` {.julia .cell-code}\nfor i in 1:4\n    x = parse(BigFloat, \"3.14e600\")\n    println(x)\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3.140000000000000000000000000000000000000000000000000000000000000000000000000003e+600\n3.140000000000000000000000000000000000000000000000000000000000000000000000000003e+600\n3.140000000000000000000000000000000000000000000000000000000000000000000000000003e+600\n3.140000000000000000000000000000000000000000000000000000000000000000000000000003e+600\n```\n:::\n:::\n\n\nThis will damage the performance of your program.\n\nTo avoid having to parse strings to create objects such as `BigFloat` in each loop, Julia provides special string literals such as `big\"3.14e600\"`.\n\nJulia will parse such a string literal only once for a `for` loop in your program, but run them many times (i.e. it won't be parsed in each loop).\n\nIn other words, these objects such as `BigFloat` are created at parse time, rather than runtime.\n\n1.  DateFormat strings\n\n-   In the following code, the `DateFormat` object will be created in each loop:\n\n::: {#711fd31a .cell execution_count=154}\n``` {.julia .cell-code}\nusing Dates\n\ndates = [\"21/7\", \"8/12\", \"28/2\"]\n\nfor s in dates\n    date = Date(s, DateFormat(\"dd/mm\"))  # Convert a date string into a date object\n    date_str = Dates.format(date, DateFormat(\"E-u\"))  # Convert a date object into a date string with given date format\n    println(date_str)\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSaturday-Jul\nSaturday-Dec\nWednesday-Feb\n```\n:::\n:::\n\n\n-   In the following code, the `DateFormat` object will be created once, but the code becomes less clear at the first glance:\n\n::: {#bd362b06 .cell execution_count=155}\n``` {.julia .cell-code}\nusing Dates\n\ninformat = DateFormat(\"dd/mm\")\noutformat = DateFormat(\"E-u\")\n\ndates = [\"21/7\", \"8/12\", \"28/2\"]\n\nfor s in dates\n    date = Date(s, informat)  # Convert a date string into a date object\n    date_str = Dates.format(date, outformat)  # Convert a date object into a date string with given date format\n    println(date_str)\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSaturday-Jul\nSaturday-Dec\nWednesday-Feb\n```\n:::\n:::\n\n\n-   We can use the `dateformat` literal to solve this problem:\n\n::: {#e6f39c5a .cell execution_count=156}\n``` {.julia .cell-code}\nusing Dates\n\ndates = [\"21/7\", \"8/12\", \"28/2\"]\n\nfor s in dates\n    date = Date(s, dateformat\"dd/mm\")  # Convert a date string into a date object\n    date_str = Dates.format(date, dateformat\"E-u\")  # Convert a date object into a date string with given date format\n    println(date_str)\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSaturday-Jul\nSaturday-Dec\nWednesday-Feb\n```\n:::\n:::\n\n\nFor detailed date format specifications, see `?DateFormat`.\n\n2.  Raw strings\n\nIn regular Julia strings, characters such as `$` and `\\n` have special meaning.\n\nIf you just want every character in a string to be literal, you need to prefix special characters with a `\\` to escape them.\n\nBut the more convenient way is to prefix a string with `raw` to tell Julia that this is a raw string, which means that every character in it is literal.\n\n::: {#5e4848fb .cell execution_count=157}\n``` {.julia .cell-code}\nnum = 100\n\nraw\"What? $(num)?\"  # num won't be replaced by its actual value\n```\n\n::: {.cell-output .cell-output-display execution_count=134}\n```\n\"What? \\$(num)?\"\n```\n:::\n:::\n\n\n3.  Regular expressions\n\nIn Julia, you can create a `Regex` object by prefixing your regular expression string with a `r`.\n\n::: {#21f714ea .cell execution_count=158}\n``` {.julia .cell-code}\ns = \"E-mail address: 123456@qq.com\"\n\nreplace(s, r\"\\d+(?=@)\" => \"abcdef\")  # Replace matched part with the pair value\n```\n\n::: {.cell-output .cell-output-display execution_count=135}\n```\n\"E-mail address: abcdef@qq.com\"\n```\n:::\n:::\n\n\nIn the following code, `match(r, s)` will search for the first match of the regular expression `r` in `s` and return a `RegexMatch` object containing the match, or `nothing` if the match failed.\n\n::: {#58ead54a .cell execution_count=159}\n``` {.julia .cell-code}\nrx = r\"\\d+:\\d+\"\n\nm = match(rx, \"11:30 in the morning; 12:00 in the noon\")\n\nm\n```\n\n::: {.cell-output .cell-output-display execution_count=136}\n```\nRegexMatch(\"11:30\")\n```\n:::\n:::\n\n\nIf some parts of the regular expression are contained within parentheses, then these matched parts will be extracted out alone from the matched string, and you can retrieve these parts by indices:\n\n::: {#30f1281f .cell execution_count=160}\n``` {.julia .cell-code}\nrx = r\"(\\d+):(\\d+)\"\n\nm = match(rx, \"11:30 in the morning; 12:00 in the noon\")\n\nm\n```\n\n::: {.cell-output .cell-output-display execution_count=137}\n```\nRegexMatch(\"11:30\", 1=\"11\", 2=\"30\")\n```\n:::\n:::\n\n\n::: {#89060e8e .cell execution_count=161}\n``` {.julia .cell-code}\nm[1], m[2]\n```\n\n::: {.cell-output .cell-output-display execution_count=138}\n```\n(\"11\", \"30\")\n```\n:::\n:::\n\n\nFurther, you can give these parts names (`?<name>`) so you can retrieve them by names instead of indices:\n\n::: {#55921207 .cell execution_count=162}\n``` {.julia .cell-code}\nrx = r\"(?<hour>\\d+):(?<minute>\\d+)\"\n\nm = match(rx, \"11:30 in the morning; 12:00 in the noon\")\n\nm\n```\n\n::: {.cell-output .cell-output-display execution_count=139}\n```\nRegexMatch(\"11:30\", hour=\"11\", minute=\"30\")\n```\n:::\n:::\n\n\n::: {#29703685 .cell execution_count=163}\n``` {.julia .cell-code}\nm[\"hour\"], m[\"minute\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=140}\n```\n(\"11\", \"30\")\n```\n:::\n:::\n\n\nIn addition, you can also iterate over a `RegexMatch` object, and many functions applicable to dictionaries also works with the `RegexMatch` object.\n\n4.  Number literals with `big`\n\nYou can use the `big` number literal to create extremely large numbers:\n\n::: {#218e7ada .cell execution_count=164}\n``` {.julia .cell-code}\ntypeof(big\"100\")  # BigInt\n```\n\n::: {.cell-output .cell-output-display execution_count=141}\n```\nBigInt\n```\n:::\n:::\n\n\n::: {#55a0c984 .cell execution_count=165}\n``` {.julia .cell-code}\ntypeof(big\"1e600\")  # BigFloat\n```\n\n::: {.cell-output .cell-output-display execution_count=142}\n```\nBigFloat\n```\n:::\n:::\n\n\n5.  Defining your own number literals with macros\n\n::: {#dbb21098 .cell execution_count=166}\n``` {.julia .cell-code}\nmacro int8_str(s)  # For a string literal with the prefix foo, such as foo\"100\", write foo_str\n    println(\"hello\")  # You can check how many times the \"hello\" will be printed when you call this macro in a loop\n    parse(Int8, s)  # Parse the number string and return an 8-bit number\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=143}\n```\n@int8_str (macro with 1 method)\n```\n:::\n:::\n\n\n::: {#5d817c99 .cell execution_count=167}\n``` {.julia .cell-code}\ntotal = 0\n\n# The \"hello\" will be printed only once,\n# which indicates that the 8-bit integer is created when the program is parsed,\n# not each time it is run\nfor _ in 1:4\n    total += int8\"10\"\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nhello\n```\n:::\n:::\n\n\n::: {#198c7f33 .cell execution_count=168}\n``` {.julia .cell-code}\ntotal\n```\n\n::: {.cell-output .cell-output-display execution_count=145}\n```\n40\n```\n:::\n:::\n\n\n6.  MIME types\n\nMIME means Multipurpose Internet Mail Extensions, which is used as a standard to identify the file types across devices because Windows usually uses a filename extension to indicate the type of a file, while Unix-like system stores the file type in special attributes.\n\nIn Julia, you can create a MIME type object in the following way:\n\n::: {#6514a160 .cell execution_count=169}\n``` {.julia .cell-code}\nMIME(\"text/html\")  # This denotes that the type of this file is a HTML page\n```\n\n::: {.cell-output .cell-output-display execution_count=146}\n```\nMIME type text/html\n```\n:::\n:::\n\n\n::: {#670ed403 .cell execution_count=170}\n``` {.julia .cell-code}\ntypeof(ans)  # The above MIME object with the type of MIME{Symbol(\"text/html\")}.\n```\n\n::: {.cell-output .cell-output-display execution_count=147}\n```\nMIME{Symbol(\"text/html\")}\n```\n:::\n:::\n\n\nNow we know that `MIME` type is a parametric type. When you pass `\"text/html\"` to its constructor, the concrete type of the object is `MIME{Symbol(\"text/html\")}`. This is long and cumbersome to write so this is why Julia offers the shortcut `MIME\"text/html\"`, **which is a concrete MIME type, not an object**.\n\n::: {#d3ee0df8 .cell execution_count=171}\n``` {.julia .cell-code}\nsay_hello(::MIME\"text/plain\") = \"hello world\"\nsay_hello(::MIME\"text/html\") = \"<h1>hello world</h1>\"\n```\n\n::: {.cell-output .cell-output-display execution_count=148}\n```\nsay_hello (generic function with 2 methods)\n```\n:::\n:::\n\n\n::: {#06055240 .cell execution_count=172}\n``` {.julia .cell-code}\nsay_hello(MIME(\"text/plain\"))\n```\n\n::: {.cell-output .cell-output-display execution_count=149}\n```\n\"hello world\"\n```\n:::\n:::\n\n\n::: {#83d0a3bc .cell execution_count=173}\n``` {.julia .cell-code}\nsay_hello(MIME(\"text/html\"))\n```\n\n::: {.cell-output .cell-output-display execution_count=150}\n```\n\"<h1>hello world</h1>\"\n```\n:::\n:::\n\n\n#### Arrays\n\n##### Types of arrays\n\n1.  1D array\n\n-   Column vector (type `Vector`)\n\nElements are separated by `,` inside `[]`.\n\nCreating a column vector with default data type:\n\n::: {#35415dd8 .cell execution_count=174}\n``` {.julia .cell-code}\ncolumn_vector = [1, 2, 3]\n```\n\n::: {.cell-output .cell-output-display execution_count=151}\n```\n3-element Vector{Int64}:\n 1\n 2\n 3\n```\n:::\n:::\n\n\nCreating a column vector with given data type:\n\n::: {#b47e68f3 .cell execution_count=175}\n``` {.julia .cell-code}\ncolumn_vector = Int8[1, 2, 3]\n```\n\n::: {.cell-output .cell-output-display execution_count=152}\n```\n3-element Vector{Int8}:\n 1\n 2\n 3\n```\n:::\n:::\n\n\nYou can check what type each element in an array is by using the `eltype()` function. If an array contains different types of elements, it will return `Any`.\n\n-   Row vector (1 by n matrix, type `Matrix`)\n\nElements are separated by space.\n\n::: {#8d0655e0 .cell execution_count=176}\n``` {.julia .cell-code}\nrow_vector = [1 2 3]\n```\n\n::: {.cell-output .cell-output-display execution_count=153}\n```\n1×3 Matrix{Int64}:\n 1  2  3\n```\n:::\n:::\n\n\n2.  2D array (type `Matrix`)\n\nRows are separated by `;`.\n\n::: {#b8829df9 .cell execution_count=177}\n``` {.julia .cell-code}\nmatrix = [1 2 3;\n          4 5 6;\n          7 8 9]\n\n# or\nmatrix = [1 2 3; 4 5 6; 7 8 9]\n```\n\n::: {.cell-output .cell-output-display execution_count=154}\n```\n3×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n 7  8  9\n```\n:::\n:::\n\n\nColumns are separated by space:\n\n::: {#70bb0d11 .cell execution_count=178}\n``` {.julia .cell-code}\nmatrix = [[1, 2, 3] [4, 5, 6] [7, 8, 9]]\n```\n\n::: {.cell-output .cell-output-display execution_count=155}\n```\n3×3 Matrix{Int64}:\n 1  4  7\n 2  5  8\n 3  6  9\n```\n:::\n:::\n\n\n3.  Array (type `Array`)\n\nThe dimension of an array is greater than 2.\n\n::: {#1006068f .cell execution_count=179}\n``` {.julia .cell-code}\nzeros(Int64, 2, 3, 4)  # two rows, three columns, and four slices\n```\n\n::: {.cell-output .cell-output-display execution_count=156}\n```\n2×3×4 Array{Int64, 3}:\n[:, :, 1] =\n 0  0  0\n 0  0  0\n\n[:, :, 2] =\n 0  0  0\n 0  0  0\n\n[:, :, 3] =\n 0  0  0\n 0  0  0\n\n[:, :, 4] =\n 0  0  0\n 0  0  0\n```\n:::\n:::\n\n\n##### Creating arrays by specific functions\n\n`zeros()`, `ones()`, `fill()`, `rand()`.\n\n::: callout-note\nArrays can contain any type of element.\n\nYou can check the type of an object by using either `typeof()`, which **reports the types of the object itself and its elements**; or `eltype()`, which **only reports the type of its elements**.\n\nJulia will guess the type of elements in an array if it's not given explicitly when an array is created.\n\nIf an array contains different types of elements, then the type of elements in this array will be `Any`, which means that you can store any type of values.\n\nWhen you add elements to an array by using `push!()`, it will check **whether the type of elements to be added is consistent with the type of elements in this array**, or **whether the type of elements to be added can be converted to the type of elements in this array**. If both failed, Julia will raise an error!\n:::\n\n##### Accessing array attributes\n\n1.  `size()`: the size of each dimension of an array.\n\n2.  `eltype()`: the type of elements in an array.\n\n3.  `typeof()`: the type of the object itself and its elements.\n\n4.  `ndims()`: the dimension of an array.\n\n5.  `length()`: total number of elements in an array.\n\n6.  `reshape()`: change the shape of an array.\n\n7.  `norm()`: magnitude of a vector, calculated by the following formula (this function comes from the package LinearAlgebra).\n\n$$\n \\|A\\|_p = \\left(\\sum_{i=1}^n |a_i|^p \\right)^{1/p}\n$$\n\n##### Operartions on arrays\n\nSuppose we have:\n\n::: {#d627efee .cell execution_count=180}\n``` {.julia .cell-code}\namounts = [4, 2, 5, 8, 1, 10]\n```\n\n::: {.cell-output .cell-output-display execution_count=157}\n```\n6-element Vector{Int64}:\n  4\n  2\n  5\n  8\n  1\n 10\n```\n:::\n:::\n\n\n::: {#a5b16c57 .cell execution_count=181}\n``` {.julia .cell-code}\nprices = [15.0, 2.5, 3.8, 9.0, 10.5, 8.5]\n```\n\n::: {.cell-output .cell-output-display execution_count=158}\n```\n6-element Vector{Float64}:\n 15.0\n  2.5\n  3.8\n  9.0\n 10.5\n  8.5\n```\n:::\n:::\n\n\nNote: both `amounts` and `prices` are **column vectors**.\n\n-   `sum()`\n\n::: {#4291d074 .cell execution_count=182}\n``` {.julia .cell-code}\nsum(amounts)\n```\n\n::: {.cell-output .cell-output-display execution_count=159}\n```\n30\n```\n:::\n:::\n\n\n-   `push!()`: insert one or more items into a collection.\n\n-   `sort()` or `sort!()`\n\n::: {#76f6e906 .cell execution_count=183}\n``` {.julia .cell-code}\n# Not modify input in place\nsort(amounts)\n```\n\n::: {.cell-output .cell-output-display execution_count=160}\n```\n6-element Vector{Int64}:\n  1\n  2\n  4\n  5\n  8\n 10\n```\n:::\n:::\n\n\n::: {#c29e611f .cell execution_count=184}\n``` {.julia .cell-code}\namounts\n```\n\n::: {.cell-output .cell-output-display execution_count=161}\n```\n6-element Vector{Int64}:\n  4\n  2\n  5\n  8\n  1\n 10\n```\n:::\n:::\n\n\n::: {#1a6ffdb0 .cell execution_count=185}\n``` {.julia .cell-code}\n# Modify input in place\nsort!(amounts)\n```\n\n::: {.cell-output .cell-output-display execution_count=162}\n```\n6-element Vector{Int64}:\n  1\n  2\n  4\n  5\n  8\n 10\n```\n:::\n:::\n\n\n::: {#81c1f197 .cell execution_count=186}\n``` {.julia .cell-code}\namounts\n```\n\n::: {.cell-output .cell-output-display execution_count=163}\n```\n6-element Vector{Int64}:\n  1\n  2\n  4\n  5\n  8\n 10\n```\n:::\n:::\n\n\n::: callout-note\nBy convention, Julia functions never modify any of their inputs in place.\n\nIf it is necessary to modify inputs in place, Julia has established the convention of tacking on an exclamation mark (`!`) to the name of any function which modifies its input in place instead of returning a modified version.\n:::\n\n-   Element-wise operations: `.+, .-, .*, ./`.\n\n::: {#b16dadc3 .cell execution_count=187}\n``` {.julia .cell-code}\namounts .* prices\n```\n\n::: {.cell-output .cell-output-display execution_count=164}\n```\n6-element Vector{Float64}:\n 15.0\n  5.0\n 15.2\n 45.0\n 84.0\n 85.0\n```\n:::\n:::\n\n\n-   Performing statistics by `using Statistics`.\n\n-   Performing operations of linear algebra by `using LinearAlgebra`.\n\n##### Slicing and dicing an array\n\n**Elements in a Julia array are numbered starting from 1 (i.e. 1-based indexing)!**\n\n::: {#5d398a3d .cell execution_count=188}\n``` {.julia .cell-code}\nvec = [1, 2, 3, 4, 5, 6]\n```\n\n::: {.cell-output .cell-output-display execution_count=165}\n```\n6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n```\n:::\n:::\n\n\n1.  Accessing elements by using `[index]`.\n\nFor arrays with dimension greater than 1, you can use `[dim1, dim2, ...]`.\n\n::: {#8a94f73a .cell execution_count=189}\n``` {.julia .cell-code}\nvec[3]\n```\n\n::: {.cell-output .cell-output-display execution_count=166}\n```\n3\n```\n:::\n:::\n\n\nOf course, subsetting and then assignment is supported:\n\n::: {#51c5c517 .cell execution_count=190}\n``` {.julia .cell-code}\nvec[3] = 100\n```\n\n::: {.cell-output .cell-output-display execution_count=167}\n```\n100\n```\n:::\n:::\n\n\n2.  Using `begin` and `end` to access the first and last element.\n\n::: {#b6f84800 .cell execution_count=191}\n``` {.julia .cell-code}\nvec[begin], vec[end]\n```\n\n::: {.cell-output .cell-output-display execution_count=168}\n```\n(1, 6)\n```\n:::\n:::\n\n\n3.  Using `:` to access all elements of some dimension.\n\n::: {#248e4691 .cell execution_count=192}\n``` {.julia .cell-code}\nvec[:]  # Access the whole vector\n```\n\n::: {.cell-output .cell-output-display execution_count=169}\n```\n6-element Vector{Int64}:\n   1\n   2\n 100\n   4\n   5\n   6\n```\n:::\n:::\n\n\n::: {#4e9909eb .cell execution_count=193}\n``` {.julia .cell-code}\nA = rand(Int64, 3, 3)\n\nA[:, 1]  # Access the 1st column\n```\n\n::: {.cell-output .cell-output-display execution_count=170}\n```\n3-element Vector{Int64}:\n  2750603897720011220\n -8230328028304376042\n  -626162070422440743\n```\n:::\n:::\n\n\n::: callout-important\nAll slice operations return **copies** of data.\n\n::: {#cad4603a .cell execution_count=194}\n``` {.julia .cell-code}\nA = collect(1:6)\n\nB = A[4:end]\n\nB[1] = 100\n\nB\n```\n\n::: {.cell-output .cell-output-display execution_count=171}\n```\n3-element Vector{Int64}:\n 100\n   5\n   6\n```\n:::\n:::\n\n\n::: {#967dd185 .cell execution_count=195}\n``` {.julia .cell-code}\nA\n```\n\n::: {.cell-output .cell-output-display execution_count=172}\n```\n6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n```\n:::\n:::\n\n\nInstead, to avoid copying data during slicing an array, you can prefix the `@view` macro to the slice operations, since it will only return a *view* of subset of the array.\n\n::: {#bb1c3522 .cell execution_count=196}\n``` {.julia .cell-code}\nA = collect(1:6)\n\nB = @view A[4:end]\n\nB[1] = 100\n\nB\n```\n\n::: {.cell-output .cell-output-display execution_count=173}\n```\n3-element view(::Vector{Int64}, 4:6) with eltype Int64:\n 100\n   5\n   6\n```\n:::\n:::\n\n\n::: {#b3eecf44 .cell execution_count=197}\n``` {.julia .cell-code}\nA\n```\n\n::: {.cell-output .cell-output-display execution_count=174}\n```\n6-element Vector{Int64}:\n   1\n   2\n   3\n 100\n   5\n   6\n```\n:::\n:::\n\n\n:::\n\n##### Combining arrays\n\n`cat()`, `hcat()`, and `vcat()`.\n\n#### Tuples\n\nElements are separated by `,` inside `()`.\n\n::: {#19877d64 .cell execution_count=198}\n``` {.julia .cell-code}\nt = (1, 2, 3)\n```\n\n::: {.cell-output .cell-output-display execution_count=175}\n```\n(1, 2, 3)\n```\n:::\n:::\n\n\n::: callout-note\nCreating a tuple containing only one element with `(1,)` (i.e. adding a `,` after the element).\n\nTuples are **immutable** once created.\n:::\n\n##### Named tuples\n\n::: {#78a9395b .cell execution_count=199}\n``` {.julia .cell-code}\nstudent = (name = \"Bob\", score  = 99, height = 2)\n\n# Index by Symbol or dot\nstudent[:name], student.name\n```\n\n::: {.cell-output .cell-output-display execution_count=176}\n```\n(\"Bob\", \"Bob\")\n```\n:::\n:::\n\n\n::: {#fe5ef93a .cell execution_count=200}\n``` {.julia .cell-code}\n# Symbol <==> String\nSymbol(\"price\"), string(:price)\n```\n\n::: {.cell-output .cell-output-display execution_count=177}\n```\n(:price, \"price\")\n```\n:::\n:::\n\n\n#### Dictionaries\n\nA dictionary is made up of **a number of pairs of `key => value`**, where key and value can be any type of values.\n\n##### Creating a dictionary\n\n-   Creating a pair with the arrow operator `=>`:\n\n::: {#c236c177 .cell execution_count=201}\n``` {.julia .cell-code}\np = 'a' => 1  # This is a pair with type Pair\n\ntypeof(p)\n```\n\n::: {.cell-output .cell-output-display execution_count=178}\n```\nPair{Char, Int64}\n```\n:::\n:::\n\n\n::: {#46478ed7 .cell execution_count=202}\n``` {.julia .cell-code}\ndump(p)  # You can use dump() to look at the fields of any value\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPair{Char, Int64}\n  first: Char 'a'\n  second: Int64 1\n```\n:::\n:::\n\n\n::: {#b217ab0a .cell execution_count=203}\n``` {.julia .cell-code}\n# From the output of dump(), we can easily see how to get values of a pair\n# This will generate a tuple by putting several values in one line by separating them with a comma\n# the functions first() and last() are versatile for ordered collections\np.first, p.second, first(p), last(p), p[1], p[2]\n```\n\n::: {.cell-output .cell-output-display execution_count=180}\n```\n('a', 1, 'a', 1, 'a', 1)\n```\n:::\n:::\n\n\n-   You can provide a list of pairs to create a dictionary:\n\n::: {#35ba7475 .cell execution_count=204}\n``` {.julia .cell-code}\nd = Dict('a' => 1, 'b' => 2, 'c' => 3)\n\ntypeof(d)\n```\n\n::: {.cell-output .cell-output-display execution_count=181}\n```\nDict{Char, Int64}\n```\n:::\n:::\n\n\n::: {#60f5583e .cell execution_count=205}\n``` {.julia .cell-code}\ndump(d)  # Checking the fields of a dictionary\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDict{Char, Int64}\n  slots: Array{UInt8}((16,)) UInt8[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf4, 0xad, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe3, 0x00]\n  keys: Array{Char}((16,))\n    1: Char '\\0'\n    2: Char '\\0'\n    3: Char '\\0'\n    4: Char '\\0'\n    5: Char '\\0'\n    ...\n    12: Char '\\0'\n    13: Char '\\0'\n    14: Char '\\0'\n    15: Char 'b'\n    16: Char '\\0'\n  vals: Array{Int64}((16,)) [2478498643202684469, 8751724873810518572, 7311705192714626416, 8099005258945295715, 7310315409782241644, 2466321564960910962, 2479642204066177401, 1, 3, 3475145254212088365, 3546363903228459569, 7598542776403373090, 3687943565983510127, 7598543875864669218, 2, 7220446003176039012]\n  ndel: Int64 0\n  count: Int64 3\n  age: UInt64 0x0000000000000003\n  idxfloor: Int64 8\n  maxprobe: Int64 1\n```\n:::\n:::\n\n\n-   Passing an array of pairs to the dictionary constructor:\n\n::: {#225c834a .cell execution_count=206}\n``` {.julia .cell-code}\na = ['a' => 1, 'b' => 2, 'c' => 3]\n\nDict(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=183}\n```\nDict{Char, Int64} with 3 entries:\n  'a' => 1\n  'c' => 3\n  'b' => 2\n```\n:::\n:::\n\n\n-   Passing an array of tuples containing only **two** elements to `Dict()`:\n\n::: {#2d627e34 .cell execution_count=207}\n``` {.julia .cell-code}\na = [('a' => 1), ('b' => 2), ('c' => 3)]\n\nDict(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=184}\n```\nDict{Char, Int64} with 3 entries:\n  'a' => 1\n  'c' => 3\n  'b' => 2\n```\n:::\n:::\n\n\n-   Creating an empty dictionary:\n\n::: {#fc0dbfa0 .cell execution_count=208}\n``` {.julia .cell-code}\nDict()\n```\n\n::: {.cell-output .cell-output-display execution_count=185}\n```\nDict{Any, Any}()\n```\n:::\n:::\n\n\n-   Creating an empty dictionary with given types of keys and values:\n\n::: {#b75c7a4e .cell execution_count=209}\n``` {.julia .cell-code}\nd = Dict{String, Int64}()\n```\n\n::: {.cell-output .cell-output-display execution_count=186}\n```\nDict{String, Int64}()\n```\n:::\n:::\n\n\nIn the above case, you must provide the keys and values with matched types as set above:\n\n::: {#726c1f06 .cell execution_count=210}\n``` {.julia .cell-code}\nd[\"a\"] = 1\n```\n\n::: {.cell-output .cell-output-display execution_count=187}\n```\n1\n```\n:::\n:::\n\n\n::: {#5e4f783e .cell execution_count=211}\n``` {.julia .cell-code}\nd['b'] = 2  # This will raise an error, because the type of 'b' is Char, not String\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>MethodError: Cannot `convert` an object of type <span class=\"ansi-bright-green-fg\">Char</span> to an object of type <span class=\"ansi-bright-red-fg\">String</span>\n\nClosest candidates are:\n  convert(::Type{String}, <span class=\"ansi-bright-red-fg\">::JuliaSyntax.Kind</span>)\n<span class=\"ansi-bright-black-fg\">   @</span> <span class=\"ansi-cyan-fg\">JuliaSyntax</span> <span class=\"ansi-bright-black-fg\">~/.julia/packages/JuliaSyntax/q0tWf/src/</span><span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">kinds.jl:975</span>\n  convert(::Type{String}, <span class=\"ansi-bright-red-fg\">::Base.JuliaSyntax.Kind</span>)\n<span class=\"ansi-bright-black-fg\">   @</span> <span class=\"ansi-bright-black-fg\">Base</span> <span class=\"ansi-bright-black-fg\">/cache/build/builder-amdci4-0/julialang/julia-release-1-dot-10/base/JuliaSyntax/src/</span><span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">kinds.jl:975</span>\n  convert(::Type{String}, <span class=\"ansi-bright-red-fg\">::String</span>)\n<span class=\"ansi-bright-black-fg\">   @</span> <span class=\"ansi-bright-black-fg\">Base</span> <span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">essentials.jl:321</span>\n  ...\n\n\nStacktrace:\n [1] setindex!(h::Dict{String, Int64}, v0::Int64, key0::Char)\n   @ Base ./dict.jl:367\n [2] top-level scope\n   @ In[188]:1</pre>\n```\n:::\n\n:::\n:::\n\n\n-   Creating a dictionary from two separate arrays zipped by `zip()` function:\n\n::: {#d9905d9b .cell execution_count=212}\n``` {.julia .cell-code}\nDict(zip('a':'c', 1:3))\n```\n\n::: {.cell-output .cell-output-display execution_count=189}\n```\nDict{Char, Int64} with 3 entries:\n  'a' => 1\n  'c' => 3\n  'b' => 2\n```\n:::\n:::\n\n\n::: callout-note\n`zip()` function can zip the corresponding values in a list of arrays into paired tuples, until any of them is exhausted.\n\n::: {#584ba684 .cell execution_count=213}\n``` {.julia .cell-code}\ncollect(zip('a':'c', 1:3, 'A':'C'))\n```\n\n::: {.cell-output .cell-output-display execution_count=190}\n```\n3-element Vector{Tuple{Char, Int64, Char}}:\n ('a', 1, 'A')\n ('b', 2, 'B')\n ('c', 3, 'C')\n```\n:::\n:::\n\n\n:::\n\n##### Accessing elements\n\n::: {#4f402a8b .cell execution_count=214}\n``` {.julia .cell-code}\nd = Dict(i => j for (i, j) in zip('A':'F', 'a':'f'))\n```\n\n::: {.cell-output .cell-output-display execution_count=191}\n```\nDict{Char, Char} with 6 entries:\n  'C' => 'c'\n  'D' => 'd'\n  'A' => 'a'\n  'E' => 'e'\n  'F' => 'f'\n  'B' => 'b'\n```\n:::\n:::\n\n\n-   By key:\n\n::: {#505f2cb3 .cell execution_count=215}\n``` {.julia .cell-code}\nd['F']\n```\n\n::: {.cell-output .cell-output-display execution_count=192}\n```\n'f': ASCII/Unicode U+0066 (category Ll: Letter, lowercase)\n```\n:::\n:::\n\n\n-By `get(dict, key, default)`: if the `key` is not in the `dict`, it will return the `default`, instead of raising an error.\n\n::: {#8051b50c .cell execution_count=216}\n``` {.julia .cell-code}\nget(d, 'Z', -1)  #\n```\n\n::: {.cell-output .cell-output-display execution_count=193}\n```\n-1\n```\n:::\n:::\n\n\n::: callout-note\nYou can use `keys()` and `values()` to get all keys and values, respectively.\n\nYou can check whether a dictionary contains a key by using `haskey(dict, key)`.\n:::\n\n#### Sets\n\n1.  Creating sets\n\n::: {#46c210f6 .cell execution_count=217}\n``` {.julia .cell-code}\nfruits = Set([\"apple\", \"banana\", \"peach\", \"pear\", \"orange\"])\n```\n\n::: {.cell-output .cell-output-display execution_count=194}\n```\nSet{String} with 5 elements:\n  \"peach\"\n  \"pear\"\n  \"orange\"\n  \"banana\"\n  \"apple\"\n```\n:::\n:::\n\n\n2.  Properties of sets\n\nThe set in Julia is the very set in mathematics.\n\nFor a given set S, the following hold:\n\n-   Each element x is either in S or not in S.\n\n-   Elements are unordered in S.\n\n-   There are no duplicate elements in S.\n\n3.  Set-specific operations\n\n-   Union: `∪` or `union()`.\n\n-   Intersection: `∩` or `intersect()`.\n\n-   Difference: `setdiff()`.\n\nCertainly, you can check whether an element belongs to a set or not (see @nte-memberoperator), as well as whether a set is a (proper) subset of the other (see @nte-subsetoperator).\n\n::: {#nte-subsetoperator .callout-note title=\"Subset operator `⊆`\"}\nYou can use `issubset()`, `⊆`, `⊇`, or `⊈` to judge the relationship between any two sets.\n:::\n\n#### Collection comprehension\n\nAn example in terms of an array: `[F(x, y, ...) for x = rx, y = ry, ...]`, where the latter `for` is nested within the former one, and generated values can be filtered using the `if` keyword.\n\n::: {#cf91d22f .cell execution_count=218}\n``` {.julia .cell-code}\n[i for i in 1:10 if i%2 == 0]\n```\n\n::: {.cell-output .cell-output-display execution_count=195}\n```\n5-element Vector{Int64}:\n  2\n  4\n  6\n  8\n 10\n```\n:::\n:::\n\n\n::: {#bf39a3c7 .cell execution_count=219}\n``` {.julia .cell-code}\n[(i, j, k) for (i, j, k) in zip('A':'F', 1:6, 'a':'f')]  # For (i, j, k), () is mandatory\n```\n\n::: {.cell-output .cell-output-display execution_count=196}\n```\n6-element Vector{Tuple{Char, Int64, Char}}:\n ('A', 1, 'a')\n ('B', 2, 'b')\n ('C', 3, 'c')\n ('D', 4, 'd')\n ('E', 5, 'e')\n ('F', 6, 'f')\n```\n:::\n:::\n\n\n::: {#a332509e .cell execution_count=220}\n``` {.julia .cell-code}\nDict('A'+i => i+1 for i in 0:10)\n```\n\n::: {.cell-output .cell-output-display execution_count=197}\n```\nDict{Char, Int64} with 11 entries:\n  'K' => 11\n  'J' => 10\n  'I' => 9\n  'H' => 8\n  'E' => 5\n  'B' => 2\n  'C' => 3\n  'D' => 4\n  'A' => 1\n  'G' => 7\n  'F' => 6\n```\n:::\n:::\n\n\n::: {#24cdcb48 .cell execution_count=221}\n``` {.julia .cell-code}\n[[j for j in 1:6] for i in 1:3]\n```\n\n::: {.cell-output .cell-output-display execution_count=198}\n```\n3-element Vector{Vector{Int64}}:\n [1, 2, 3, 4, 5, 6]\n [1, 2, 3, 4, 5, 6]\n [1, 2, 3, 4, 5, 6]\n```\n:::\n:::\n\n\nYou can specify the type of elements generated by prefixing with a wanted type:\n\n::: {#53d76d4b .cell execution_count=222}\n``` {.julia .cell-code}\nVector{Float64}[[j for j in 1:6] for i in 1:3]\n```\n\n::: {.cell-output .cell-output-display execution_count=199}\n```\n3-element Vector{Vector{Float64}}:\n [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]\n [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]\n [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]\n```\n:::\n:::\n\n\n#### Generator\n\nCollection comprehensions can also be written **without the enclosing brackets**, producing an object known as a generator.\n\n::: {#7ce4f1f4 .cell execution_count=223}\n``` {.julia .cell-code}\nsum(1/n^2 for n = 1:1000)\n```\n\n::: {.cell-output .cell-output-display execution_count=200}\n```\n1.6439345666815615\n```\n:::\n:::\n\n\n**Note:** when writing a generator expression **with multiple dimensions inside an argument list**, parentheses are needed to separate the generator from subsequent arguments.\n\n::: {#24b438f7 .cell execution_count=224}\n``` {.julia .cell-code}\nmap(tuple, (1/(i+j) for i=1:2, j=1:2), [1 3; 2 4])\n```\n\n::: {.cell-output .cell-output-display execution_count=201}\n```\n2×2 Matrix{Tuple{Float64, Int64}}:\n (0.5, 1)       (0.333333, 3)\n (0.333333, 2)  (0.25, 4)\n```\n:::\n:::\n\n\n**Generating a matrix:**\n\n::: {#886fe029 .cell execution_count=225}\n``` {.julia .cell-code}\n[100i + j for i=1:3, j=1:3]\n```\n\n::: {.cell-output .cell-output-display execution_count=202}\n```\n3×3 Matrix{Int64}:\n 101  102  103\n 201  202  203\n 301  302  303\n```\n:::\n:::\n\n\nThe above code is equivalent to:\n\n::: {#85c26357 .cell execution_count=226}\n``` {.julia .cell-code}\nA = zeros(Float64, 3, 3)\n\nfor i in 1:3\n    for j in 1:3\n        A[i,j] = 100i + j\n    end\nend\n\nA\n```\n\n::: {.cell-output .cell-output-display execution_count=203}\n```\n3×3 Matrix{Float64}:\n 101.0  102.0  103.0\n 201.0  202.0  203.0\n 301.0  302.0  303.0\n```\n:::\n:::\n\n\n#### Enumerating values and indices\n\n::: {#4576860e .cell execution_count=227}\n``` {.julia .cell-code}\ncollect(enumerate('A':'F'))\n```\n\n::: {.cell-output .cell-output-display execution_count=204}\n```\n6-element Vector{Tuple{Int64, Char}}:\n (1, 'A')\n (2, 'B')\n (3, 'C')\n (4, 'D')\n (5, 'E')\n (6, 'F')\n```\n:::\n:::\n\n\n::: {#b824488c .cell execution_count=228}\n``` {.julia .cell-code}\n[(i, val) for (i, val) in enumerate('A':'F')]\n```\n\n::: {.cell-output .cell-output-display execution_count=205}\n```\n6-element Vector{Tuple{Int64, Char}}:\n (1, 'A')\n (2, 'B')\n (3, 'C')\n (4, 'D')\n (5, 'E')\n (6, 'F')\n```\n:::\n:::\n\n\n#### Creating an `enum` type with `@enum` macro\n\n::: {#9c6d35a2 .cell execution_count=229}\n``` {.julia .cell-code}\n@enum Fruit apple peach pear banana orange\n\nFruit\n```\n\n::: {.cell-output .cell-output-display execution_count=206}\n```\nEnum Fruit:\napple = 0\npeach = 1\npear = 2\nbanana = 3\norange = 4\n```\n:::\n:::\n\n\n::: {#67217cc6 .cell execution_count=230}\n``` {.julia .cell-code}\nFruit(0), Fruit(3)  # Access by index\n```\n\n::: {.cell-output .cell-output-display execution_count=207}\n```\n(apple, banana)\n```\n:::\n:::\n\n\n::: {#43f9bf57 .cell execution_count=231}\n``` {.julia .cell-code}\ninstances(Fruit)  # Return all possible values\n```\n\n::: {.cell-output .cell-output-display execution_count=208}\n```\n(apple, peach, pear, banana, orange)\n```\n:::\n:::\n\n\n#### Understanding Julia collections\n\nTwo key questions:\n\n1.  What makes something a collection?\n\n2.  What are the differences and similarities between different collection types?\n\n##### What makes something a collection\n\nAt a minimum, you are expected to extend the `iterate()` function for your data type with the following methods to make your data type a collection:\n\n| Method                 | Purpose                                                                    |\n|------------------------------------|------------------------------------|\n| `iterate(iter)`        | Return the first item and the next state (e.g. the index of the next item) |\n| `iterate(iter, state)` | Return the current item and the next state                                 |\n\nAn index-based iteration example:\n\n1.  Define the `Cluster` type to be iterated:\n\n::: {#c50d5aa6 .cell execution_count=232}\n``` {.julia .cell-code}\n# Define the Engine type\nabstract type Engine end\n\n# Define valid engine models\nstruct Panda <: Engine\n    count::Integer\nend\nstruct Bear <: Engine\n    count::Integer\nend\nstruct Dog <: Engine\n    count::Integer\nend\n\n# Define the Cluster type, which can consist of many engine models\nstruct Cluster <: Engine\n    engines::Vector{Engine}  # A vector with elements of Engine type\nend\n```\n:::\n\n\n::: {#5fa4efd7 .cell execution_count=233}\n``` {.julia .cell-code}\nengine_type(::Panda) = \"Panda\"\nengine_type(::Bear) = \"Bear\"\nengine_type(::Dog) = \"Dog\"\n\nengine_count(engine::Union{Panda, Bear, Dog}) = engine.count\n```\n\n::: {.cell-output .cell-output-display execution_count=210}\n```\nengine_count (generic function with 1 method)\n```\n:::\n:::\n\n\n2.  Extend the `iterate()` function:\n\n::: {#7840dfc0 .cell execution_count=234}\n``` {.julia .cell-code}\nimport Base: iterate\n\n# Start the iteration\nfunction iterate(cluster::Cluster)\n    cluster.engines[1], 2  # Return the first element and the index of the next element\nend\n\n# Get the next element\nfunction iterate(cluster::Cluster, i::Integer)\n    if i > length(cluster.engines)\n        nothing  # Return nothing to indicate you reached the end\n    else\n        cluster.engines[i], i+1  # Don't forget to return the index of the next element\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=211}\n```\niterate (generic function with 488 methods)\n```\n:::\n:::\n\n\n3.  Iterate the `Cluster` instance:\n\n::: {#255e05f1 .cell execution_count=235}\n``` {.julia .cell-code}\ncluster = Cluster([Panda(1), Bear(5), Dog(10)])\n```\n\n::: {.cell-output .cell-output-display execution_count=212}\n```\nCluster(Engine[Panda(1), Bear(5), Dog(10)])\n```\n:::\n:::\n\n\n::: {#2045f3cf .cell execution_count=236}\n``` {.julia .cell-code}\nfor engine in cluster\n    println(engine_type(engine), \": \", engine_count(engine))\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPanda: 1\nBear: 5\nDog: 10\n```\n:::\n:::\n\n\nInternally, the Julia JIT compiler will convert this `for` loop into a lower-level `while` loop, which looks like the following code:\n\n::: {#5c717e4c .cell execution_count=237}\n``` {.julia .cell-code}\nnext = iterate(cluster)  # Begin iteration\nwhile next != nothing  # Check if you reached the end of the iteration\n    (engine, i) = next\n    println(engine_type(engine), \": \", engine_count(engine))\n    next = iterate(cluster, i)  # Advance to the next element\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPanda: 1\nBear: 5\nDog: 10\n```\n:::\n:::\n\n\nA linked list example:\n\n::: {#8f4d706c .cell execution_count=238}\n``` {.julia .cell-code}\nimport Base: iterate\n\nstruct MyLinkedList\n    id::Int\n    name::String\n    next::Union{MyLinkedList, Nothing}\nend\n\n# First, Julia uses the instance of MyLinkedList as the unique argument to retrieve the first element and the flag of the next element\niterate(first::MyLinkedList) = ((first.id, first.name), first.next)  # The first value is what you want to retrieve; the second value is used to tell where the next element is\n# Then, Julia uses the instance of MyLinkedList and the flag of the next element, returned by the previous one to retrieve the next element and the flag of the next element, in contrast with the current one\niterate(prev::MyLinkedList, current::MyLinkedList) = ((current.id, current.name), current.next)\n# Finally, iteration-supported function needs a nothing to indicate that the iteration is done\niterate(::MyLinkedList, ::Nothing) = nothing  # Return nothing if the iteration is done\n\nx = MyLinkedList(1, \"1st\", MyLinkedList(2, \"2nd\", MyLinkedList(3, \"3rd\", nothing)))\n\nfor (id, name) in x  # The parentheses are essential\n    println(id, \": \", name)\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1: 1st\n2: 2nd\n3: 3rd\n```\n:::\n:::\n\n\n::: callout-caution\nFor multiple assignment, parentheses are mandatory in `for` loop; otherwise it's trivial.\n:::\n\nA similar `while` counterpart of `for`:\n\n::: {#06c37b5b .cell execution_count=239}\n``` {.julia .cell-code}\nnext = iterate(x)\nwhile next != nothing\n    current, next = next\n    println(current[1], \": \", current[2])\n    next = iterate(x, next)\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1: 1st\n2: 2nd\n3: 3rd\n```\n:::\n:::\n\n\n4.  Adding support for `map()` and `collect()`\n\nIf you run `collect()` on x, you will get the following error:\n\n::: {#0aacc410 .cell execution_count=240}\n``` {.julia .cell-code}\ncollect(x)\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>MethodError: no method matching length(::MyLinkedList)\n\nClosest candidates are:\n  length(<span class=\"ansi-bright-red-fg\">::Automa.ByteSet</span>)\n<span class=\"ansi-bright-black-fg\">   @</span> <span class=\"ansi-yellow-fg\">Automa</span> <span class=\"ansi-bright-black-fg\">~/.julia/packages/Automa/Aq8Mq/src/</span><span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">byteset.jl:7</span>\n  length(<span class=\"ansi-bright-red-fg\">::Tables.DictRowTable</span>)\n<span class=\"ansi-bright-black-fg\">   @</span> <span class=\"ansi-magenta-fg\">Tables</span> <span class=\"ansi-bright-black-fg\">~/.julia/packages/Tables/8p03y/src/</span><span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">dicts.jl:118</span>\n  length(<span class=\"ansi-bright-red-fg\">::Core.Compiler.InstructionStream</span>)\n<span class=\"ansi-bright-black-fg\">   @</span> <span class=\"ansi-bright-black-fg\">Base</span> <span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">show.jl:2777</span>\n  ...\n\n\nStacktrace:\n [1] _similar_shape(itr::MyLinkedList, ::Base.HasLength)\n   @ Base ./array.jl:710\n [2] _collect(cont::UnitRange{Int64}, itr::MyLinkedList, ::Base.HasEltype, isz::Base.HasLength)\n   @ Base ./array.jl:765\n [3] collect(itr::MyLinkedList)\n   @ Base ./array.jl:759\n [4] top-level scope\n   @ In[217]:2</pre>\n```\n:::\n\n:::\n:::\n\n\nOf course, you can simply define a `length()` method for `MyLinkedList` type like the following:\n\n::: {#4bfb5ca8 .cell execution_count=241}\n``` {.julia .cell-code}\nimport Base: length\n\nlength(::Nothing) = 0\nlength(x::MyLinkedList) = 1 + length(x.next)\n\nlength(x)\n```\n\n::: {.cell-output .cell-output-display execution_count=218}\n```\n3\n```\n:::\n:::\n\n\nHowever, the time it takes to calculate the length of `MyLinkedList` is proportional to its length. Such algorithms are referred to as **linear** or $O(n)$ in big-O notation.\n\nInstead, we will implement an `IteratorSize()` method:\n\n::: {#0c4dc11d .cell execution_count=242}\n``` {.julia .cell-code}\nimport Base: IteratorSize\n\nIteratorSize(::Type{MyLinkedList}) = Base.SizeUnknown()\n```\n\n::: {.cell-output .cell-output-display execution_count=219}\n```\nIteratorSize\n```\n:::\n:::\n\n\nBy default, `IteratorSize()` is defined like the following:\n\n::: {#6564400c .cell execution_count=243}\n``` {.julia .cell-code}\nIteratorSize(x) = IteratorSize(typeof(x))\nIteratorSize(::Type) = HasLength()\n```\n:::\n\n\n::: callout-note\nHere, `IteratorSize()` is a **trait** of Julia collections. It is used to indicate whether a collection has a known length.\n\n**In Julia, traits are defined as abstract types. The values a trait can have are determined by a concrete subtype.**\n\nFor example, the trait `IteratorSize()` has subtypes `SizeUnknown()`, `HasLength()`, and so on.\n\nIf the `IteratorSize()` trait is defined as `HasLength()`, then Julia will call `length()` to determine the size of the result array produced from `collect()`. Instead, when you define this trait as `SizeUnknown()`, Julia will use an empty array for output that grows as needed.\n:::\n\n::: callout-note\n\n::: {#518715b8 .cell execution_count=244}\n``` {.julia .cell-code}\nfoo(::Type{Integer}) = 'A'  # Only accepting the type Integer as a valid argument\n\nfoo(Integer)\n```\n\n::: {.cell-output .cell-output-display execution_count=220}\n```\n'A': ASCII/Unicode U+0041 (category Lu: Letter, uppercase)\n```\n:::\n:::\n\n\n::: {#804a8fe8 .cell execution_count=245}\n``` {.julia .cell-code}\nfoo(Int64)\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>MethodError: no method matching foo(::Type{Int64})\n\nClosest candidates are:\n  foo(<span class=\"ansi-bright-red-fg\">::Int64</span>)\n<span class=\"ansi-bright-black-fg\">   @</span> <span class=\"ansi-magenta-fg\">Main</span> <span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">In[23]:1</span>\n  foo(<span class=\"ansi-bright-red-fg\">::Type{Integer}</span>)\n<span class=\"ansi-bright-black-fg\">   @</span> <span class=\"ansi-magenta-fg\">Main</span> <span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">In[220]:1</span>\n\n\nStacktrace:\n [1] top-level scope\n   @ In[221]:2</pre>\n```\n:::\n\n:::\n:::\n\n\n::: {#9edf2179 .cell execution_count=246}\n``` {.julia .cell-code}\nfb(::Type{<:Integer}) = 'B'  # Integer as well as its all subtypes are valid arguments\n\nfb(Integer)\n```\n\n::: {.cell-output .cell-output-display execution_count=222}\n```\n'B': ASCII/Unicode U+0042 (category Lu: Letter, uppercase)\n```\n:::\n:::\n\n\n::: {#56c98ff3 .cell execution_count=247}\n``` {.julia .cell-code}\nfb(Int64)\n```\n\n::: {.cell-output .cell-output-display execution_count=223}\n```\n'B': ASCII/Unicode U+0042 (category Lu: Letter, uppercase)\n```\n:::\n:::\n\n\n:::\n\n5.  Adding more interfaces to your data type\n\nTo make your data type more versatile, you may add more interfaces to your data type.\n\nFor example, as a collection, your data type should support getting, setting, adding, and removing elements, which are achieved by the following methods:\n\n-   `getindex()`: this makes it possible to access elements with `[]`.\n\n-   `setindex!()`: this makes it possible to set elements with `[]`.\n\n-   `push!()`: adding elements to the back of a collection.\n\n-   `pushfirst!()`: adding elements to the front of a collection.\n\n-   `pop!()`: removing the last element.\n\n-   `popfirst!()`: removing the first element.\n\nIn a word, some interfaces to a collection are achieved by implicitly calling some methods by Julia itself (e.g. looping a collection); some other interfaces to a collection are achieved by explicitly calling some methods by users (e.g. adding elements).\n\n### Functional programming\n\n#### Higher order functions\n\nThese are funtions that take other functions as arguments and/or return functions.\n\n1.  `map(f, iterable)`: apply `f` to each element of `iterable`.\n\n::: {#ff31c8c4 .cell execution_count=248}\n``` {.julia .cell-code}\nmap(uppercase, 'a':'z')\n```\n\n::: {.cell-output .cell-output-display execution_count=224}\n```\n26-element Vector{Char}:\n 'A': ASCII/Unicode U+0041 (category Lu: Letter, uppercase)\n 'B': ASCII/Unicode U+0042 (category Lu: Letter, uppercase)\n 'C': ASCII/Unicode U+0043 (category Lu: Letter, uppercase)\n 'D': ASCII/Unicode U+0044 (category Lu: Letter, uppercase)\n 'E': ASCII/Unicode U+0045 (category Lu: Letter, uppercase)\n 'F': ASCII/Unicode U+0046 (category Lu: Letter, uppercase)\n 'G': ASCII/Unicode U+0047 (category Lu: Letter, uppercase)\n 'H': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)\n 'I': ASCII/Unicode U+0049 (category Lu: Letter, uppercase)\n 'J': ASCII/Unicode U+004A (category Lu: Letter, uppercase)\n 'K': ASCII/Unicode U+004B (category Lu: Letter, uppercase)\n 'L': ASCII/Unicode U+004C (category Lu: Letter, uppercase)\n 'M': ASCII/Unicode U+004D (category Lu: Letter, uppercase)\n 'N': ASCII/Unicode U+004E (category Lu: Letter, uppercase)\n 'O': ASCII/Unicode U+004F (category Lu: Letter, uppercase)\n 'P': ASCII/Unicode U+0050 (category Lu: Letter, uppercase)\n 'Q': ASCII/Unicode U+0051 (category Lu: Letter, uppercase)\n 'R': ASCII/Unicode U+0052 (category Lu: Letter, uppercase)\n 'S': ASCII/Unicode U+0053 (category Lu: Letter, uppercase)\n 'T': ASCII/Unicode U+0054 (category Lu: Letter, uppercase)\n 'U': ASCII/Unicode U+0055 (category Lu: Letter, uppercase)\n 'V': ASCII/Unicode U+0056 (category Lu: Letter, uppercase)\n 'W': ASCII/Unicode U+0057 (category Lu: Letter, uppercase)\n 'X': ASCII/Unicode U+0058 (category Lu: Letter, uppercase)\n 'Y': ASCII/Unicode U+0059 (category Lu: Letter, uppercase)\n 'Z': ASCII/Unicode U+005A (category Lu: Letter, uppercase)\n```\n:::\n:::\n\n\n2.  `reduce(f, iterable)`: apply `f` to the element of `iterable` in an iterable way.\n\n::: {#b77bb1f2 .cell execution_count=249}\n``` {.julia .cell-code}\nreduce(+, 1:100)\n```\n\n::: {.cell-output .cell-output-display execution_count=225}\n```\n5050\n```\n:::\n:::\n\n\n3.  `filter(predicate, iterable)`: return a subset of `iterable` based on `predicate`.\n\nNote: a `predicate` is a function that takes an element of `iterable` and always returns a Boolean value.\n\n::: {#b8abc867 .cell execution_count=250}\n``` {.julia .cell-code}\nfilter(isuppercase, ['A', 'b', 'C', 'd'])\n```\n\n::: {.cell-output .cell-output-display execution_count=226}\n```\n2-element Vector{Char}:\n 'A': ASCII/Unicode U+0041 (category Lu: Letter, uppercase)\n 'C': ASCII/Unicode U+0043 (category Lu: Letter, uppercase)\n```\n:::\n:::\n\n\n### I/O (Networking and Streams)\n\n#### I/O types\n\nThe Julia I/O system is centered on the abstract type `IO`, which has several concrete types, such as `IOStream`, `IOBuffer`, `Process` and `TCPSocket`. Each type allows you to read and write data from different I/O devices, such as files, in-memory buffers, running processes, or network connections.\n\n#### Stream I/O\n\nAll Julia streams expose at least a `read()` and a `write()` method, taking the stream as their first argument.\n\nThe `write()` method operates on binary streams, which means that values do not get converted to any canonical text representation but are written out as is.\n\n`write()` takes the data to write as its second argument:\n\n::: {#b7a3866d .cell execution_count=251}\n``` {.julia .cell-code}\nwrite(stdout, \"Hello World\")  # return 11, the number of bytes written to stdout\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello World\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=227}\n```\n11\n```\n:::\n:::\n\n\n::: {#8ece3002 .cell execution_count=252}\n``` {.julia .cell-code}\nwrite(stdout, \"Hello World\");  # supress return value 11 with ;\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello World\n```\n:::\n:::\n\n\n`read()` takes the type of data to be read as its second argument:\n\n::: {#23ce09e9 .cell execution_count=253}\n``` {.julia .cell-code}\njulia> read(stdin, Char)\nA\n# 'A': ASCII/Unicode U+0041 (category Lu: Letter, uppercase)\n```\n:::\n\n\nTo read a simple byte array:\n\n::: {#2601e8cf .cell execution_count=254}\n``` {.julia .cell-code}\njulia> x = zeros(UInt8, 6)\n# 6-element Vector{UInt8}:\n#  0x00\n#  0x00\n#  0x00\n#  0x00\n#  0x00\n#  0x00\n\njulia> read!(stdin, x)  # read from stdin and store them in x\nabcdef\n# 6-element Vector{UInt8}:\n#  0x61\n#  0x62\n#  0x63\n#  0x64\n#  0x65\n#  0x66\n\njulia> x\n# 6-element Vector{UInt8}:\n#  0x61\n#  0x62\n#  0x63\n#  0x64\n#  0x65\n#  0x66\n```\n:::\n\n\nThe above is equivalent to:\n\n::: {#9431e36f .cell execution_count=255}\n``` {.julia .cell-code}\njulia> x = read(stdin, 6)\nabcdef\n# 6-element Vector{UInt8}:\n#  0x61\n#  0x62\n#  0x63\n#  0x64\n#  0x65\n#  0x66\n\njulia> x\n# 6-element Vector{UInt8}:\n#  0x61\n#  0x62\n#  0x63\n#  0x64\n#  0x65\n#  0x66\n```\n:::\n\n\nTo read the entire line:\n\n::: {#3a72eec7 .cell execution_count=256}\n``` {.julia .cell-code}\njulia> readline(stdin)\n1234567890\n# \"1234567890\"\n```\n:::\n\n\nTo read all lines of an I/O stream or a file as a vector of strings using `redalines(io)`.\n\nTo read every line from `stdin` you can use `eachline(io)`:\n\n::: {#100c2a4d .cell execution_count=257}\n``` {.julia .cell-code}\n# you can use Ctrl + D to terminate the input (play the role of EOF) \njulia> for line in eachline(stdin)\n           println(\"Found $line\")\n       end\n123456\n# Found 123456\nabcdef\n# Found abcdef\n```\n:::\n\n\nRead by character:\n\n::: {#0fd5d4ec .cell execution_count=258}\n``` {.julia .cell-code}\njulia> while !eof(stdin)\n       x = read(stdin, Char)\n       println(\"Found: $x\")\n       end\nabcdef\n# Found: a\n# Found: b\n# Found: c\n# Found: d\n# Found: e\n# Found: f\n```\n:::\n\n\n#### Text I/O\n\nFor text I/O, using the `print()` or `show()` methods, taking the stream as their first argument, which is a mandatory convention.\n\n`print()` is used to write a canonical text representation of a value to the output stream. If a canonical text representation exists for the value, it is printed without any adornments. If no canonical text representation exists, `print()` calls the `show()` function to display the value.\n\n`print()` is more about customizing the output for specific messages, while `show()` is about displaying complex objects in a readable format. The choice between `print()` and `show()` depends on the context and the desired output format. For simple text output, `print()` is often sufficient, but for displaying the structure and content of complex objects, `show()` is the preferred choice.\n\nFor custom pretty-printing of your own types, define `show()` (which calls `print()` to customize the output content and style of your own type) instead of `print()` for it.\n\nOf course, for more pretty-printing, Julia also provides functions such as `println()` (with trailing newline), `printstyled()` (support some rich displays, such as colors), etc.\n\n#### I/O output contextual properties\n\nSometimes I/O output can benefit from the ability to pass contextual information into show methods. The `IOContext` object provides this framework for associating arbitrary metadata with an I/O object.\n\n#### Working with files\n\n::: {#ef87e9c0 .cell execution_count=259}\n``` {.julia .cell-code}\n# 1. Write content to a file with the write(filename::String, content) method\n# 2. Read the contents of a file with the read(filename::String) method, or read(filename::String, String) to the contents as a string\njulia> write(\"hello.txt\", \"Hello, World!\")  # return the number of bytes written\n# 13\n\njulia> read(\"hello.txt\")  # return bytes\n# 13-element Vector{UInt8}:\n#  0x48\n#  0x65\n#  0x6c\n#  0x6c\n#  0x6f\n#  0x2c\n#  0x20\n#  0x57\n#  0x6f\n#  0x72\n#  0x6c\n#  0x64\n#  0x21\n\njulia> read(\"hello.txt\", String)  # return the contents as a string\n# \"Hello, World!\"\n```\n:::\n\n\nInstead of directly passing a string as the file name, you can first open a file with `open(filename::AbstractString, [mode::AbstractString]; lock = true) -> IOStream`, which returns an `IOStream` object that you can use to read/write things from/to the file.\n\n::: {#960ba877 .cell execution_count=260}\n``` {.julia .cell-code}\njulia> f = open(\"hello.txt\")  # open a file\n# IOStream(<file hello.txt>)\n\njulia> readlines(f)  # do something (read/write)\n# 1-element Vector{String}:\n#  \"Hello, World!\"\n\njulia> close(f)  # close the file\n```\n:::\n\n\nInstead of closing the file manually, you can pass a function (accepting the `IOStream` returned by `open()` as its first argument) as the first argument of `open()` method, which will close the file upon completion for you.\n\n::: {#758af651 .cell execution_count=261}\n``` {.julia .cell-code}\njulia> open(\"hello.txt\") do io\n       uppercase(read(io, String))\n       end\n# \"HELLO, WORLD!\"\n```\n:::\n\n\n#### Working with networking\n\n![A rough scheme of five network layers](./figures/scheme_of_five_network_layers.png){.lightbox fig-alt=\"Click to see a larger version of the image\" fig-align=\"center\"}\n\n##### TCP (Transmission Control Protocol)\n\nIn a word, TCP provides highly reliable data transmission services with these features: connection-oriented, reliable, flow control, congestion control, error checking, slower than UDP due to providing such features.\n\n::: {#90f4aa5e .cell execution_count=262}\n``` {.julia .cell-code}\nusing Sockets\n\n## server side\nerrormonitor(@async begin\n        server = listen(2000)  # 1. listen on a given port on a specified address; create a server waiting for incoming connections on the specified port 2000 in this case; a TCPServer socket is returned; in computer networking, a socket is a software structure that provides a bidirectional communication channel between two processes, where one process acts as a server and the other as a client\n        while true\n            sock = accept(server)  # 2. retrieve a connection to the client that is trying to connect to the server we just created\n            @async while isopen(sock)  # 3. if connected, do something between the server and the client\n                write(sock, string(\"The server has received the message from the client: \", readline(sock, keep = true)))  # 4. read something from the client and then write something to the client; keep = true means that these trailing newline characters are also returned (instead of removing them from the line before it is returned) as part of the line\n            end\n        end\nend)\n\n## client side\nclient = connect(2000)  # 1. connect to a host on a given port; return a TCPSocket socket\n\nerrormonitor(@async while isopen(client)  # 2. if connected, do something\n    write(stdout, readline(client, keep = true))  # 3. read something from the server and then print them to the termimal (stdout)\nend)\n\nprintln(client, \"Hello world from the client\")  # 3. write something to the server\n# The server has received the message from the client: Hello world from the client\n\n## finally, use close() to disconnect the socket\nclose(client)\n```\n:::\n\n\n**Note:** some details about `listen()` and `connect()`:\n\n::: {#5fa545ee .cell execution_count=263}\n``` {.julia .cell-code}\n## 1. connect([host], port::Integer) -> TCPSocket  #  Connect to the host `host` on port `port` (TCPServer)\nlisten(2000)  # listen on localhost:2000 (IPv4)\nlisten(ip\"127.0.0.1\", 2000)  # equivalent to the above (IPv4)\nlisten(ip\"::1\", 2000)  # equivalent to the above (IPv6)\nlisten(IPv4(0), 2000)  # listen on port 2000 on all IPv4 interfaces\nlisten(IPv6(0), 2000)  # listen on port 2000 on all IPv6 interfaces\n\n## 2. connect(path::AbstractString) -> PipeEndpoint  # connect to the named pipe (Windows) / UNIX domain socket at `path` (PipeServer)\nlisten(\"testsocket\")  # listen on a UNIX domain socket\nlisten(\"\\\\\\\\.\\\\pipe\\\\testsocket\")  # listen on a Windows named pipe (\\\\.\\pipe\\)\n```\n:::\n\n\nThe difference between TCP and named pipes or UNIX domain sockets is subtle and has to do with the `accept()` and `connect()` methods:\n\n::: {#bed77128 .cell execution_count=264}\n``` {.julia .cell-code}\naccept(server[, client])  # Accepts a connection on the given server and returns a connection to the client. An uninitialized client stream may be provided, in which case it will be used instead of creating a new stream.\n\nconnect([host], port::Integer) -> TCPSocket  # Connect to the host `host` on port `port`.\nconnect(path::AbstractString) -> PipeEndpoint  # Connect to the named pipe / UNIX domain socket at path.\n```\n:::\n\n\n**Resolving IP addresses:**\n\n::: {#bc6f8506 .cell execution_count=265}\n``` {.julia .cell-code}\njulia> getaddrinfo(\"google.com\")\n# ip\"59.24.3.174\"\n```\n:::\n\n\n##### UDP (User Datagram Protocol)\n\nUDP provides no such features as provided by TCP.\n\nA common use for UDP is in multicast applications.\n\n::: {#5e50723d .cell execution_count=266}\n``` {.julia .cell-code}\n## receiver\nusing Sockets\n\ngroup = ip\"226.6.8.8\"  # Choose a valid IP address for multicast: for IPv4, the multicast address range is from 224.0.0.0 to 239.255.255.255. Any address within this range is designated for multicast use. For IPv6, the multicast range begins with ff, such as ff05::5:6:7.\nsocket = UDPSocket()  # Open a UDP socket.\nbind(socket, ip\"0.0.0.0\", 6688)  # Bind socket to the given host:port. Note that 0.0.0.0 (IPv4) / :: (IPv6) will listen on all devices (listen on all available network interfaces and all IPv4 / IPv6 addresses associated with the host machine. When binding to a port, make sure that the port number is not in use by another application and that it's not a well-known or registered port that has a specific protocol associated with it.\njoin_multicast_group(socket, group)  # Join a socket to a particular multicast group.\nprintln(String(recv(socket)))  # For recv():  read a UDP packet from the specified socket, and return the bytes received. This call blocks.\n# Hello over IPv4\nleave_multicast_group(socket, group)  #  Remove a socket from a particular multicast group.\nclose(socket)  # Close the socket.\n\n## sender\nusing Sockets\n\ngroup = ip\"226.6.8.8\"\nsocket = UDPSocket()\nsend(socket, group, 6688, \"Hello over IPv4\")  #  Send msg over socket to host:port. It is not necessary for a sender to join the multicast group.\nclose(socket)\n```\n:::\n\n\n### Parametric types\n\nYou can think of the expression `S=P{T}` as **parametric type `P`** taking a **type parameter `T`** and returning a new **concrete type `S`**. Both `T` and `S` are concrete types, while `P` is just a template for making types.\n\n#### Defining parametric methods\n\n::: {#e6dde5f3 .cell execution_count=267}\n``` {.julia .cell-code}\nfunction linearsearch(haystack::AbstractVector{T}, needle::T) where T\n    for (i, x) in enumerate(haystack)\n        if needle == x\n            return i\n        end\n    end\nend\n\nlinearsearch([1, 4, 6, 8], 6)\n```\n\n::: {.cell-output .cell-output-display execution_count=229}\n```\n3\n```\n:::\n:::\n\n\n::: {#12f7ad87 .cell execution_count=268}\n``` {.julia .cell-code}\nlinearsearch([1, 4, 6, 8], \"six\")\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>MethodError: no method matching linearsearch(::Vector{Int64}, ::String)\n\nClosest candidates are:\n  linearsearch(::AbstractVector{T}, <span class=\"ansi-bright-red-fg\">::T</span>) where T\n<span class=\"ansi-bright-black-fg\">   @</span> <span class=\"ansi-magenta-fg\">Main</span> <span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">In[229]:1</span>\n\n\nStacktrace:\n [1] top-level scope\n   @ In[230]:2</pre>\n```\n:::\n\n:::\n:::\n\n\nIn this example, the `linearsearch()` is a parametric method, which takes a type parameter `T`, defined in the `where T` clause. You can define more than one type parameter in the `where` clause (e.g. `where {T, S}`).\n\n#### Defining parametric types\n\n::: {#f30f364d .cell execution_count=269}\n``` {.julia .cell-code}\n\"A point at coordinate (x, y)\"\nstruct Point{T}\n    x::T\n    y::T\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=231}\n```\nPoint\n```\n:::\n:::\n\n\nYou can impose constraints on the type parameter `T` with subtype operator `<:`:\n\n::: {#e14ef272 .cell execution_count=270}\n``` {.julia .cell-code}\nstruct RPoint{T<:Number}\n    x::T\n    y::T\nend\n```\n:::\n\n\nWhen creating a point with `Point`, you can let Julia to infer the type parameter from arguments or explicitly set the type parameter:\n\n::: {#4ec0bf52 .cell execution_count=271}\n``` {.julia .cell-code}\nPoint(1, 2), Point{Int}(3, 4)\n```\n\n::: {.cell-output .cell-output-display execution_count=233}\n```\n(Point{Int64}(1, 2), Point{Int64}(3, 4))\n```\n:::\n:::\n\n\nIn fact, `sum(xs::Vector)` is the same as `sum(xs::Vector{T}) where T`.\n\nIn summary, parametric types can improve the **type safety** (stricter type checking), **performance** (more type restrictions, less type-related jobs), and **memory usage** (more type restrictions, more precise assignment of memory).\n\n### Scope of variables\n\n#### Introduction\n\nThe scope of a variable is the region of code within which a variable is accessible. Variable scoping helps avoid variable naming conflicts.\n\nThere are two main types of scopes in programming languages: **lexical scope** (also called static scope) and **dynamic scope**.\n\nIn languages with **lexical scope**, the name resolution depends on the location in the source code and the lexical context, where the named variable is defined. In contrast, in languages with **dynamic scope**, the name resolution depends on the program state and the runtime context when the name is encountered.\n\nIn a word, with **lexical scope** a name is resolved by searching the local lexical context, then if that fails, by searching the outer lexical context, and so on; with **dynamic scope**, a name is resolved by searching the local execution context, then if that fails, by searching the outer execution context, and so on, progressing up the call stack.\n\nJulia uses lexical scope. Further, there are two main types of scopes in Julia, **global scope** and **local scope**. The latter can be nested.\n\nIn Julia, different constructs may introduce different types of scopes.\n\n#### Scope constructs\n\nThe constructs introducing scopes are:\n\n| Construct                                                    | Scope type | Allowed within |\n|------------------------|------------------------|------------------------|\n| module, baremodule                                           | global     | global         |\n| struct                                                       | soft local | global         |\n| for, while, try                                              | soft local | global, local  |\n| macro                                                        | hard local | global         |\n| functions, do blocks, let blocks, comprehensions, generators | hard local | global, local  |\n\n**Note:** **begin blocks** and **if blocks** do not introduce scopes.\n\n#### Global scope\n\nEach module introduces a global scope.\n\nModules can introduce variables of other modules into their scopes through the `using` or `import` statement, or through qualified access using the dot notation.\n\n::: {#11a376db .cell execution_count=272}\n``` {.julia .cell-code}\nmodule A\n    a = 1  # a is a global variable in A's scope\nend\n\nmodule B\n    module C\n        c = 2\n    end\n    b = C.c  # can access the namespace of a nested global scope through a qualified access\n\n    import ..A  # makes module A available\n    d = A.a\nend\n```\n:::\n\n\nIf a top-level expression (e.g. a `begin` or `if` block) contains a variable declared with keyword `local`, then that variable is not accessible outside that expression.\n\n::: {#1b879f64 .cell execution_count=273}\n``` {.julia .cell-code}\nx = 1\nbegin\n    local x = 0\n    @show x\nend\n@show x\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx = 0\nx = 1\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=234}\n```\n1\n```\n:::\n:::\n\n\n**Note:** the REPL is in the global scope of the module `Main`.\n\n#### Local scope\n\nA local scope nested inside another local/global scope can see variables in all the outer scopes in which it is contained. Outer scopes, on the other hand, cannot see variables in inner scopes.\n\nWhen `x = <value>` occurs in a local scope, Julia will apply the following rules to decide what the expression means:\n\n1.  **Existing local**: if `x` is already a local variable, then the existing local `x` is assigned.\n\n2.  **Hard scope**: if x is not already a local variable and this assignment occurs inside of any hard scope construct, then a new local variable named `x` is created in the scope of the assignment.\n\n3.  **Soft scope**: if x is not already a local variable and all of the scope constructs containing the assignment are soft scopes, the behavior depends on whether the global variable `x` is defined:\n\n    -   If global `x` is undefined, a new local variable named `x` is created in the scope of the assignment;\n\n    -   If global `x` is defined, then the following rules are applied:\n\n        -   In interactive mode, the global variable `x` is assigned;\n\n        -   In non-interactive mode, an ambiguity warning is printed and a new local variable named `x` is created in the scope of the assignment.\n\nTherefore, in non-interactive mode, the soft scope and hard scope behaves identically except that a warning is printed when an implicitly local variable shadows a global variable in the soft scope.\n\n**Note:** in Julia, a variable cannot be a non-local variable, meaning that it is either a local variable or a global variable, **which is determined regardless of the order of expressions**. As a consequence, if you assign to an existing local, it always updates that existing local; therefore, you can only shadow a local by explicitly declaring a new local in a nested scope with the `local` keyword.\n\n::: {#6a027bea .cell execution_count=274}\n``` {.julia .cell-code}\nfunction outer_foo()\n    x = 99  # x is a local variable in the outer_foo's scope\n    @show x\n    let\n        x = 100  # updates the local variable x defined in the outer_foo's scope\n    end\n    @show x\n    return nothing\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=235}\n```\nouter_foo (generic function with 1 method)\n```\n:::\n:::\n\n\n::: {#3c8d1766 .cell execution_count=275}\n``` {.julia .cell-code}\ncode = \"\"\"\ns = 0 # global\nfor i = 1:10\n    t = s + i # new local t\n    s = t # new local s with warning\nend\ns, # global; should be 0\n@isdefined(t) # global; should be false\n\"\"\";\n\ninclude_string(Main, code)\n```\n\n::: {.cell-output .cell-output-error}\n```\nLoadError: LoadError: UndefVarError: `s` not defined\nin expression starting at string:2\nLoadError: UndefVarError: `s` not defined\nin expression starting at string:2\n\nStacktrace:\n [1] top-level scope\n   @ ./string:3\n [2] eval\n   @ ./boot.jl:385 [inlined]\n [3] include_string(mapexpr::typeof(identity), mod::Module, code::String, filename::String)\n   @ Base ./loading.jl:2076\n [4] include_string\n   @ ./loading.jl:2086 [inlined]\n [5] include_string(m::Module, txt::String)\n   @ Base ./loading.jl:2086\n [6] top-level scope\n   @ In[236]:12\n```\n:::\n:::\n\n\n::: callout-caution\nSo don't forget to use the `global` keyword to declare a variable `x` if you want to use a global `x` instead of a local `x` in seeing a `for` loop in non-interactive mode:\n\n::: {#60524ef8 .cell execution_count=276}\n``` {.julia .cell-code}\ncode = \"\"\"\ns = 0\nfor i in 1:100\n    global s = s + i\nend\n@show s\n\"\"\"\n\ninclude_string(Main, code)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ns = 5050\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=237}\n```\n5050\n```\n:::\n:::\n\n\n:::\n\n#### `let` blocks\n\n`let` blocks create a new hard local scope and **introduce new variable bindings each time they run**. The variable need not be immediately assigned. The value evaluated from the last expression is returned.\n\n::: {#1cdf40d3 .cell execution_count=277}\n``` {.julia .cell-code}\nlet x  # x need not be immediately assigned\n    x = 1\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=238}\n```\n1\n```\n:::\n:::\n\n\nThe `let` syntax accepts a comma-separated series of assignments and variable names.\n\n::: {#b7042e51 .cell execution_count=278}\n``` {.julia .cell-code}\nx, y = 1, 2\n\nlet x = x, y = 20\n    @show x, y\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(x, y) = (1, 20)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=239}\n```\n(1, 20)\n```\n:::\n:::\n\n\n**Note:** in the above example, `x = x` is possible, since the assignment is evaluated from the right to the left. `x` in the right-hand side is global; `x` in the left-hand side is local.\n\n#### Loops\n\nA `for` loop iteration variable is always a new local variable; otherwise you declare it using the `outer` keyword.\n\n::: {#d725cad8 .cell execution_count=279}\n``` {.julia .cell-code}\nfunction for_f1()\n    i = 0\n    for i = 1:3  # i is local\n    end\n    return i\nend\n\nfor_f1()\n```\n\n::: {.cell-output .cell-output-display execution_count=240}\n```\n0\n```\n:::\n:::\n\n\n::: {#5ac6e88b .cell execution_count=280}\n``` {.julia .cell-code}\nfunction for_f2()\n    i = 0\n    for outer i = 1:3  # i is global\n    end\n    return i\nend\n\nfor_f2()\n```\n\n::: {.cell-output .cell-output-display execution_count=241}\n```\n3\n```\n:::\n:::\n\n\nA noteworthy fact is that you must declare `i` using the `global` keyword in the following code or an error will be raised when you run it in non-interactive mode:\n\n::: {#1784f2fc .cell execution_count=281}\n``` {.julia .cell-code}\ncode = \"\"\"\n    i = 10\n    while i <= 12\n        i = i + 1  # i is regarded as a local instead of a global since this is determined regardless of the order of expressions\n        @show i\n    end\n    @show i\n\"\"\"\n\ninclude_string(Main, code)\n```\n\n::: {.cell-output .cell-output-error}\n```\nLoadError: LoadError: UndefVarError: `i` not defined\nin expression starting at string:2\nLoadError: UndefVarError: `i` not defined\nin expression starting at string:2\n\nStacktrace:\n [1] top-level scope\n   @ ./string:3\n [2] eval\n   @ ./boot.jl:385 [inlined]\n [3] include_string(mapexpr::typeof(identity), mod::Module, code::String, filename::String)\n   @ Base ./loading.jl:2076\n [4] include_string\n   @ ./loading.jl:2086 [inlined]\n [5] include_string(m::Module, txt::String)\n   @ Base ./loading.jl:2086\n [6] top-level scope\n   @ In[242]:11\n```\n:::\n:::\n\n\n::: {#0e1b10fd .cell execution_count=282}\n``` {.julia .cell-code}\ncode = \"\"\"\n    i = 10\n    while i <= 12\n        global i = i + 1  # i is global\n        @show i\n    end\n    @show i\n\"\"\"\n\ninclude_string(Main, code)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ni = 11\ni = 12\ni = 13\ni = 13\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=243}\n```\n13\n```\n:::\n:::\n\n\n#### Constants\n\nThe `const` declaration should only be used in global scope on globals. It is difficult for the compiler to optimize code involving global variables, since their values (or even their types) might change at almost any time. If a global variable will not change, adding a `const` declaration solves this performance problem.\n\nLocal constants are quite different. The compiler is able to determine automatically when a local variable is constant, so local constant declarations are not necessary, and in fact are currently not supported.\n\n#### Typed globals\n\nA global can be declared to always be of a constant type by using the syntax `global x::T` or upon assignment as `x::T = 123`.\n\nOnce a global is declared to be of a constant type, it cannot be assigned to values which cannot be converted to the specified type. In addition, a global has either been assigned to or its type has been set, the binding type is not allowed to change.\n\n### Parallel computing\n\n#### Asynchronous tasks\n\nA task has a create-start-run-finish lifecycle, allowing suspending and resuming computations.\n\n1.  **Create** a task by calling the `Task` constructor on a **0-argument** function or using the `@task` macro: `Task(() -> x)` is equivalent to `@task x`.\n2.  **Start** a task by calling `schedule(x)` (i.e., add it to an internal queue of tasks).\n\n**Note:** for convenience, you can use `@async x` to create and start a task at once (equivalent to `schedule(@task x)`).\n\n3.  You can then call `wait(x)` to wait the task to exit.\n\n::: {#8a10ec8b .cell execution_count=283}\n``` {.julia .cell-code}\nfunction mysleep(seconds)\n    sleep(seconds)\n    println(\"done\")\nend\n\nt = Task(() -> mysleep(5))  # equivalent to `@task mysleep(5)`\nschedule(t)\nwait(t)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndone\n```\n:::\n:::\n\n\n4.  Communicating with channels.\n\n-   You can call the `Channel{T}(size)` constructor to create a channel with an internal buffer that can hold a maximum of `size` objects of type `T` (`Channel(0)` constructs an unbuffered channel).\n\n-   Different tasks can write to the same channel concurrently via `put!(channel, x)` calls.\n\n-   Different tasks can read data concurrently via `take!(channel)` (remove and return a value from a channel) or `fetch()` (return the **first** available value from a channel without removing) calls.\n\n-   If a channel is empty, readers (on a `take!()` call) will block until data is available.\n\n-   If a channel is full, writers (on a `put!()` call) will block until space becomes available.\n\n-   You can use `isready(channel)` to check for the presence of any object in the channel, and use `wait(channel)` to wait for an object to become available.\n\n-   You can use `close(channel)` to close a channel. On a closed channel, `put!()` will fail, but `take!()` and `fetch()` can still successfully return any existing values until it is emptied.\n\n-   You can associate a channel with a task using the `Channel(f)` constructor (`f` is a function accepting a **single** argument of type `Channel`) or the `bind(channel, task)` function. This means that the lifecycle of the channel is bound to this task (i.e., you don't have to close the channel explicitly, while the channel will be closed the moment the task exits). In addition, it will not only log any unexpected failures, but also force the associated resources to close and propagate the exception everywhere. Compared with `bind()`, `errormonitor(task)` only prints an error log if `task` fails.\n\n-   The returned channel can be used as an iterable object in a `for` loop, in which case the loop variable takes on all the produced values. **The loop is terminated when the channel is closed**.\n\n::: {#aa5c4002 .cell execution_count=284}\n``` {.julia .cell-code}\njobs = Channel{Int}(32)\nresults = Channel{Tuple}(32)\n\nfunction do_work()\n    for job_id in jobs\n        exec_time = rand()\n        sleep(exec_time)\n\n        put!(results, (job_id, exec_time))\n    end\nend\n\nfunction make_jobs(n)\n    for i in 1:n\n        put!(jobs, i)\n    end\nend\n\nn = 12\n\nerrormonitor(@async make_jobs(n))\n\nfor i in 1:4  # spawn 4 tasks\n    errormonitor(@async do_work())\nend\n\nsum_time = 0\neval_time = @elapsed while n > 0\n    job_id, exec_time = take!(results)\n    println(\"$job_id finished in $(round(exec_time; digits = 2)) seconds\")\n    global n = n - 1\n    global sum_time = sum_time + exec_time\nend\nprintln(\"The evaluated time is $eval_time seconds\")\nprintln(\"The accumulated time is $sum_time seconds\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 finished in 0.22 seconds\n4 finished in 0.35 seconds\n6 finished in 0.2 seconds\n2 finished in 0.67 seconds\n3 finished in 0.97 seconds\n7 finished in 0.45 seconds\n8 finished in 0.39 seconds\n5 finished in 0.87 seconds\n12 finished in 0.04 seconds\n9 finished in 0.48 seconds\n11 finished in 0.61 seconds\n10 finished in 0.77 seconds\nThe evaluated time is 1.874634034 seconds\nThe accumulated time is 6.0185192397190255 seconds\n```\n:::\n:::\n\n\n5.  More task operations\n\nTask operations are built on a low-level primitive called `yieldto(task, value)`, which suspends the current task, switches to the specified task, and causes that task's last `yieldto()` call to return the specified value.\n\nA few other useful functions of tasks:\n\n-   `current_task()`: gets a reference to the currently-running task.\n\n-   `istaskdone()`: queries whether a task has exited.\n\n-   `istaskstarted()`: queries whether a task has run yet.\n\n-   `task_local_storage()`: manipulates a key-value store specific to the current task.\n\n#### Multi-threading\n\nJulia's multi-threading, provided by the `Threads` module, a sub-module of `Base`, provides the ability to schedule tasks simultaneously on more than one thread or CPU core, sharing memory.\n\n##### Starting Julia with multiple threads\n\nThe number of execution threads is controlled either by using `-t`/`--threads` (`julia -t 4`) command line argument or by using the `JULIA_NUM_THREADS` (`export JULIA_NUM_THREADS=4`, which must be done before starting Julia, and setting it in `startup.jl` file by using `ENV` is too late) environment variable. When both are specified, the `-t`/`--threads` takes precedence. Both options support the `auto` argument, which let Julia itself infer a useful default number of threads to use.\n\n**Note:** The number of threads specified with `-t`/`--threads` is propagated to processes that are spawned using the `-p`/`--procs` or `--machine-file` command line option. For example, `julia -p 2 -t 2` spawns 1 main process and 2 worker processes, and all three processes have 2 threads enabled. For more fine grained control over worker threads use `addprocs()` and pass `-t`/`--threads` as `exeflags`.\n\n**Note:** The Garbage Collector (GC) can use multiple threads. You can specify it either by using the `--gcthreads` command line argument or by using the `JULIA_NUM_GC_THREADS` environment variable.\n\nAfter starting Julia with multiple threads, you can check it with the following functions:\n\n::: {#95488997 .cell execution_count=285}\n``` {.julia .cell-code}\nThreads.nthreads()\n```\n\n::: {.cell-output .cell-output-display execution_count=246}\n```\n1\n```\n:::\n:::\n\n\n::: {#48e3962f .cell execution_count=286}\n``` {.julia .cell-code}\nThreads.threadid()\n```\n\n::: {.cell-output .cell-output-display execution_count=247}\n```\n1\n```\n:::\n:::\n\n\n##### Thread pools\n\nThere are two types of thread pools: `:interactive` (often used for interactive tasks) and `:default` (often used for long duration tasks).\n\nYou can set the number of execution threads available for each thread pool of the two by: `-t 3,1` or `JULIA_NUM_THREADS=3,1`, which means that there are 3 threads in the `:default` thread pool, and 1 thread in the `:interactive` thread pool. Both numbers can be replaced with the word `auto`.\n\nCorresponding helper functions:\n\n::: {#8dd90a4f .cell execution_count=287}\n``` {.julia .cell-code}\nusing Base.Threads\n\nprintln(nthreadpools())  # the number of thread pools\n\nprintln(threadpool(1))  # which thread pool the thread 1 belongs to\n\nprintln(nthreads(:default))  # the number of threads available for the :default thread pool\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2\ndefault\n1\n```\n:::\n:::\n\n\n##### Spawning threads\n\n1.  `@spawn`: you can specify which thread pool should be used by the spawned thread.\n\n::: {#c3e35080 .cell execution_count=288}\n``` {.julia .cell-code}\nThreads.@spawn :interactive begin; println(\"task done\"); end\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntask done\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=249}\n```\nTask (done) @0x00007f915a615aa0\n```\n:::\n:::\n\n\n2.  `@threads`: this macro is affixed in front of a `for` loop to indicate to Julia that the loop is a multi-threaded region.\n\n::: {#12a2d8e6 .cell execution_count=289}\n``` {.julia .cell-code}\na = zeros(10)\n\n# the iteration space is plit among the threads\nThreads.@threads for i = 1:10\n    a[i] = Threads.threadid()\nend\n\na\n```\n\n::: {.cell-output .cell-output-display execution_count=250}\n```\n10-element Vector{Float64}:\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n```\n:::\n:::\n\n\n**Note:** after a task starts running on a certain thread it may move to a different thread although the `:static` schedule option for `@threads` does freeze the thread id. This means that in most cases `threadid()` should not be treated as constant within a task.\n\n##### Avoiding data race\n\nBe very careful about reading any data if another thread might write to it!\n\nInstead, always use the lock pattern when changing data accessed by other threads.\n\n::: {#c4ae2072 .cell execution_count=290}\n``` {.julia .cell-code}\nlk = ReentrantLock()\n\n# method 1\nlock(lk) do \n    use(a)\nend\n\n# method 2\nbegin\n    lock(lk)\n    try\n        use(a)\n    finally\n        unlock(lk)  # each lock must be matched by an unlock\n    end\nend\n```\n:::\n\n\nA toy example:\n\n1.  Without multi-threading:\n\n::: {#322fed0a .cell execution_count=291}\n``` {.julia .cell-code}\n# the correct result\nfunction sum_single(x)\n    s = 0\n    for i = x\n        s += i\n    end\n    s\nend\n\n@time sum_single(1:1_000_000)  # in Julia, the underscore (_) can be used as a separator in literal integers to enhance readability\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  0.000001 seconds\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=251}\n```\n500000500000\n```\n:::\n:::\n\n\n2.  Data race often leads to non-deterministic results:\n\n::: {#13cc7435 .cell execution_count=292}\n``` {.julia .cell-code}\n# with data race and the result is non-deterministic\nfunction sum_multi_bad(x)\n    s = 0\n    Threads.@threads for i = x\n        s += i\n    end\n    s\nend\n\nfor i = 1:6\n    println(sum_multi_bad(1:1_000_000))\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n500000500000\n500000500000\n500000500000\n500000500000\n500000500000\n500000500000\n```\n:::\n:::\n\n\n3.  Add lock when performing data race operations:\n\n::: {#d07610ea .cell execution_count=293}\n``` {.julia .cell-code}\n# locked version\n# the result is correct\nlk = ReentrantLock()\n\nfunction sum_multi_lock(x)\n    s = 0\n    Threads.@threads for i = x\n        lock(lk) do\n            s += i\n        end\n    end\n    s\nend\n\nfor i = 1:6\n    println(sum_multi_lock(1:1_000_000))\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n500000500000\n500000500000\n500000500000\n500000500000\n500000500000\n500000500000\n```\n:::\n:::\n\n\n4.  Split data into chunks –\\> use its own internal buffer for each thread –\\> collect all results of chunks:\n\n::: {#df8d0a61 .cell execution_count=294}\n``` {.julia .cell-code}\n# split the sum into chunks that are race-free\n# collect the result of each chunk\n# add the results together\nfunction sum_multi_chunk(x)\n    chunks = Iterators.partition(x, length(x) ÷ Threads.nthreads())\n    tasks = map(chunks) do chunk\n        Threads.@spawn sum_single(chunk)\n    end\n    chunk_sums = fetch.(tasks)\n    return sum_single(chunk_sums)\nend\n\n@time sum_multi_chunk(1:1_000_000)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  0.031615 seconds (15.59 k allocations: 1.081 MiB, 99.56% compilation time)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=254}\n```\n500000500000\n```\n:::\n:::\n\n\n5.  Use atomic operations:\n\nJulia supports accessing and modifying values atomically, that is, in a thread-safe way to avoid data race.\n\nA value (which must be of a **primitive** type) can be wrapped as `Threads.Atomic{T}(value)` to indicate it must be accessed in this way.\n\nIn a word, perform atomic operations on atomic values to avoid data race.\n\n::: {#2dbe2aa0 .cell execution_count=295}\n``` {.julia .cell-code}\nfunction sum_multi_atomic(x)\n    s = Threads.Atomic{Int}(0)  # s is an atomic value of type Int\n    Threads.@threads for i = x\n        Threads.atomic_add!(s, i)  # perform atomic operation atomic_add! (add i to s, and return the old value) on atomic value s\n    end\n    s\nend\n\nres = sum_multi_atomic(1:1_000_000)\nres[]  # Atomic objects can be accessed using the [] notation\n```\n\n::: {.cell-output .cell-output-display execution_count=255}\n```\n500000500000\n```\n:::\n:::\n\n\n#### Multi-processing and Distributed computing\n\nDistributed computing provided by module `Distributed` runs multiple Julia processes with **separate** memory spaces.\n\n##### Starting and managing multiple processes\n\nIn Julia, each process has an associated identifier. The process providing the interactive Julia prompt always has an id equal to 1, called the main process.\n\nBy default, the processes used for parallel operations are referred to as \"workers\". When there is only 1 process, process 1 is considered a worker. Otherwise, workers are considered to be all processes other than process 1. As a result, adding 2 or more processes is required to gain benefits from parallel processing methods. Adding a single process is beneficial if you just wish to do other things in the main process while a long computation is running on the worker.\n\nJulia has built-in support for two types of clusters:\n\n-   **A local cluster** specified with the `-p`/`--procs` option (implicitly loads module `Distributed`).\n\n-   **A cluster spanning machines** using the `--machine-file` option.\n\nThis uses a **passwordless** ssh login to start Julia worker processes from the same path as the current host on the specified machines.\n\nEach machine definition takes the form `[count*] [user@]host[:port] [bind_addr[:port]]`. `count` is the number of workers to spawn on the node, and defaults to 1; `user` defaults to the current user; `port` defaults to the standard ssh port; `bind_addr[:port]` specifies the IP address and port that other workers should use to connect to this worker.\n\n**Note:** in Julia, distribution of code to worker processes relies on `Serialization.serialize` (the need for data serialization and deserialization arises primarily due to the requirement to convert complex data structures into formats that can be transmitted across a network when different nodes communicate with each other), so it is advised that all workers on all machines use the same version of Julia to ensure compatibility of serialization and deserialization.\n\n`Distributed` package provides some useful functions for starting and managing processes within Julia:\n\n::: {#d670289e .cell execution_count=296}\n``` {.julia .cell-code}\nusing Distributed  # Module Distributed must be explicitly loaded on the master process before invoking addprocs() and other functions if you want to start distributed computing within Julia, instead of using command line options. It is automaticaly made available on the worker processes.\n\naddprocs()  # launch worker processes using the LocalManager (the same as -p), SSHManager (the same as --machine-file) or other cluster managers of type ClusterManager\n\nprocs()  # return a list of all process identifiers\n\nnprocs()  # return the number of available processes\n\nworkers()\n\nnworkers()\n\nmyid()  # get the id of the current process\n```\n:::\n\n\n**Note:** workers do **not** run a `~/.julia/config/startup.jl` startup script, nor do they synchronize their global state with any of the other running processes. You may use `addprocs(exeflags = \"--project\")` to initialize a worker with a particular environment.\n\n::: {.callout-note title=\"Network requirements for `LocalManager` and `SSHManager`\"}\n1.  The master process does not listen on any port. It only connects out to the workers.\n2.  Each worker binds to only one of the local interfaces and listens on an ephemeral port number assigned by the OS.\n3.  `LocalManager`, used by `addprocs(N)`, by default binds only to the loopback interface. An `addprocs(4)` followed by an `addprocs([\"remote_host\"])` will fail. To create a cluster comprising their local system and a few remote systems, it can be done by explicitly requesting `LocalManager` to bind to an external network interface via `restrict` keyword argument: `addprocs(4; restrict = false)`.\n4.  `SSHManager`, used by `addprocs(list_of_remote_hosts)`, launches workers on remote hosts via SSH. By default SSH is only used to launch Julia workers. Subsequent master-worker and worker-worker connections use plain, unencrypted TCP/IP sockets. The remote hosts must have passwordless login enabled. Additional SSH flags or credentials may be specified via keyword argument `sshflags`.\n:::\n\n::: {.callout-note title=\"Cluster cookie\"}\nAll processes in a cluster share the same cookie which, by default, is a randomly generated string on the master process, and can be accessed via `cluster_cookie()`, while `cluster_cookie(cookie)` sets it and returns the new cookie. It can also be passed to the workers at startup via `--worker=<cookie>`.\n:::\n\n::: {.callout-note title=\"Specifying network topology\"}\nThe keyword argument `topology` to `addprocs()` is used to specify how the workers must be connected to each other. The default is `:all_to_all`, meaning that all workers are connected to each other.\n:::\n\n##### Starting distributed programming\n\nDistributed programming in Julia is built on two primitives:\n\n1.  Remote references: a remote reference is an object of type `RemoteChannel` that can be used from any process to refer to an object stored on a particular process. Multiple processes can communicate via `RemoteChannel`.\n2.  Remote calls: a remote call is a request by one process to call a certain function on certain arguments on another (possibly the same) process. A remote call returns a `Future` object to its result. Then you can use `wait()` to wait the function running to finish or use `fetch()` to get the returned value by the called function.\n\nLaunch remote calls:\n\n::: {#574846d8 .cell execution_count=297}\n``` {.julia .cell-code}\n@spawn p expr  # Create a closure around an expression and run the closure asynchronously on process p. If p is set to :any, then the system will pick a process to use automatically.\n@fetchfrom p expr  # equivalent to fetch(@spawnat p expr)\n\nremotecall(f, pid, ...)  # Call a function f asynchronously on the given arguments ... on the specified process pid.\nremotecall(f, pool, ...)  # Give a pool of type WorkerPool instead of a pid. It will wait for and take a free worker from pool to use.\nremotecall_fetch()  # equivalent to fetch(remotecall())\nremote_do(f, id, ...)  # Run f on worker id asynchronously. Unlike remotecall, it does not store the result of computation, nor is there a way to wait for its completion.\n```\n:::\n\n\n::: {#6c3f4289 .cell execution_count=298}\n``` {.julia .cell-code}\nusing Distributed\n\naddprocs(2)  # add 2 wrokers via LocalManager\n\nr = remotecall(rand, 2, 3, 3)  # run rand(3, 3) on process 2\ns = @spawnat 2 1 .+ fetch(r)  # run expr 1 .+ fetch(r) on process 2 (note: this forms a closure () -> 1 .+ fetch(r) which contains the global variable r)\nfetch(s)\n```\n\n::: {.cell-output .cell-output-display execution_count=256}\n```\n3×3 Matrix{Float64}:\n 1.5031   1.409    1.48658\n 1.61592  1.6915   1.6822\n 1.22917  1.57784  1.43686\n```\n:::\n:::\n\n\n**Note:** once fetched, a `Future` will cache its value locally. Further `fetch()` calls don not entail a network hop. Once all referencing `Future`s have fetched, the remote stored value is deleted.\n\n##### Code and data availability\n\nBefore spawning a process, you must ensure that your code and data are available on any process that runs it.\n\n1.  **Code availability**\n\n::: {#81146b5b .cell execution_count=299}\n``` {.julia .cell-code}\nfunction rand2(dims...)\n    return 2 * rand(dims...)\nend\n\nrand2(2, 2)\n```\n\n::: {.cell-output .cell-output-display execution_count=257}\n```\n2×2 Matrix{Float64}:\n 1.95961  1.90016\n 0.80429  1.84709\n```\n:::\n:::\n\n\n::: {#92c15702 .cell execution_count=300}\n``` {.julia .cell-code}\nusing Distributed\n\naddprocs(2)\n```\n:::\n\n\n::: {#30f8a0cd .cell execution_count=301}\n``` {.julia .cell-code}\n# rand2 is defined in the main process\n# so process 1 knew it but the others did not\nfetch(@spawnat :any rand2(2, 2))\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>On worker 2:\nUndefVarError: `#rand2` not defined\nStacktrace:\n  [1] <span class=\"ansi-bold\">deserialize_datatype</span>\n<span class=\"ansi-bright-black-fg\">    @</span> <span class=\"ansi-bright-black-fg\">~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Serialization/src/</span><span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">Serialization.jl:1399</span>\n  [2] <span class=\"ansi-bold\">handle_deserialize</span>\n<span class=\"ansi-bright-black-fg\">    @</span> <span class=\"ansi-bright-black-fg\">~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Serialization/src/</span><span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">Serialization.jl:867</span>\n  [3] <span class=\"ansi-bold\">deserialize</span>\n<span class=\"ansi-bright-black-fg\">    @</span> <span class=\"ansi-bright-black-fg\">~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Serialization/src/</span><span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">Serialization.jl:814</span>\n  [4] <span class=\"ansi-bold\">handle_deserialize</span>\n<span class=\"ansi-bright-black-fg\">    @</span> <span class=\"ansi-bright-black-fg\">~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Serialization/src/</span><span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">Serialization.jl:874</span>\n  [5] <span class=\"ansi-bold\">deserialize</span>\n<span class=\"ansi-bright-black-fg\">    @</span> <span class=\"ansi-bright-black-fg\">~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Serialization/src/</span><span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">Serialization.jl:814</span><span class=\"ansi-bright-black-fg\"> [inlined]</span>\n  [6] <span class=\"ansi-bold\">deserialize_global_from_main</span>\n<span class=\"ansi-bright-black-fg\">    @</span> <span class=\"ansi-bright-black-fg\">~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Distributed/src/</span><span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">clusterserialize.jl:160</span>\n  [7] <span class=\"ansi-bold\">#5</span>\n<span class=\"ansi-bright-black-fg\">    @</span> <span class=\"ansi-bright-black-fg\">~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Distributed/src/</span><span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">clusterserialize.jl:72</span><span class=\"ansi-bright-black-fg\"> [inlined]</span>\n  [8] <span class=\"ansi-bold\">foreach</span>\n<span class=\"ansi-bright-black-fg\">    @</span> <span class=\"ansi-bright-black-fg\">./</span><span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">abstractarray.jl:3097</span>\n  [9] <span class=\"ansi-bold\">deserialize</span>\n<span class=\"ansi-bright-black-fg\">    @</span> <span class=\"ansi-bright-black-fg\">~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Distributed/src/</span><span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">clusterserialize.jl:72</span>\n [10] <span class=\"ansi-bold\">handle_deserialize</span>\n<span class=\"ansi-bright-black-fg\">    @</span> <span class=\"ansi-bright-black-fg\">~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Serialization/src/</span><span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">Serialization.jl:960</span>\n [11] <span class=\"ansi-bold\">deserialize</span>\n<span class=\"ansi-bright-black-fg\">    @</span> <span class=\"ansi-bright-black-fg\">~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Serialization/src/</span><span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">Serialization.jl:814</span>\n [12] <span class=\"ansi-bold\">handle_deserialize</span>\n<span class=\"ansi-bright-black-fg\">    @</span> <span class=\"ansi-bright-black-fg\">~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Serialization/src/</span><span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">Serialization.jl:871</span>\n [13] <span class=\"ansi-bold\">deserialize</span>\n<span class=\"ansi-bright-black-fg\">    @</span> <span class=\"ansi-bright-black-fg\">~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Serialization/src/</span><span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">Serialization.jl:814</span>\n [14] <span class=\"ansi-bold\">handle_deserialize</span>\n<span class=\"ansi-bright-black-fg\">    @</span> <span class=\"ansi-bright-black-fg\">~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Serialization/src/</span><span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">Serialization.jl:874</span>\n [15] <span class=\"ansi-bold\">deserialize</span>\n<span class=\"ansi-bright-black-fg\">    @</span> <span class=\"ansi-bright-black-fg\">~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Serialization/src/</span><span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">Serialization.jl:814</span><span class=\"ansi-bright-black-fg\"> [inlined]</span>\n [16] <span class=\"ansi-bold\">deserialize_msg</span>\n<span class=\"ansi-bright-black-fg\">    @</span> <span class=\"ansi-bright-black-fg\">~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Distributed/src/</span><span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">messages.jl:87</span>\n [17] <span class=\"ansi-bold\">#invokelatest#2</span>\n<span class=\"ansi-bright-black-fg\">    @</span> <span class=\"ansi-bright-black-fg\">./</span><span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">essentials.jl:892</span><span class=\"ansi-bright-black-fg\"> [inlined]</span>\n [18] <span class=\"ansi-bold\">invokelatest</span>\n<span class=\"ansi-bright-black-fg\">    @</span> <span class=\"ansi-bright-black-fg\">./</span><span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">essentials.jl:889</span><span class=\"ansi-bright-black-fg\"> [inlined]</span>\n [19] <span class=\"ansi-bold\">message_handler_loop</span>\n<span class=\"ansi-bright-black-fg\">    @</span> <span class=\"ansi-bright-black-fg\">~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Distributed/src/</span><span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">process_messages.jl:176</span>\n [20] <span class=\"ansi-bold\">process_tcp_streams</span>\n<span class=\"ansi-bright-black-fg\">    @</span> <span class=\"ansi-bright-black-fg\">~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Distributed/src/</span><span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">process_messages.jl:133</span>\n [21] <span class=\"ansi-bold\">#103</span>\n<span class=\"ansi-bright-black-fg\">    @</span> <span class=\"ansi-bright-black-fg\">~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Distributed/src/</span><span style=\"text-decoration:underline\" class=\"ansi-bright-black-fg\">process_messages.jl:121</span>\n\nStacktrace:\n [1] remotecall_fetch(f::Function, w::Distributed.Worker, args::Distributed.RRID; kwargs::@Kwargs{})\n   @ Distributed ~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Distributed/src/remotecall.jl:465\n [2] remotecall_fetch(f::Function, w::Distributed.Worker, args::Distributed.RRID)\n   @ Distributed ~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Distributed/src/remotecall.jl:454\n [3] remotecall_fetch\n   @ ~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Distributed/src/remotecall.jl:492 [inlined]\n [4] call_on_owner\n   @ ~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Distributed/src/remotecall.jl:565 [inlined]\n [5] fetch(r::Future)\n   @ Distributed ~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Distributed/src/remotecall.jl:619\n [6] top-level scope\n   @ ~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Distributed/src/macros.jl:95</pre>\n```\n:::\n\n:::\n:::\n\n\n**Note:** more commonly you'll be loading code from files or packages, and you'll have a considerable amount of flexibility in controlling which processes load code. So if you have defined some functions, types, etc., you'd better organize them into files or packages, which will make things easier.\n\nConsider a file, `DummyModule.jl`, containing the following code:\n\n::: {#87ee7445 .cell execution_count=302}\n``` {.julia .cell-code}\nmodule DummyModule\nexport MyType, f\n\nmutable struct MyType\n    a::Int\nend\n\nf(x) = x^2 + 1\n\nprintln(\"DummyModule loaded\")\n\nend\n```\n:::\n\n\nIn order to refer to the code defined in `DummyModule.jl` across all processes, **first**, `DummyModule.jl` needs to be **loaded** on every process. Calling `include(\"DummyModule.jl\")` loads it only on a single process. To load it on every process, use the `@everywhere [procs()] expr` macro, which execute an expression under `Main` on all `procs`:\n\n::: {#af597c58 .cell execution_count=303}\n``` {.julia .cell-code}\n@everywhere include(\"DummyModule.jl\")\n@everywhere using InteractiveUtils\n\n@fetchfrom 2 InteractiveUtils.varinfo()  # show exported global variables in a module\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDummyModule loaded\n      From worker 2:\tDummyModule loaded\n      From worker 3:\tDummyModule loaded\n```\n:::\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=259}\n| name        |        size | summary |\n|:----------- | -----------:|:------- |\n| Base        |             | Module  |\n| Core        |             | Module  |\n| Distributed |   1.130 MiB | Module  |\n| DummyModule | 266.719 KiB | Module  |\n| Main        |             | Module  |\n| r           |   256 bytes | Future  |\n\n:::\n:::\n\n\nOnce loaded, we can use code defined in `DummyModule.jl` across all processes by:\n\n::: {#38ab71be .cell execution_count=304}\n``` {.julia .cell-code}\n@everywhere using .DummyModule\n\n@fetchfrom 2 f(100)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      From worker 2:\t┌ Warning: Cannot transfer global variable f; it already has a value.\n      From worker 2:\t└ @ Distributed ~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Distributed/src/clusterserialize.jl:166\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=260}\n```\n10001\n```\n:::\n:::\n\n\n**Note:** a file can be preloaded on multiple processes at startup with the `-L` flag, and a driver script can be used to drive the computation: `julia -p <n> -L file1.jl -L file2.jl driver.jl`. The Julia process running the driver script given here has an id equal to 1, just like a process providing an interactive prompt.\n\nIf `DummyModule.jl` is a package, just use `@everywhere using DummyModule`, which will make code defined in `DummyModule.jl` available in every process.\n\n2.  **Data availability**\n\nSending messages and moving data constitute most of the overhead in a distributed program.\n\nReducing the number of messages and the amount of data sent is critical to achieving performance and scalability.\n\n-   Global variables\n\n    Expressions executed remotely via `@spawnat`, or closures specified for remote execution using `remotecall()` may refer to global variables.\n\n    Remote calls with embedded global references (**under Main module only**) manage globals as follows:\n\n    -   New global bindings are created on destination workers if they are referenced as part of remote call.\n\n    -   Global constants are declared as constants on remote nodes too.\n\n    -   Globals are re-sent to a destination worker only in the context of a remote call, and only if its value has changed.\n\n    -   The cluster does not synchronize global bindings across nodes.\n\n**Note:** memory associated with globals may be collected when they are reassigned on the master, while no such action is taken on the workers as the bindings continue to be valid. `clear!()` can be used to manually reassign specific globals on remote nodes to `nothing` once they are no longer required.\n\nOnly when remote calls refer to globals under the `Main` module are new global bindings created on destination workers, so we can use `let` blocks to localize global variables when forming closures. This avoids new global bindings' creating on destination workers:\n\n::: {#c52d868f .cell execution_count=305}\n``` {.julia .cell-code}\nA = rand(10, 10)\nremotecall_fetch(() -> A, 2)  # A is a global variable under the Main module, so new global binding of A will be created on process 2\n\nB = rand(10, 10)\nlet B = B  # B becomes a local variable, so B won't be created on process 2\n    remotecall_fetch(() -> B, 2)\nend\n@fetchfrom 2 InteractiveUtils.varinfo()\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=261}\n| name        |        size | summary               |\n|:----------- | -----------:|:--------------------- |\n| A           |   840 bytes | 10×10 Matrix{Float64} |\n| Base        |             | Module                |\n| Core        |             | Module                |\n| Distributed |   1.141 MiB | Module                |\n| DummyModule | 267.550 KiB | Module                |\n| Main        |             | Module                |\n| r           |   256 bytes | Future                |\n\n:::\n:::\n\n\n-   Communicating with `RemoteChannel`s\n\n    Create references to remote channels with the following:\n\n\n    ::: {#0da5cb6d .cell execution_count=306}\n    ``` {.julia .cell-code}\n    RemoteChannel(f, pid)  # Create references to remote channels of a specific size and type. f is a function that when executed on pid (the default is the current process) must return an implementation of an AbstractChannel. e.g., RemoteChannel(() -> Channel{Int}(10), pid).\n    RemoteChannel(pid)  # make a reference to a Channel{Any}(1) on process pid\n    ```\n    :::\n    \n    \n    -   A `Channel` is local to a process, but a `RemoteChannel` can put and take values across workers.\n    -   A `RemoteChannel` can be thought of as a handle to a `Channel`.\n    -   The process id, `pid`, associated with a `RemoteChannel` identifies the process where the backing store, i.e., the backing `Channel` exists.\n    -   Any process with a reference to a `RemoteChannel` can put and take items from the channel. Data is automatically sent to or retrieved from the process a `RemoteChannel` is associated with.\n    -   Serializing a `Channel` also serializes any data present in the channel. Deserializing it therefore effectively makes a copy of the original object.\n    -   On the other hand, serializing a `RemoteChannel` only involves the serialization of an identifier that identifies the **location** and **instance** of `Channel` referred to by the handle. A deserialized `RemoteChannel` object on any worker, therefore also points to the same backing store as the original.\n\n::: {#66a3085f .cell execution_count=307}\n``` {.julia .cell-code}\njobs = RemoteChannel(() -> Channel{Int}(32))\nresults = RemoteChannel(() -> Channel{Tuple}(32))\n\n@everywhere function do_work(jobs, results)  # define work function everywhere\n    while true\n        job_id = take!(jobs)\n        exec_time = rand()\n        sleep(exec_time)  # simulate elpased time doing actual work\n        put!(results, (job_id, exec_time, myid()))\n    end\nend\n\nfunction make_jobs(n)\n    for i in 1:n\n        put!(jobs, i)\n    end\nend\n\nn = 12\n\nerrormonitor(@async make_jobs(n))\n\nfor p in workers()\n    remote_do(do_work, p, jobs, results)\nend\n\n@elapsed while n > 0\n    job_id, exec_time, where = take!(results)\n    println(\"$job_id finished in $(round(exec_time; digits = 2)) seconds on worker $where\")\n    global n = n - 1\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 finished in 0.36 seconds on worker 2\n2 finished in 0.49 seconds on worker 3\n3 finished in 0.61 seconds on worker 2\n4 finished in 0.46 seconds on worker 3\n5 finished in 0.21 seconds on worker 2\n6 finished in 0.46 seconds on worker 3\n7 finished in 0.63 seconds on worker 2\n8 finished in 0.54 seconds on worker 3\n9 finished in 0.73 seconds on worker 2\n10 finished in 0.78 seconds on worker 3\n12 finished in 0.47 seconds on worker 3\n11 finished in 0.77 seconds on worker 2\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=262}\n```\n3.646881956\n```\n:::\n:::\n\n\n::: {.callout-note title=\"Local invocations\"}\nWhen data is stored on a different node from the execution node, data is necessarily copied over to the remote node for execution. However, when the destination node is the local node, i.e., the calling process id is the same as the remote node id, it is executed as a local call. It is usually (not always) executed in a different task, but there is no serialization/deserialization of data. Consequently, the call refers to the same object instances as passed, i.e., no copies are created.\n\n::: {#cf9fe527 .cell execution_count=308}\n``` {.julia .cell-code}\nrc = RemoteChannel(() -> Channel(3))  # RemoteChannel created on local node\n\nv = [0]  # array in Julia has stable memory address\n\nfor i in 1:3\n    v[1] = i  # reusing v\n    put!(rc, v)\nend\n\nres = [take!(rc) for _ in 1:3]\n\nprintln(res)\n\nprintln(map(objectid, res))\n\nprintln(\"Num unique obejcts: \", length(unique(map(objectid, res))))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[3], [3], [3]]\nUInt64[0xb5f36520df483d44, 0xb5f36520df483d44, 0xb5f36520df483d44]\nNum unique obejcts: 1\n```\n:::\n:::\n\n\nIn general, this is not an issue. If the local node is also being used as a compute node, and the arguments used post the call, this behavior needs to be factored in and if required deep copies of arguments.\n:::\n\n-   Shared arrays\n\nShared arrays use system shared memory to map the same array across many processes.\n\nEach \"participating\" process has access to the **entire** array, which is totally different from the `DArray` defined in `DistributedArrays.jl`, of which each process has local access to just a chunk (i.e., no two processes share the same chunk).\n\nA `SharedArray` defined in `SharedArrays` module is a good choice when you want to have a large amount of data jointly accessible to two or more processes **on the same machine**.\n\nIn cases where an algorithm insists on an `Array` input, the underlying array can be retrieved from a `SharedArray` by calling `sdata()`. For other `AbstractArray` types, `sdata()` just returns the object itself.\n\nThe constructor for a shared array is of the form: `SharedArray{T, N}(dims::NTuple; init=false, pids=Int[])`, by which we can construct an `N`-dimensional shared array of **a bits type** (check whether an element is supported using `isbits()`) `T` and size `dims` across the processes specified by `pids`. If an initialization function of the form `f(S::SharedArray)` is passed to `init`, then it is called on all the participating workers. You can specify that each worker runs the `init` function on a distinct portion of the array, thereby parallelizing initialization.\n\n::: {#0f7b3b80 .cell execution_count=309}\n``` {.julia .cell-code}\n@everywhere using SharedArrays\n\nS = SharedArray{Int, 2}((3, 4), init = S -> S[localindices(S)] = repeat([myid()], length(localindices(S))))\n\n# localindices(S): return a range describing the \"default\" indices to be handled by the current process.\n# indexpids(S): return the current worker's index (starting from 1, not the same as the actual pid) in the list of workers mapping the SharedArray, or 0 if the SharedArray is not mapped onto the current process.\n# procs(S): return the list of pids mapping the SharedArray.\n```\n\n::: {.cell-output .cell-output-display execution_count=264}\n```\n3×4 SharedMatrix{Int64}:\n 2  2  3  3\n 2  2  3  3\n 2  2  3  3\n```\n:::\n:::\n\n\n**Note:** because any process mapping the `SharedArray` has access to the entire array, you must take consideration on possible operation conflicts.\n\n##### Parallel loops and map\n\n1.  Looping and then reducing\n\nMany iterations run independently over several processes, and then their results are combined using some function (the result of each iteration is taken as the value of the last expression inside the loop) . The combination process is called a reduction. In code, this typically looks like the pattern `x = f(x, v[i])`, where `x` is the accumulator, `f` is the reduction function, and `v[i]` are the elements being reduced. It is desirable for `f` to be associative, so that it does not matter what order the operations are performed in.\n\n::: {#f57563f4 .cell execution_count=310}\n``` {.julia .cell-code}\n# When reducer is given, it will be blocked and return the final result of reduction process.\n# @distributed [reducer] for var = range\n#     body\n# end\n\n# reducer is optional.\n# If it is omitted, then it will return a Task object immediately without waiting for completion.\n# You can prefix @sync or add wait(t) or fetch(t) (returns nothing) after it to wait for completion.\n # @sync @distributed for var = range\n #    body\n # end\n\nres = @distributed (vcat) for i in 1:6\n    [(myid(), i)]\nend\n\nres\n```\n\n::: {.cell-output .cell-output-display execution_count=265}\n```\n6-element Vector{Tuple{Int64, Int64}}:\n (2, 1)\n (2, 2)\n (2, 3)\n (3, 4)\n (3, 5)\n (3, 6)\n```\n:::\n:::\n\n\n2.  Mapping\n\nIf we merely want to apply a function to all elements in some collection, we can use parallelized map, implemented in Julia as the `pmap()` function.\n\n::: {#554b6640 .cell execution_count=311}\n``` {.julia .cell-code}\nusing LinearAlgebra\n\nM = Matrix{Float64}[rand(1000, 1000) for _ in 1:10]\npmap(svdvals, M)  # calculate the singular values of several matrices in parallel\n```\n\n::: {.cell-output .cell-output-display execution_count=266}\n```\n10-element Vector{Vector{Float64}}:\n [500.0177759176757, 18.06421174287783, 17.981227621452373, 17.92332726630117, 17.838731068240488, 17.753420331994597, 17.71168733528711, 17.65476735816585, 17.612128360065476, 17.60771882704177  …  0.13840101616328937, 0.13193911862258584, 0.119357747880438, 0.09113289171473231, 0.08174833937081102, 0.06222010852072497, 0.049038422635441, 0.044561563193161305, 0.032449963316072604, 0.004270513230201547]\n [500.30544074594235, 18.208593500785533, 18.065289425851613, 17.933575561586757, 17.876499153629222, 17.79394429110242, 17.743295558948113, 17.71173784722835, 17.636519899933216, 17.568455695453785  …  0.13909473497550548, 0.1258594448249676, 0.10669500571693123, 0.08732721226257344, 0.08142060317423437, 0.0788981154402882, 0.05107719237438204, 0.031088180053545786, 0.026451363097944342, 0.004063611399161055]\n [500.2383144234097, 18.20885652402711, 18.07387962906993, 17.941728535882334, 17.86677133986938, 17.785710542272103, 17.739979733947795, 17.687792755541416, 17.655984575634626, 17.587119441580146  …  0.1451055539983298, 0.11358291164602549, 0.09018720630023444, 0.07432213468827491, 0.0634179113616737, 0.05692325777032984, 0.046625536277500206, 0.041853196581529445, 0.018178386645154875, 0.005094318045634688]\n [500.08794972395094, 18.211169090921466, 18.01872349533582, 17.88317231483914, 17.831103953157847, 17.788623584914873, 17.69556377892961, 17.64227565387745, 17.562609974342866, 17.530957120518234  …  0.1299667395269755, 0.12605384263694233, 0.1199364272934578, 0.0907819888244224, 0.08444632611907225, 0.0645911259983415, 0.04500889195905585, 0.03609595929475514, 0.021457892995438033, 3.911322873167237e-5]\n [500.39799136478507, 18.188496528811577, 17.93885712318831, 17.91617495698291, 17.87925556993448, 17.804217993958584, 17.759407936966824, 17.68514205593617, 17.572076461263453, 17.486672912061415  …  0.1417312756246332, 0.13230348206024667, 0.10808243480402457, 0.09433543844715478, 0.08511001643180341, 0.07146686489631734, 0.05385226061060048, 0.04661522077498004, 0.03626662998958416, 0.002823350266137398]\n [500.0464917909289, 18.113149192600773, 17.97923538558104, 17.892593281819696, 17.88070110324045, 17.826539102019595, 17.795053182243407, 17.709390365345474, 17.636474841339222, 17.57943201808123  …  0.12713221472491243, 0.12043499286655325, 0.11892362431840613, 0.10574598850361529, 0.07040897674634287, 0.06203266394157855, 0.02891899925283343, 0.02324572333043797, 0.008048687735659933, 0.004048970364503665]\n [500.20792958963085, 18.263404607762315, 17.988461798078323, 17.94151044591021, 17.906683661996663, 17.799256070999544, 17.691587113039837, 17.638905291137, 17.592113448939926, 17.524114072141707  …  0.11865220351167223, 0.11324976639200965, 0.09827556395803742, 0.07991930837783091, 0.07332384654639487, 0.06128267369804715, 0.04588312454628313, 0.03396766771447287, 0.016349936424052768, 0.011199176040884285]\n [500.2391541923157, 18.19140580852207, 18.073220181904198, 17.999214486451805, 17.93329076587103, 17.836893095606627, 17.74171259073714, 17.699132546313077, 17.69173191902944, 17.622034367356633  …  0.1290446371721021, 0.11873486270170926, 0.09776060243126537, 0.08638887552109367, 0.06533047631062908, 0.052847250293200455, 0.04289225912421125, 0.02916876608337244, 0.003817842295596054, 0.0007402282451418853]\n [500.402623977743, 18.214065294826792, 18.048992153116778, 17.894189262106632, 17.826211143515497, 17.772187539583324, 17.728088360235752, 17.679718584941128, 17.639346999834785, 17.591389840924748  …  0.13196716329141053, 0.1225266613074704, 0.11380031492083569, 0.10058478965749333, 0.09556531974737391, 0.06989544785771873, 0.043063064029072784, 0.03170637137963487, 0.012399855214929882, 0.0056719089695850345]\n [500.35870301845523, 18.269334272611584, 18.158536673951332, 18.031058325685493, 17.919853937318564, 17.82302393607198, 17.785346597746784, 17.719313041097486, 17.676155655930508, 17.616267744093314  …  0.13204201738915136, 0.12738071898037176, 0.1105672679705761, 0.0868965269591531, 0.07557966901028731, 0.06625255459036215, 0.04305752033514217, 0.025735748362021374, 0.014438080587197949, 0.006864933414932486]\n```\n:::\n:::\n\n\n##### Noteworthy external parallel packages\n\nThere are also other packages implementing parallelism or providing data structures suitable for parallelism in Julia.\n\nIn addition, we have also several packages used for GPU programming in Julia.\n\n#### Running external programs\n\n##### Creating `Cmd` objects\n\nThere are two ways to create a `Cmd` objects:\n\n1.  Put the command between backticks (`` ` ``):\n\n::: {#82319ed4 .cell execution_count=312}\n``` {.julia .cell-code}\n`echo hello, world`\n```\n\n::: {.cell-output .cell-output-display execution_count=267}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>`<span style=\"text-decoration:underline\">echo</span> <span style=\"text-decoration:underline\">hello,</span> <span style=\"text-decoration:underline\">world</span>`</pre>\n```\n:::\n\n:::\n:::\n\n\n2.  Use `Cmd()` constructor:\n\n::: {#4e0c25e7 .cell execution_count=313}\n``` {.julia .cell-code}\nCmd(`echo hello, world`)  # from an existing Cmd\nCmd([\"echo\", \"hello, world\"])  # from a list of arguments\n```\n\n::: {.cell-output .cell-output-display execution_count=268}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>`<span style=\"text-decoration:underline\">echo</span> <span style=\"text-decoration:underline\">'hello, world'</span>`</pre>\n```\n:::\n\n:::\n:::\n\n\nKeyword arguments of `Cmd()` allow you to specify several aspects of the `Cmd`'s execution environment.\n\nFor example, you can specify a working directory for the command via `dir`, setting execution environment variables via `env`, which can also be set by two helper functions `setenv()` and `addenv()`.\n\n##### Running `Cmd` objects\n\nThe command is never run with a shell. Instead, Julia will do all of the following processes itself. In fact, the command is run as Julia's immediate child process, using `folk` and `exec` calls.\n\nJulia provides several ways to run a `Cmd` object:\n\n1.  `run()`:\n\n::: {#fffe4abf .cell execution_count=314}\n``` {.julia .cell-code}\nrun(`echo hello, world`)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nhello, world\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=269}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>Process(`<span style=\"text-decoration:underline\">echo</span> <span style=\"text-decoration:underline\">hello,</span> <span style=\"text-decoration:underline\">world</span>`, ProcessExited(0))</pre>\n```\n:::\n\n:::\n:::\n\n\n2.  `read()`:\n\n::: {#4f9f51b5 .cell execution_count=315}\n``` {.julia .cell-code}\nread(`echo hello, world`, String)  # run the command and return the resulting output as a `String`, or as an array of bytes if `String` is omitted\n```\n\n::: {.cell-output .cell-output-display execution_count=270}\n```\n\"hello, world\\n\"\n```\n:::\n:::\n\n\nAs can be seen, the resulting string has a single trailing newline. You can use `readchomp()`, equivalent to `chomp(read(x, String))` to remove it (`chomp()` can be used to remove a single trailing newline from a string).\n\n3.  Use `open()` to read from or write to an external command:\n\n::: {#7421203f .cell execution_count=316}\n``` {.julia .cell-code}\n# writes go to the command's standard input (stdio = stdout)\nopen(`sort -n`, \"w\", stdout) do io\n    for i = 6:-1:1\n        println(io, i)\n    end\nend\n\n# reads from the command's standard output (stdio = stdin)\nopen(`echo \"hello, world\"`, \"r\", stdin) do io\n    readchomp(io)\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n2\n3\n4\n5\n6\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=271}\n```\n\"hello, world\"\n```\n:::\n:::\n\n\n**Note**: the program name and individual arguments in a command can be accessed and iterated over as if the command were an array of strings:\n\n::: {#42da647c .cell execution_count=317}\n``` {.julia .cell-code}\ncollect(`cut -f 1,3,5 test.txt`)\n```\n\n::: {.cell-output .cell-output-display execution_count=272}\n```\n4-element Vector{String}:\n \"cut\"\n \"-f\"\n \"1,3,5\"\n \"test.txt\"\n```\n:::\n:::\n\n\n::: {#4fda250f .cell execution_count=318}\n``` {.julia .cell-code}\n`cut -f 1,3,5 test.txt`[2]\n```\n\n::: {.cell-output .cell-output-display execution_count=273}\n```\n\"-f\"\n```\n:::\n:::\n\n\n##### Command interpolation\n\nYou can use `$` for interpolation much as you would **in a string literal**, and Julia will know when the inserted string needs to be quoted:\n\n::: {#9f4f0d8b .cell execution_count=319}\n``` {.julia .cell-code}\npath = \"/Volumes/External HD\"\nname = \"data\"\next = \"csv\"\n`sort $path/$name.$ext`  # due to the command is never interpreted by a shell, there's no need for actual quoting, which is only for presentation to the user\n```\n\n::: {.cell-output .cell-output-display execution_count=274}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>`<span style=\"text-decoration:underline\">sort</span> <span style=\"text-decoration:underline\">'/Volumes/External HD/data.csv'</span>`</pre>\n```\n:::\n\n:::\n:::\n\n\nIf you want to interpolate multiple words, just using an iterable container:\n\n::: {#b6d9dbde .cell execution_count=320}\n``` {.julia .cell-code}\nfiles = [\"/etc/passwd\", \"/Volumes/External HD/data.csv\"]\n`grep foo $files`\n```\n\n::: {.cell-output .cell-output-display execution_count=275}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>`<span style=\"text-decoration:underline\">grep</span> <span style=\"text-decoration:underline\">foo</span> <span style=\"text-decoration:underline\">/etc/passwd</span> <span style=\"text-decoration:underline\">'/Volumes/External HD/data.csv'</span>`</pre>\n```\n:::\n\n:::\n:::\n\n\nIf you interpolate an array as part of a shell word, the shell's Cartesian product generation is simulated:\n\n::: {#f06fec63 .cell execution_count=321}\n``` {.julia .cell-code}\nnames = [\"foo\", \"bar\", \"baz\"]\n`cat $names.txt`\n```\n\n::: {.cell-output .cell-output-display execution_count=276}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>`<span style=\"text-decoration:underline\">cat</span> <span style=\"text-decoration:underline\">foo.txt</span> <span style=\"text-decoration:underline\">bar.txt</span> <span style=\"text-decoration:underline\">baz.txt</span>`</pre>\n```\n:::\n\n:::\n:::\n\n\nSince you can interpolate literal arrays, no need to create temporary array objects first:\n\n::: {#f2c36083 .cell execution_count=322}\n``` {.julia .cell-code}\n`cat $[\"foo\", \"bar\"].$[\"png\", \"jpeg\"]`\n```\n\n::: {.cell-output .cell-output-display execution_count=277}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>`<span style=\"text-decoration:underline\">cat</span> <span style=\"text-decoration:underline\">foo.png</span> <span style=\"text-decoration:underline\">foo.jpeg</span> <span style=\"text-decoration:underline\">bar.png</span> <span style=\"text-decoration:underline\">bar.jpeg</span>`</pre>\n```\n:::\n\n:::\n:::\n\n\n##### Quoting\n\nIf you just want to treat some special characters as is, then quote it with paired single quotes `''`, or quote it with paired double quotes `\"\"`, which means that all characters within paired single quotes will have no special meanings, but some may have within paired double quotes:\n\n::: {#ef1d75e9 .cell execution_count=323}\n``` {.julia .cell-code}\n`cat '$file'`\n```\n\n::: {.cell-output .cell-output-display execution_count=278}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>`<span style=\"text-decoration:underline\">cat</span> <span style=\"text-decoration:underline\">'$file'</span>`</pre>\n```\n:::\n\n:::\n:::\n\n\n::: {#6a807d24 .cell execution_count=324}\n``` {.julia .cell-code}\nfile = \"text.txt\"\n`cat \"$file\"`\n```\n\n::: {.cell-output .cell-output-display execution_count=279}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>`<span style=\"text-decoration:underline\">cat</span> <span style=\"text-decoration:underline\">text.txt</span>`</pre>\n```\n:::\n\n:::\n:::\n\n\nAs can be seen, this mechanism used here is the same one as is used in shell, so you can just copy and paste a valid shell commands into here, and it will works properly.\n\n##### Pipelines\n\nShell metacharacters, such as `|`, `&`, and `>`, need to be quoted (or escaped) inside of Julia's backticks:\n\n::: {#9ce279d0 .cell execution_count=325}\n``` {.julia .cell-code}\nrun(`echo hello \\| sort`)  # here, | is not a pipe, just a normal character\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nhello | sort\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=280}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>Process(`<span style=\"text-decoration:underline\">echo</span> <span style=\"text-decoration:underline\">hello</span> <span style=\"text-decoration:underline\">'|'</span> <span style=\"text-decoration:underline\">sort</span>`, ProcessExited(0))</pre>\n```\n:::\n\n:::\n:::\n\n\n1.  Use `pipeline()` to construct a pipe:\n\n::: {#e2652fc6 .cell execution_count=326}\n``` {.julia .cell-code}\nrun(pipeline(`cut -d : -f 3 /etc/passwd`, `head -n 6`, `sort -n`))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0\n1\n2\n3\n4\n5\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=281}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>Base.ProcessChain(Base.Process[Process(`<span style=\"text-decoration:underline\">cut</span> <span style=\"text-decoration:underline\">-d</span> <span style=\"text-decoration:underline\">:</span> <span style=\"text-decoration:underline\">-f</span> <span style=\"text-decoration:underline\">3</span> <span style=\"text-decoration:underline\">/etc/passwd</span>`, ProcessExited(0)), Process(`<span style=\"text-decoration:underline\">head</span> <span style=\"text-decoration:underline\">-n</span> <span style=\"text-decoration:underline\">6</span>`, ProcessExited(0)), Process(`<span style=\"text-decoration:underline\">sort</span> <span style=\"text-decoration:underline\">-n</span>`, ProcessExited(0))], Base.DevNull(), Base.DevNull(), Base.DevNull())</pre>\n```\n:::\n\n:::\n:::\n\n\n2.  Run multiple commands in parallel using `&`:\n\n::: {#e319bc67 .cell execution_count=327}\n``` {.julia .cell-code}\nrun(`echo hello` & `echo world` & `echo Tom`)  # the order of the output here is non-deterministic\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nhello\nworld\nTom\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=282}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>Base.ProcessChain(Base.Process[Process(`<span style=\"text-decoration:underline\">echo</span> <span style=\"text-decoration:underline\">hello</span>`, ProcessExited(0)), Process(`<span style=\"text-decoration:underline\">echo</span> <span style=\"text-decoration:underline\">world</span>`, ProcessExited(0)), Process(`<span style=\"text-decoration:underline\">echo</span> <span style=\"text-decoration:underline\">Tom</span>`, ProcessExited(0))], Base.DevNull(), Base.DevNull(), Base.DevNull())</pre>\n```\n:::\n\n:::\n:::\n\n\nCombine both `|` and `&`:\n\n::: {#541f69ce .cell execution_count=328}\n``` {.julia .cell-code}\nrun(pipeline(`echo world` & `echo hello`, `sort`))  # a single UNIX pipe is created and written to by both echo processes, and the other end of the pipe is read from by the sort command\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nhello\nworld\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=283}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>Base.ProcessChain(Base.Process[Process(`<span style=\"text-decoration:underline\">echo</span> <span style=\"text-decoration:underline\">world</span>`, ProcessExited(0)), Process(`<span style=\"text-decoration:underline\">echo</span> <span style=\"text-decoration:underline\">hello</span>`, ProcessExited(0)), Process(`<span style=\"text-decoration:underline\">sort</span>`, ProcessExited(0))], Base.DevNull(), Base.DevNull(), Base.DevNull())</pre>\n```\n:::\n\n:::\n:::\n\n\n::: {#1a8ed06a .cell execution_count=329}\n``` {.julia .cell-code}\nproducer() = `awk 'BEGIN{for (i = 0; i <= 6; i++) {print i; system(\"sleep 1\")}}'`\nconsumer(flag) = `awk '{print \"'$flag' \"$1; system(\"sleep 2\")}'`  # to make the interpolation $flag work, you have to put it between single quotes\nrun(pipeline(producer(), consumer(\"A\") & consumer(\"B\") & consumer(\"C\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nB 0\nA 1\nC 2\nB 3\nA 4\nC 5\nB 6\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=284}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>Base.ProcessChain(Base.Process[Process(`<span style=\"text-decoration:underline\">awk</span> <span style=\"text-decoration:underline\">'BEGIN{for (i = 0; i &lt;= 6; i++) {print i; system(\"sleep 1\")}}'</span>`, ProcessExited(0)), Process(`<span style=\"text-decoration:underline\">awk</span> <span style=\"text-decoration:underline\">'{print \"A \"$1; system(\"sleep 2\")}'</span>`, ProcessExited(0)), Process(`<span style=\"text-decoration:underline\">awk</span> <span style=\"text-decoration:underline\">'{print \"B \"$1; system(\"sleep 2\")}'</span>`, ProcessExited(0)), Process(`<span style=\"text-decoration:underline\">awk</span> <span style=\"text-decoration:underline\">'{print \"C \"$1; system(\"sleep 2\")}'</span>`, ProcessExited(0))], Base.DevNull(), Base.DevNull(), Base.DevNull())</pre>\n```\n:::\n\n:::\n:::\n\n\n## Julia documentation system\n\n::: {#23104459 .cell execution_count=330}\n``` {.julia .cell-code}\n\"Store propellant for a rocket\"\nabstract type OhTank end\n\n\"\"\"\n    total(t::OhTank) -> Float64\n\nMass of propellant tank `t` when it is full.\n\"\"\"\nfunction totalmass end\n```\n\n::: {.cell-output .cell-output-display execution_count=285}\n```\ntotalmass\n```\n:::\n:::\n\n\nThe Julia documentation system works by prefixing a function or type definition with a regular Julia text string, quoted by double or triple quotes. This is totally different from a comment with the `#` symbol. Comments don't get stored in the Julia help system.\n\nInside this text string, you can document your function or type definition using markdown syntax.\n\n## Modules and Pakcages\n\nThe core Julia language imposes very little; many functions are extended by modules and packages.\n\nJulia code is organized into files, modules, and packages. Files containing Julia code use the `.jl` file extension.\n\n### Modules\n\nModules help organize code into coherent units. They are delimited syntactically inside `module <NameOfModule> ... end`, and have the following features:\n\n1.  Modules are separate namespaces, each introducing a new global scope. This allows the same name to be used for different functions or global variables without conflict, as long as they are in separate modules.\n\n2.  Modules have facilities for detailed namespace management: each defines a set of names it exports, and can import names from other modules with `using` and `import`.\n\n3.  Modules can be precompiled for faster loading, and may contain code for runtime initialization.\n\nModule definition:\n\n::: {#8ecc6fbb .cell execution_count=331}\n``` {.julia .cell-code}\nmodule <NameOfModule>\n\n# using, import, export statements are usually here\n\ninclude(\"file1.jl\")\ninclude(\"file2.jl\")\n\nend\n```\n:::\n\n\n::: callout-note\n1.  Files and file names are mostly unrelated to modules, since modules are associated only with module expression. One can have multiple files per module, and multiple modules per file.\n\n2.  `include` behaves as if the contents of the source file were evaluated in the global scope of the including module.\n\n3.  The recommended style is not to indent the body of the module. It is also common to use `UpperCamelCase` for module names, and use the plural form if applicable.\n:::\n\n#### Namespace management\n\nNamespace management refers to the facilities the language offers for making names in a module available in other modules.\n\n##### Qualified names\n\nNames for functions, variables, and types in the global scope always belong to a module, called the parent module. One can use `parentmodule()` to find the parent module of a name.\n\nOne can also refer to those names outside their parent module by prefixing them with their module name, e.g. `Base.UnitRange`. This is called a qualified name.\n\nThe parent module may be accessible using a chain of submodules like `Base.Math.sin`, where `Base.Main` is called the module path.\n\nDue to syntactic ambiguities, qualifying a name that contains only symbols, such as an operator, requires inserting a colon, e.g. `Base.:+`. A small number of operators additionally require parentheses, e.g. `Base.:(==)`.\n\n##### Export lists\n\nNames can be added to the export list of a module with `export`: these are symbols that are imported when `using` the module.\n\n::: {#6993dce3 .cell execution_count=332}\n``` {.julia .cell-code}\nmodule NiceStuff\n\nexport nice, DOG\n\n# definitions of nice and DOG\n\nend\n```\n:::\n\n\nIn fact, a module can have multiple `export` statements in arbitrary locations.\n\n##### `using` and `import`\n\n1.  `using`: brings **the module name** and **the elements of the export list** into the surrounding global namespace.\n\n2.  `import`: brings only **the module name** into scope.\n\n::: callout-note\n1.  To load a module from a locally defined module, a dot needs to be added before the module name like `using .ModuleName`.\n\n2.  One can specify which identifiers to be loaded in a module, e.g., `using .NiceStuff: nice, DOG`.\n\n3.  Renaming imported identifiers with `as`.\n\n::: {#8da0c0d7 .cell execution_count=333}\n``` {.julia .cell-code}\nimport CSV as C  # This only works with import\nimport CSV: read as rd\nusing CSV: read as rd\n```\n:::\n\n\n:::\n\n#### How does Julia find a module\n\n1.  Julia looks for module files in directories defined in the `LOAD_PATH` variable:\n\n::: {#af492610 .cell execution_count=334}\n``` {.julia .cell-code}\nLOAD_PATH\n```\n\n::: {.cell-output .cell-output-display execution_count=286}\n```\n3-element Vector{String}:\n \"@\"\n \"@v#.#\"\n \"@stdlib\"\n```\n:::\n:::\n\n\n2.  To make it look in other places, add some more using `push!()`:\n\n::: {#69e7d8db .cell execution_count=335}\n``` {.julia .cell-code}\npush!(LOAD_PATH, \"/path/to/my/julia/projects\")\n```\n\n::: {.cell-output .cell-output-display execution_count=287}\n```\n4-element Vector{String}:\n \"@\"\n \"@v#.#\"\n \"@stdlib\"\n \"/path/to/my/julia/projects\"\n```\n:::\n:::\n\n\n::: callout-note\nTo avoid doing this every time you run Julia, put this line into your startup file `~/.julia/config/startup.jl`, which runs each time you start an interactive Julia session.\n:::\n\n3.  Julia looks for files in those directories in the form of a package with the structure: `ModuleName/src/file.jl`.\n\n4.  Or, if not in package form, it will look for a filename that matches the name of your module.\n\n### Standard modules\n\nThere are three most important modules:\n\n-   Core\n\nCore contains all identifiers considered \"built in\" to the language, i.e. part of the core language and not libraries.\n\nEevery module implicitly specifies `using Core`, since you cannot do anything without these definitions.\n\n-   Base\n\nBase contains basic functionality.\n\nAll modules implicitly contain `using Base`.\n\n-   Main\n\nMain is the top-level module, and Julia starts with Main set as the current module.\n\nVariables defined at the prompt go in Main, and `varinfo()` lists variables in Main.\n\n### Packages\n\nJulia uses **git** for organizing and controlling packages.\n\nBy convention, all packages are stored in git repositories.\n\n### Organizing your code into modules and packages\n\n#### Setting up your working environment\n\nIn Julia, different environments can have totally different packages and versions installed from another environment.\n\nThis makes it possible that you can construct an environment tailored to your project, which makes your project completely reproducible.\n\n::: {#93ee8f99 .cell execution_count=336}\n``` {.julia .cell-code}\n## Make the job directory in the shell mode\nshell> mkdir job\n\n## Activate the job environment in the package mode\n(@v1.10) pkg> activate job\n  Activating new project at `~/temp/job`\n\n## Add packages into the job environment\n(job) pkg> add CairoMakie ElectronDisplay\n\n## Check what packages are added into the job environment\n(job) pkg> status\nStatus `~/temp/job/Project.toml`\n  [13f3f980] CairoMakie v0.11.5\n  [d872a56f] ElectronDisplay v1.0.1\n\n## Julia adds packages into the job environment by adding information of packages into the following two files of the job environment:\n# 1. Project.toml: specifies what packages are added to this environment\n\nshell> cat Project.toml\n[deps]\nCairoMakie = \"13f3f980-e62b-5c42-98c6-ff1f3baf88f0\"  # The string is the universally unique identifier (UUID) of the CairoMakie package, which allows you to install different packages with the same package name. If there was another CairoMakie package, you should add this one with the command: add CairoMakie=13f3f980-e62b-5c42-98c6-ff1f3baf88f0\nElectronDisplay = \"d872a56f-244b-5cc9-b574-2017b5b909a8\"\n\n# 2. Manifest.toml: specifies the information of packages which those packages we just installed depend on\n\nshell> head Manifest.toml\n# This file is machine-generated - editing it directly is not advised\n\njulia_version = \"1.10.0\"\nmanifest_format = \"2.0\"\nproject_hash = \"666c5e651c78c84e1125a572f7fba0bc8b920e62\"\n\n[[deps.AbstractFFTs]]\ndeps = [\"LinearAlgebra\"]\ngit-tree-sha1 = \"d92ad398961a3ed262d8bf04a1a2b8340f915fef\"\nuuid = \"621f4979-c628-5d54-868e-fcf4e3e8185c\"\nversion = \"1.5.0\"\nweakdeps = [\"ChainRulesCore\", \"Test\"]\n\n    [deps.AbstractFFTs.extensions]\n    AbstractFFTsChainRulesCoreExt = \"ChainRulesCore\"\n    AbstractFFTsTestExt = \"Test\"\n\n[[deps.AbstractLattices]]\ngit-tree-sha1 = \"222ee9e50b98f51b5d78feb93dd928880df35f06\"\nuuid = \"398f06c4-4d28-53ec-89ca-5b2656b7603d\"\nversion = \"0.3.0\"\n```\n:::\n\n\nThese two files (`Project.toml` and `Manifest.toml`) are automatically created by Julia.\n\n#### Creating your own module and package\n\n::: {#18dd02d4 .cell execution_count=337}\n``` {.julia .cell-code}\nshell> cd job\n/home/yangrui/temp/job\n\nshell> tree\n.\n├── Manifest.toml\n└── Project.toml\n\n0 directories, 2 files\n\n## Create a package scaffolding with the `generate` command in the package mode\n# You can also use the PkgTemplate library to create peackages with a more sophisticated way\n(job) pkg> generate ToyPackage\n  Generating  project ToyPackage:\n    ToyPackage/Project.toml\n    ToyPackage/src/ToyPackage.jl\n\nshell> tree\n.\n├── Manifest.toml\n├── Project.toml\n└── ToyPackage\n    ├── Project.toml  # In fact, Julia package is also an environment, which means you can add other packages it depends on\n    └── src\n        └── ToyPackage.jl  # This file contains the top-level module having the same name as the package\n\n2 directories, 4 files\n\nshell> cat ToyPackage/src/ToyPackage.jl\nmodule ToyPackage  # You can now add code into this module (e.g. import names from other packages by using the `using` and `import` statements; specify what names should be exported by using the `export` statement; include other .jl files by using the `include()` function; you can also directly define variables, functions, types here)\n\ngreet() = print(\"Hello World!\")\n\nend # module ToyPackage\n\n## To make packages you are developing available when importing them by using the `using` and `import` statements, you can use the `dev` command to add your package info into the metadata files of the job environment\n(@v1.10) pkg> activate job\n  Activating new project at `~/temp/job/job`\n\nshell> ls\nManifest.toml  Project.toml  ToyPackage\n\n(job) pkg> dev ./ToyPackage\n   Resolving package versions...\n    Updating `~/temp/job/job/Project.toml`\n  [0bc4f551] + ToyPackage v0.1.0 `../ToyPackage`\n    Updating `~/temp/job/job/Manifest.toml`\n  [0bc4f551] + ToyPackage v0.1.0 `../ToyPackage`\n\n(job) pkg> status\nStatus `~/temp/job/job/Project.toml`\n  [0bc4f551] ToyPackage v0.1.0 `../ToyPackage`\n```\n:::\n\n\nTwo packages are very useful when modifying and developing packages:\n\n-   OhMyREPL: provides syntax highlighting and history matching in the Julia REPL;\n\n-   Revise: monitors code changes to packages loaded into the REPL and updates the REPL with these changes.\n\n#### Testing your package\n\nYou can use the Test package to test your package.\n\n::: {#522a6cd4 .cell execution_count=338}\n``` {.julia .cell-code}\n## In the ToyPackage/test/runtests.jl  # This is essential\nusing ToyPackage\nusing Test\n\n# Each test is contained in this block\n@testset \"All tests\" begin\n    include(\"trigtests.jl\")\nend\n\n## In the ToyPackage/test/trigtests.jl  # This is not essential if you write all tests into the above file\n@testset \"trigonometric tests\" begin\n    @test cos(0) = 1.0  # Each test starts with the macro @test. For floating-point numbers, the results may be not exactly identical, so you can use the ≈ (\\approx) or use the isapprox() function to specify the tolerance\n    @test sin(0) = 0.0\nend\n\n@testset \"polynomial tests\" begin\n    # Some more tests\nend\n\n## Test your package with the `test` command in the package mode\n(job) pkg> activate ToyPackage  # Of course, this is not essential. You can test the ToyPackage package in any enviroment which knows where this package is (e.g. in the job environment)\n  Activating project at `~/temp/job/ToyPackage`\n\n(ToyPackage) pkg> test ToyPackage  # If you are in the ToyPackage environment, only use the `test` command without the package name is fine\n```\n:::\n\n\n## Appendices\n\n### Heap and Stack\n\nHeap and stack are two important regions in computer **memory** used for storing data.\n\nThere are some differences between heap and stack:\n\n1.  **Heap:** the heap is a larger memory area that is **manually requested and released** by the programmer or the memory manager of a programming language. Memory allocation on the heap is more flexible and can be dynamically adjusted according to the needs of the program. However, since it requires tracking all allocated and released memory blocks, heap management is usually more complex and slower than stack management. **The heap is used to store objects whose size and lifetime are uncertain, such as dynamic arrays, object instances, etc.**\n2.  **Stack**: the stack is a memory area **managed automatically** by the operating system or runtime environment. It follows the Last In, First Out (LIFO) principle, meaning the last element entered is the first one to be removed. Memory allocation and deallocation on the stack are very fast because these operations only involve moving pointers, without the need for complex memory management algorithms. **The stack is typically used to store local variables and context information for function calls.**\n\nJulia stores **mutable data types in heap**, and **immutable data types in stack**, which means the memory address pointed to an immutable value, such as an integer, may be unstable (changed often). So In Julia, you can only reliably get the memory address of mutable data by the follows:\n\n::: {#8556bf63 .cell execution_count=339}\n``` {.julia .cell-code}\na = [1, 2, 3, 4, 5, 6]\n\np = pointer_from_objref(a)  # get the memory address of a Julia object as a Ptr (Ptr{T} means a memory address referring to data of type T)\nprintln(p)\n\nx = unsafe_pointer_to_objref(p)  # convert a Ptr to an object reference (assuming the pointer refers to a valid heap-allocated Julia object)\nprintln(x)\n\n# ===/≡ is used to judge whether two objects are identical:\n# first the types of the two are compared\n# then mutable objects are compared by memory address\n# and immutable objects are compared by contents at the bit level\nprintln(a === x)\n\n# if x === y then objectid(x) == objectid(y)\n\n# == is used to compare whether the contents of the two obejcts are identical though other properties may also be taken into account\nx = 1 # Int64\ny = 1.0  # Float64\nprintln(x === y)\nprintln(x == y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPtr{Nothing} @0x00007f9158e0f9d0\n[1, 2, 3, 4, 5, 6]\ntrue\nfalse\ntrue\n```\n:::\n:::\n\n\n### Julia installation and configuration\n\n1.  Setting some environmental variables globally and permanently\n\nCreating a `~/.julia/config/startup.jl` file with the contents:\n\n::: {#45b42567 .cell execution_count=340}\n``` {.julia .cell-code}\n# Customizing package server\nENV[\"JULIA_PKG_SERVER\"] = \"https://mirrors.pku.edu.cn/julia\"\n\n# Customizing https proxy\nENV[\"https_proxy\"] = \"http://127.0.0.1:10809\"\n```\n:::\n\n\n### Julia REPL mode\n\n-   `julia>`: the standard Julia mode.\n\n-   `help?>`: the help mode. Enter help mode by pressing `?`.\n\n-   `pkg>`: the package mode for installing and removing packages. Enter package mode by pressing `]`.\n\n-   `shell>`: the shell mode. Enter shell mode by pressing `;`.\n\nTo back to the standard Julia mode, press `Backspace`.\n\n### Installing third-party packages\n\nPkg is Julia's builtin package manager, which can be used to install, update, and remove packages.\n\nYou can install packages either by calling Pkg functions in the standard Julia mode or by executing Pkg commands in the package mode.\n\n-   In the package mode:\n\n::: {#d7f03a8b .cell execution_count=341}\n``` {.julia .cell-code}\n# To install packages (multiple packages are separated by comma or space), use add\n(@v1.9) pkg> add JSON, StaticArrays\n\n# To install packages with specified versions using the @ symbol\n(@v1.9) pkg> add CairoMakie@0.5.10\n\n# To remove packages, use rm or remove (some Pkg REPL commands have a short and a long version of the command)\n(@v1.9) pkg> rm JSON, StaticArrays\n\n# To update packages, use up or update\n(@v1.9) pkg> up\n\n# To see installed packages, use st or status\n(@v1.9) pkg> st\n```\n:::\n\n\n::: callout-note\nIn the REPL prompt, `(@v1.9)` lets you know that `v1.9` is the active environment.\n\nDifferent environments can have totally different packages and versions installed from another environment.\n\nThis makes it possible that you can construct an environment tailored to your project, which makes your project completely reproducible.\n:::\n\n-   In the standard Julia mode\n\n::: {#ab437a6e .cell execution_count=342}\n``` {.julia .cell-code}\njulia> Pkg.add([\"JSON\", \"StaticArrays\"])\n\n# Pkg.remove()\n# Pkg.update()\n# Pkg.status()\n```\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}
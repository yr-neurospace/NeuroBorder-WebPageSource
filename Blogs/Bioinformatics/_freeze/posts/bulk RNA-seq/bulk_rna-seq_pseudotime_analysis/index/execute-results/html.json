{
  "hash": "5fa9bc8dce4d93e585fca8b70c011ecd",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Bulk RNA-seq pseudotime analysis\"\nauthor: \"Rui Yang\"\ndate: \"2024-09-09\"\ndate-modified: last-modified\ncategories: [bulk rna-seq, pseudotime]\nformat:\n  html:\n    toc: true\n    toc-depth: 6\n    toc-location: left\n    fig-align: center\n    number-depth: 6\n    number-sections: true\n    fig-cap-location: bottom\n    fig-format: png\n    lightbox: true\n    tbl-cap-location: top\n    page-layout: full\n\nexecute:\n  warning: false\n---\n\n\n## Introduction\n\nIn scRNA-seq, various tools, such as Monocle3, provide the capability of performing pseudotime analysis. In brief, assume that there are both progenitors and more differentiated progenies in an scRNA-seq dataset. If we consider the most undeferentiated progenitors as the developmental origin (assigning them the number $0$), and the most differentiated progenies the developmental ends (assigning them the number 10), then we can assign each intermediate cell within them a number between $0$ and $10$. For cells with numbers approaching $0$ more, they are more similar with the progenitors in terms of their RNA expression patterns and vice versa. Once we assign each cell a number (i.e. a developmental pseudotime point) and order them based on their pseudotime, we can arrange highly variable genes based on their peaking expression patterns (i.e. genes with peaking expression patterns at early stages are placed at the left, etc.).\n\nIn bulk RNA-seq, the number of samples is far less than the number of cells in scRNA-seq, where each cell can be regarded as a sample, so the gene expression dynamics along the developmental stages are not so smooth (i.e. jagged) as we have seen in scRNA-seq if we do the same analysis in bulk RNA-seq as in scRNA-seq. Therefore, to make the gene expression dynamics smoother along the developmental stages, we need to obtain more pseudo/interpolated time points than those we have.\n\nBriefly, to achieve this goal, we need to do the following things:\n\n1. Define the time scale among developmental samples based on their mutual Euclidean distances calculated from their coordinates `(Dim.1, Dim.2)` obtained from their PCA space (i.e. consider the earliest sample as the developmental origin, assign it $0$, and for the remaining samples, use their Euclidean disntances accumulated from the origin as their developmental time points).\n\n2. Scale the time scale to `(0, 10)`.\n\n3. Fit a spline for each gene based its $(time, expression)$ pairs along the actual developmental stages, and use this fitted spline to interpolate more $(time, expression)$ pairs (using the `loess` method in `modelr` package).\n\n4. For each gene, obtain its PCA coordinate `(Dim.1, Dim.2)`, and then feed all possible signed combinations of `Dim.1` and `Dim.2` of all genes to `atan2` to get a sequence of values used to sort genes.\n\n5. Visualize gene expression dynamics along interpolated time points to pick the expected one.\n\n## Pipeline\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuppressWarnings(suppressMessages(library(vroom)))\nsuppressWarnings(suppressMessages(library(tidyverse)))\nsuppressWarnings(suppressMessages(library(ggplot2)))\nsuppressWarnings(suppressMessages(library(ggrepel)))\nsuppressWarnings(suppressMessages(library(magrittr)))\nsuppressWarnings(suppressMessages(library(FactoMineR)))\nsuppressWarnings(suppressMessages(library(ComplexHeatmap)))\nsuppressWarnings(suppressMessages(library(scales)))\nsuppressWarnings(suppressMessages(library(modelr)))\nsuppressWarnings(suppressMessages(library(RColorBrewer)))\nsuppressWarnings(suppressMessages(library(patchwork)))\nsuppressWarnings(suppressMessages(library(showtext)))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfont_family <- \"Arial\"\n\nfont_df <- filter(font_files(), family == font_family)\nfont_add(\n    family = font_family,\n    regular = if (\"Regular\" %in% font_df[[\"face\"]]) font_df[[\"file\"]][font_df[[\"face\"]] == \"Regular\"] else stop(\"no font file found\"),\n    bold = if (\"Bold\" %in% font_df[[\"face\"]]) font_df[[\"file\"]][font_df[[\"face\"]] == \"Bold\"] else NULL,\n    italic = if (\"Bold Italic\" %in% font_df[[\"face\"]]) font_df[[\"file\"]][font_df[[\"face\"]] == \"Bold Italic\"] else NULL,\n    bolditalic = if (\"Italic\" %in% font_df[[\"face\"]]) font_df[[\"file\"]][font_df[[\"face\"]] == \"Italic\"] else NULL\n)\nshowtext_auto()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# specify input gene expression matrix\n# containing one ID column named \"GeneID\"\n# the remaining columns are sample columns named in the form of \"SampleID.Replicate\" (e.g. Skin.1, Skin.2, etc.)\n# SampleID must not contain \".\"\n# Replicate must be one or more integers\nexpr_file <- \"./data/RNA_TPM.txt\"\n# specify the sample levels, reflecting their actual developmental stages\nsample_dev_order <- c(\"DAI0\", \"DAI3\", \"DAI6\", \"DAI9\", \"DAI12\")\ntime_points_num <- 500\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nexpr <- vroom(expr_file) %>%\n    as.data.frame() %>%\n    set_rownames(.[[\"GeneID\"]]) %>%\n    select(-all_of(\"GeneID\")) %>%\n    distinct()\nsample_df <- strsplit(names(expr), \".\", fixed = T) %>%\n    do.call(rbind, .) %>%\n    as.data.frame() %>%\n    set_colnames(c(\"SampleID\", \"Replicate\")) %>%\n    mutate(Sample = paste0(SampleID, \".\", Replicate))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# calculate the mean expression value of each gene within each sample\ndata <- data.frame(GeneID = row.names(expr))\nfor (id in unique(sample_df[[\"SampleID\"]])) {\n    id_reps <- filter(sample_df, SampleID == id) %>%\n        pull(Sample) %>%\n        unique()\n    id_mean_expr <- data.frame(Expr = rowMeans(expr[, id_reps]))\n    names(id_mean_expr) <- id\n    data <- bind_cols(data, id_mean_expr)\n}\ndata <- as.data.frame(data) %>%\n    set_rownames(.[[\"GeneID\"]]) %>%\n    select(-all_of(\"GeneID\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# use row variances to identify the top 3000 most variable genes\n# log2-trsanformation is recommended for reducing variance variation among genes\ndata <- log2(data + 1)\ndata[[\"var\"]] <- apply(data, 1, var)\ndata <- data %>%\n    arrange(desc(var)) %>%\n    slice_head(n = 3000) %>%\n    select(-all_of(\"var\"))\ndata <- data[, sample_dev_order]\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# perform PCA analysis over samples (samples as observations)\n# calculate Euclidean distances among samples based on their coordinates (Dim.1, Dim.2) in sample PCA space\n# obtain the developmental time scale by accumulating distances of mutual samples\nsample_pca <- PCA(t(data), scale.unit = T, ncp = 5, graph = F)\nsample_pca_coords <- sample_pca$ind$coord[, 1:2]\n\n# visualize sample positions in PCA space\nsample_pca_coords_vis <- as.data.frame(sample_pca_coords)\nsample_pca_coords_vis[[\"Sample\"]] <- row.names(sample_pca_coords_vis)\nsample_pca_eig_vis <- as.data.frame(sample_pca$eig)\n\nggplot(sample_pca_coords_vis, aes(Dim.1, Dim.2)) +\n    geom_point(size = 2) +\n    geom_text_repel(aes(label = Sample), size = 5, min.segment.length = 3) +\n    xlab(paste0(\"PC1 (\", round(sample_pca_eig_vis[\"comp 1\", \"percentage of variance\"]), \"%)\")) +\n    ylab(paste0(\"PC2 (\", round(sample_pca_eig_vis[\"comp 2\", \"percentage of variance\"]), \"%)\")) +\n    theme_bw() +\n    theme(\n        panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank(),\n        axis.title.x = element_text(size = 26),\n        axis.title.y = element_text(size = 26),\n        axis.text.x = element_text(size = 24),\n        axis.text.y = element_text(size = 24),\n        legend.text = element_text(size = 24),\n        legend.title = element_text(size = 26),\n        text = element_text(family = \"Arial\")\n    )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){fig-align='center'}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsample_dists <- as.matrix(dist(sample_pca_coords, method = \"euclidean\"))\n\n# visualize sample distances via heatmap\nHeatmap(sample_dists, cluster_rows = F, cluster_columns = F)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){fig-align='center'}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# calculate the developmental time scale by accumulating distances of mutual samples along the actual developmental stages\nraw_timeline <- cumsum(c(0, sapply(2:ncol(data), function(x) {\n    sample_dists[x - 1, x]\n})))\n# scale the raw time scale to (0, 10)\nnew_timeline <- scales::rescale(raw_timeline, to = c(0, 10))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# fit a spline for each gene and obtain 500 time points by interpolation\ndata_scale <- as.data.frame(t(scale(t(data))))\n\n# interpolate more time points (e.g., 500) to make the expression dynamics smoother along the developmental stages\n# based on the fitted spline for each gene (using the loess method in modelr package)\npseudotime_model_fun <- function(sample_value, sample_timeline, time_points_num = 500) {\n    grid <- data.frame(time = seq(0, 10, length.out = time_points_num))\n    data <- tibble(value = sample_value, time = sample_timeline)\n    model <- loess(value ~ time, data)\n    predict <- add_predictions(grid, model)\n    return(predict)\n}\n\npseudotime_model_res <- apply(data_scale, 1, pseudotime_model_fun, sample_timeline = new_timeline, time_points_num = time_points_num)\nres <- lapply(pseudotime_model_res, function(x) {\n    x[[\"pred\"]]\n}) %>%\n    do.call(rbind, .) %>%\n    as.data.frame() %>%\n    set_colnames(pseudotime_model_res[[1]][[\"time\"]])\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# perform PCA analysis over genes\n# use atan2 method to sort genes based on their coordinates (Dim.1, Dim.2) in gene PCA space\ngene_pca <- PCA(res, scale.unit = T, ncp = 5, graph = F)\ngene_pca_coords <- gene_pca$ind$coord[, 1:2]\nres <- bind_cols(res, gene_pca_coords)\n\n# we have four signed combinations of Dim.1 and Dim.2\nres[[\"atan2.1\"]] <- atan2(res[[\"Dim.1\"]], res[[\"Dim.2\"]])\nres[[\"atan2.2\"]] <- atan2(res[[\"Dim.1\"]], -res[[\"Dim.2\"]])\nres[[\"atan2.3\"]] <- atan2(-res[[\"Dim.1\"]], res[[\"Dim.2\"]])\nres[[\"atan2.4\"]] <- atan2(-res[[\"Dim.1\"]], -res[[\"Dim.2\"]])\n\n# sort genes based on their atan2 values in ascending order\nres_order1 <- arrange(res, res[[\"atan2.1\"]])\nres_order2 <- arrange(res, res[[\"atan2.2\"]])\nres_order3 <- arrange(res, res[[\"atan2.3\"]])\nres_order4 <- arrange(res, res[[\"atan2.4\"]])\n\n# pick the expected one\np1 <- Heatmap(as.matrix(res_order1[, 1:time_points_num]),\n    cluster_rows = F,\n    cluster_columns = F,\n    show_row_names = F,\n    show_column_names = F,\n    column_title = \"Order1\",\n    heatmap_legend_param = list(title = \"Order1\", legend_height = unit(2, \"cm\")),\n    col = colorRampPalette(rev(brewer.pal(n = 11, name = \"RdYlBu\")))(100)\n)\np2 <- Heatmap(as.matrix(res_order2[, 1:time_points_num]),\n    cluster_rows = F,\n    cluster_columns = F,\n    show_row_names = F,\n    show_column_names = F,\n    column_title = \"Order2\",\n    heatmap_legend_param = list(title = \"Order2\", legend_height = unit(2, \"cm\")),\n    col = colorRampPalette(rev(brewer.pal(n = 11, name = \"RdYlBu\")))(100)\n)\np3 <- Heatmap(as.matrix(res_order3[, 1:time_points_num]),\n    cluster_rows = F,\n    cluster_columns = F,\n    show_row_names = F,\n    show_column_names = F,\n    column_title = \"Order3\",\n    heatmap_legend_param = list(title = \"Order3\", legend_height = unit(2, \"cm\")),\n    col = colorRampPalette(rev(brewer.pal(n = 11, name = \"RdYlBu\")))(100)\n)\np4 <- Heatmap(as.matrix(res_order4[, 1:time_points_num]),\n    cluster_rows = F,\n    cluster_columns = F,\n    show_row_names = F,\n    show_column_names = F,\n    column_title = \"Order4\",\n    heatmap_legend_param = list(title = \"Order4\", legend_height = unit(2, \"cm\")),\n    col = colorRampPalette(rev(brewer.pal(n = 11, name = \"RdYlBu\")))(100)\n)\n\np1 + p2 + p3 + p4\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){fig-align='center'}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
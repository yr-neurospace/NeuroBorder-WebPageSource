[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bioinformatics",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nIdentify housekeeping genes\n\n\n\n\n\n\nbulk rna-seq\n\n\nhousekeeping genes\n\n\n\n\n\n\n\n\n\nSep 18, 2024\n\n\nRui Yang\n\n\n\n\n\n\n\n\n\n\n\n\nBulk RNA-seq pseudotime analysis\n\n\n\n\n\n\nbulk rna-seq\n\n\npseudotime\n\n\n\n\n\n\n\n\n\nSep 9, 2024\n\n\nRui Yang\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/bulk RNA-seq/bulk_rna-seq_pseudotime_analysis/index.html",
    "href": "posts/bulk RNA-seq/bulk_rna-seq_pseudotime_analysis/index.html",
    "title": "Bulk RNA-seq pseudotime analysis",
    "section": "",
    "text": "In scRNA-seq, various tools, such as Monocle3, provide the capability of performing pseudotime analysis. In brief, assume that there are both progenitors and more differentiated progenies in an scRNA-seq dataset. If we consider the most undeferentiated progenitors as the developmental origin (assigning them the number \\(0\\)), and the most differentiated progenies the developmental ends (assigning them the number 10), then we can assign each intermediate cell within them a number between \\(0\\) and \\(10\\). For cells with numbers approaching \\(0\\) more, they are more similar with the progenitors in terms of their RNA expression patterns and vice versa. Once we assign each cell a number (i.e. a developmental pseudotime point) and order them based on their pseudotime, we can arrange highly variable genes based on their peaking expression patterns (i.e. genes with peaking expression patterns at early stages are placed at the left, etc.).\nIn bulk RNA-seq, the number of samples is far less than the number of cells in scRNA-seq, where each cell can be regarded as a sample, so the gene expression dynamics along the developmental stages are not so smooth (i.e. jagged) as we have seen in scRNA-seq if we do the same analysis in bulk RNA-seq as in scRNA-seq. Therefore, to make the gene expression dynamics smoother along the developmental stages, we need to obtain more pseudo/interpolated time points than those we have.\nBriefly, to achieve this goal, we need to do the following things:\n\nDefine the time scale among developmental samples based on their mutual Euclidean distances calculated from their coordinates (Dim.1, Dim.2) obtained from their PCA space (i.e. consider the earliest sample as the developmental origin, assign it \\(0\\), and for the remaining samples, use their Euclidean disntances accumulated from the origin as their developmental time points).\nScale the time scale to (0, 10).\nFit a spline for each gene based its \\((time, expression)\\) pairs along the actual developmental stages, and use this fitted spline to interpolate more \\((time, expression)\\) pairs (using the loess method in modelr package).\nFor each gene, obtain its PCA coordinate (Dim.1, Dim.2), and then feed all possible signed combinations of Dim.1 and Dim.2 of all genes to atan2 to get a sequence of values used to sort genes.\nVisualize gene expression dynamics along interpolated time points to pick the expected one."
  },
  {
    "objectID": "posts/bulk RNA-seq/bulk_rna-seq_pseudotime_analysis/index.html#introduction",
    "href": "posts/bulk RNA-seq/bulk_rna-seq_pseudotime_analysis/index.html#introduction",
    "title": "Bulk RNA-seq pseudotime analysis",
    "section": "",
    "text": "In scRNA-seq, various tools, such as Monocle3, provide the capability of performing pseudotime analysis. In brief, assume that there are both progenitors and more differentiated progenies in an scRNA-seq dataset. If we consider the most undeferentiated progenitors as the developmental origin (assigning them the number \\(0\\)), and the most differentiated progenies the developmental ends (assigning them the number 10), then we can assign each intermediate cell within them a number between \\(0\\) and \\(10\\). For cells with numbers approaching \\(0\\) more, they are more similar with the progenitors in terms of their RNA expression patterns and vice versa. Once we assign each cell a number (i.e. a developmental pseudotime point) and order them based on their pseudotime, we can arrange highly variable genes based on their peaking expression patterns (i.e. genes with peaking expression patterns at early stages are placed at the left, etc.).\nIn bulk RNA-seq, the number of samples is far less than the number of cells in scRNA-seq, where each cell can be regarded as a sample, so the gene expression dynamics along the developmental stages are not so smooth (i.e. jagged) as we have seen in scRNA-seq if we do the same analysis in bulk RNA-seq as in scRNA-seq. Therefore, to make the gene expression dynamics smoother along the developmental stages, we need to obtain more pseudo/interpolated time points than those we have.\nBriefly, to achieve this goal, we need to do the following things:\n\nDefine the time scale among developmental samples based on their mutual Euclidean distances calculated from their coordinates (Dim.1, Dim.2) obtained from their PCA space (i.e. consider the earliest sample as the developmental origin, assign it \\(0\\), and for the remaining samples, use their Euclidean disntances accumulated from the origin as their developmental time points).\nScale the time scale to (0, 10).\nFit a spline for each gene based its \\((time, expression)\\) pairs along the actual developmental stages, and use this fitted spline to interpolate more \\((time, expression)\\) pairs (using the loess method in modelr package).\nFor each gene, obtain its PCA coordinate (Dim.1, Dim.2), and then feed all possible signed combinations of Dim.1 and Dim.2 of all genes to atan2 to get a sequence of values used to sort genes.\nVisualize gene expression dynamics along interpolated time points to pick the expected one."
  },
  {
    "objectID": "posts/bulk RNA-seq/bulk_rna-seq_pseudotime_analysis/index.html#pipeline",
    "href": "posts/bulk RNA-seq/bulk_rna-seq_pseudotime_analysis/index.html#pipeline",
    "title": "Bulk RNA-seq pseudotime analysis",
    "section": "2 Pipeline",
    "text": "2 Pipeline\n\nsuppressWarnings(suppressMessages(library(vroom)))\nsuppressWarnings(suppressMessages(library(tidyverse)))\nsuppressWarnings(suppressMessages(library(ggplot2)))\nsuppressWarnings(suppressMessages(library(ggrepel)))\nsuppressWarnings(suppressMessages(library(magrittr)))\nsuppressWarnings(suppressMessages(library(FactoMineR)))\nsuppressWarnings(suppressMessages(library(ComplexHeatmap)))\nsuppressWarnings(suppressMessages(library(scales)))\nsuppressWarnings(suppressMessages(library(modelr)))\nsuppressWarnings(suppressMessages(library(RColorBrewer)))\nsuppressWarnings(suppressMessages(library(patchwork)))\nsuppressWarnings(suppressMessages(library(showtext)))\n\n\nfont_family &lt;- \"Arial\"\n\nfont_df &lt;- filter(font_files(), family == font_family)\nfont_add(\n    family = font_family,\n    regular = if (\"Regular\" %in% font_df[[\"face\"]]) font_df[[\"file\"]][font_df[[\"face\"]] == \"Regular\"] else stop(\"no font file found\"),\n    bold = if (\"Bold\" %in% font_df[[\"face\"]]) font_df[[\"file\"]][font_df[[\"face\"]] == \"Bold\"] else NULL,\n    italic = if (\"Bold Italic\" %in% font_df[[\"face\"]]) font_df[[\"file\"]][font_df[[\"face\"]] == \"Bold Italic\"] else NULL,\n    bolditalic = if (\"Italic\" %in% font_df[[\"face\"]]) font_df[[\"file\"]][font_df[[\"face\"]] == \"Italic\"] else NULL\n)\nshowtext_auto()\n\n\n# specify input gene expression matrix\n# containing one ID column named \"GeneID\"\n# the remaining columns are sample columns named in the form of \"SampleID.Replicate\" (e.g. Skin.1, Skin.2, etc.)\n# SampleID must not contain \".\"\n# Replicate must be one or more integers\nexpr_file &lt;- \"./data/RNA_TPM.txt\"\n# specify the sample levels, reflecting their actual developmental stages\nsample_dev_order &lt;- c(\"DAI0\", \"DAI3\", \"DAI6\", \"DAI9\", \"DAI12\")\ntime_points_num &lt;- 500\n\n\nexpr &lt;- vroom(expr_file) %&gt;%\n    as.data.frame() %&gt;%\n    set_rownames(.[[\"GeneID\"]]) %&gt;%\n    select(-all_of(\"GeneID\")) %&gt;%\n    distinct()\nsample_df &lt;- strsplit(names(expr), \".\", fixed = T) %&gt;%\n    do.call(rbind, .) %&gt;%\n    as.data.frame() %&gt;%\n    set_colnames(c(\"SampleID\", \"Replicate\")) %&gt;%\n    mutate(Sample = paste0(SampleID, \".\", Replicate))\n\n\n# calculate the mean expression value of each gene within each sample\ndata &lt;- data.frame(GeneID = row.names(expr))\nfor (id in unique(sample_df[[\"SampleID\"]])) {\n    id_reps &lt;- filter(sample_df, SampleID == id) %&gt;%\n        pull(Sample) %&gt;%\n        unique()\n    id_mean_expr &lt;- data.frame(Expr = rowMeans(expr[, id_reps]))\n    names(id_mean_expr) &lt;- id\n    data &lt;- bind_cols(data, id_mean_expr)\n}\ndata &lt;- as.data.frame(data) %&gt;%\n    set_rownames(.[[\"GeneID\"]]) %&gt;%\n    select(-all_of(\"GeneID\"))\n\n\n# use row variances to identify the top 3000 most variable genes\n# log2-trsanformation is recommended for reducing variance variation among genes\ndata &lt;- log2(data + 1)\ndata[[\"var\"]] &lt;- apply(data, 1, var)\ndata &lt;- data %&gt;%\n    arrange(desc(var)) %&gt;%\n    slice_head(n = 3000) %&gt;%\n    select(-all_of(\"var\"))\ndata &lt;- data[, sample_dev_order]\n\n\n# perform PCA analysis over samples (samples as observations)\n# calculate Euclidean distances among samples based on their coordinates (Dim.1, Dim.2) in sample PCA space\n# obtain the developmental time scale by accumulating distances of mutual samples\nsample_pca &lt;- PCA(t(data), scale.unit = T, ncp = 5, graph = F)\nsample_pca_coords &lt;- sample_pca$ind$coord[, 1:2]\n\n# visualize sample positions in PCA space\nsample_pca_coords_vis &lt;- as.data.frame(sample_pca_coords)\nsample_pca_coords_vis[[\"Sample\"]] &lt;- row.names(sample_pca_coords_vis)\nsample_pca_eig_vis &lt;- as.data.frame(sample_pca$eig)\n\nggplot(sample_pca_coords_vis, aes(Dim.1, Dim.2)) +\n    geom_point(size = 2) +\n    geom_text_repel(aes(label = Sample), size = 5, min.segment.length = 3) +\n    xlab(paste0(\"PC1 (\", round(sample_pca_eig_vis[\"comp 1\", \"percentage of variance\"]), \"%)\")) +\n    ylab(paste0(\"PC2 (\", round(sample_pca_eig_vis[\"comp 2\", \"percentage of variance\"]), \"%)\")) +\n    theme_bw() +\n    theme(\n        panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank(),\n        axis.title.x = element_text(size = 26),\n        axis.title.y = element_text(size = 26),\n        axis.text.x = element_text(size = 24),\n        axis.text.y = element_text(size = 24),\n        legend.text = element_text(size = 24),\n        legend.title = element_text(size = 26),\n        text = element_text(family = \"Arial\")\n    )\n\n\n\n\n\n\n\n\n\nsample_dists &lt;- as.matrix(dist(sample_pca_coords, method = \"euclidean\"))\n\n# visualize sample distances via heatmap\nHeatmap(sample_dists, cluster_rows = F, cluster_columns = F)\n\n\n\n\n\n\n\n\n\n# calculate the developmental time scale by accumulating distances of mutual samples along the actual developmental stages\nraw_timeline &lt;- cumsum(c(0, sapply(2:ncol(data), function(x) {\n    sample_dists[x - 1, x]\n})))\n# scale the raw time scale to (0, 10)\nnew_timeline &lt;- scales::rescale(raw_timeline, to = c(0, 10))\n\n\n# fit a spline for each gene and obtain 500 time points by interpolation\ndata_scale &lt;- as.data.frame(t(scale(t(data))))\n\n# interpolate more time points (e.g., 500) to make the expression dynamics smoother along the developmental stages\n# based on the fitted spline for each gene (using the loess method in modelr package)\npseudotime_model_fun &lt;- function(sample_value, sample_timeline, time_points_num = 500) {\n    grid &lt;- data.frame(time = seq(0, 10, length.out = time_points_num))\n    data &lt;- tibble(value = sample_value, time = sample_timeline)\n    model &lt;- loess(value ~ time, data)\n    predict &lt;- add_predictions(grid, model)\n    return(predict)\n}\n\npseudotime_model_res &lt;- apply(data_scale, 1, pseudotime_model_fun, sample_timeline = new_timeline, time_points_num = time_points_num)\nres &lt;- lapply(pseudotime_model_res, function(x) {\n    x[[\"pred\"]]\n}) %&gt;%\n    do.call(rbind, .) %&gt;%\n    as.data.frame() %&gt;%\n    set_colnames(pseudotime_model_res[[1]][[\"time\"]])\n\n\n# perform PCA analysis over genes\n# use atan2 method to sort genes based on their coordinates (Dim.1, Dim.2) in gene PCA space\ngene_pca &lt;- PCA(res, scale.unit = T, ncp = 5, graph = F)\ngene_pca_coords &lt;- gene_pca$ind$coord[, 1:2]\nres &lt;- bind_cols(res, gene_pca_coords)\n\n# we have four signed combinations of Dim.1 and Dim.2\nres[[\"atan2.1\"]] &lt;- atan2(res[[\"Dim.1\"]], res[[\"Dim.2\"]])\nres[[\"atan2.2\"]] &lt;- atan2(res[[\"Dim.1\"]], -res[[\"Dim.2\"]])\nres[[\"atan2.3\"]] &lt;- atan2(-res[[\"Dim.1\"]], res[[\"Dim.2\"]])\nres[[\"atan2.4\"]] &lt;- atan2(-res[[\"Dim.1\"]], -res[[\"Dim.2\"]])\n\n# sort genes based on their atan2 values in ascending order\nres_order1 &lt;- arrange(res, res[[\"atan2.1\"]])\nres_order2 &lt;- arrange(res, res[[\"atan2.2\"]])\nres_order3 &lt;- arrange(res, res[[\"atan2.3\"]])\nres_order4 &lt;- arrange(res, res[[\"atan2.4\"]])\n\n# pick the expected one\np1 &lt;- Heatmap(as.matrix(res_order1[, 1:time_points_num]),\n    cluster_rows = F,\n    cluster_columns = F,\n    show_row_names = F,\n    show_column_names = F,\n    column_title = \"Order1\",\n    heatmap_legend_param = list(title = \"Order1\", legend_height = unit(2, \"cm\")),\n    col = colorRampPalette(rev(brewer.pal(n = 11, name = \"RdYlBu\")))(100)\n)\np2 &lt;- Heatmap(as.matrix(res_order2[, 1:time_points_num]),\n    cluster_rows = F,\n    cluster_columns = F,\n    show_row_names = F,\n    show_column_names = F,\n    column_title = \"Order2\",\n    heatmap_legend_param = list(title = \"Order2\", legend_height = unit(2, \"cm\")),\n    col = colorRampPalette(rev(brewer.pal(n = 11, name = \"RdYlBu\")))(100)\n)\np3 &lt;- Heatmap(as.matrix(res_order3[, 1:time_points_num]),\n    cluster_rows = F,\n    cluster_columns = F,\n    show_row_names = F,\n    show_column_names = F,\n    column_title = \"Order3\",\n    heatmap_legend_param = list(title = \"Order3\", legend_height = unit(2, \"cm\")),\n    col = colorRampPalette(rev(brewer.pal(n = 11, name = \"RdYlBu\")))(100)\n)\np4 &lt;- Heatmap(as.matrix(res_order4[, 1:time_points_num]),\n    cluster_rows = F,\n    cluster_columns = F,\n    show_row_names = F,\n    show_column_names = F,\n    column_title = \"Order4\",\n    heatmap_legend_param = list(title = \"Order4\", legend_height = unit(2, \"cm\")),\n    col = colorRampPalette(rev(brewer.pal(n = 11, name = \"RdYlBu\")))(100)\n)\n\np1 + p2 + p3 + p4"
  },
  {
    "objectID": "posts/bulk RNA-seq/identify_housekeeping_genes/index.html",
    "href": "posts/bulk RNA-seq/identify_housekeeping_genes/index.html",
    "title": "Identify housekeeping genes",
    "section": "",
    "text": "In brief, housekeeping genes are those with higher expression levels, low variances, and ubiquitous expression profiles across samples and species.\nIn paper “What are housekeeping genes” by Chintan J. Joshi, housekeeping genes are defined as those with the following four properties:\n\nHigher expression stability\nCellular maintenance\nEssentiality\nConservation"
  },
  {
    "objectID": "posts/bulk RNA-seq/identify_housekeeping_genes/index.html#methods-overview",
    "href": "posts/bulk RNA-seq/identify_housekeeping_genes/index.html#methods-overview",
    "title": "Identify housekeeping genes",
    "section": "",
    "text": "In brief, housekeeping genes are those with higher expression levels, low variances, and ubiquitous expression profiles across samples and species.\nIn paper “What are housekeeping genes” by Chintan J. Joshi, housekeeping genes are defined as those with the following four properties:\n\nHigher expression stability\nCellular maintenance\nEssentiality\nConservation"
  },
  {
    "objectID": "posts/bulk RNA-seq/identify_housekeeping_genes/index.html#method-1",
    "href": "posts/bulk RNA-seq/identify_housekeeping_genes/index.html#method-1",
    "title": "Identify housekeeping genes",
    "section": "2 Method 1",
    "text": "2 Method 1\nFrom “A Comprehensive Mouse Transcriptomic BodyMap across 17 Tissues by RNA-seq” by Bin Li.\nCriteria for identification of housekeeping genes:\n\nHighly expressed in all biological samples (\\(FPKM &gt; 1\\));\nLow variance across tissues: std(log2(FPKM)) &lt; 1;\nNo logarithmic expression value differed from the averaged log2(FPKM) value by a factor of two (i.e. fourfold) or more.\n\nCriteria for identification of reference genes:\n\n\\(FPKM &gt; 50\\) across all biological samples;\nstd(log2(FPKM)) &lt; 0.5 over tissues;\nNo logarithmic expression value differed from the averaged log2(FPKM) value by a factor of one (i.e. twofold) or more."
  },
  {
    "objectID": "posts/bulk RNA-seq/identify_housekeeping_genes/index.html#method-2",
    "href": "posts/bulk RNA-seq/identify_housekeeping_genes/index.html#method-2",
    "title": "Identify housekeeping genes",
    "section": "3 Method 2",
    "text": "3 Method 2\nFrom “Housekeeping protein‑coding genes interrogated with tissue and individual variations” by Kuo‑FengTung.\nGini coefficient of inequality (Gini index):\n\n\\(TPM &gt; 0.05\\);\n\\(\\text{Gini index} &lt; 0.2\\)."
  },
  {
    "objectID": "posts/bulk RNA-seq/identify_housekeeping_genes/index.html#method-3",
    "href": "posts/bulk RNA-seq/identify_housekeeping_genes/index.html#method-3",
    "title": "Identify housekeeping genes",
    "section": "4 Method 3",
    "text": "4 Method 3\nFrom “The evolution of gene expression levels in mammalian organs” by David Brawand.\nPipeline used to pick housekeeping genes and normalize expression levels across species:\n\nConvert TPM to \\(log2(TPM+1)\\);\nRetrieve and only keep one-to-one orthologous genes across all species with confidence equal to \\(1\\) from Ensembl BioMart;\nSort orthologs based on TPMs in descending order and represent each gene by its TPM rank in each sample;\nCalculate the standard deviation and median of each ortholog based on its ranks across samples;\nKeep orthologs the medians of which are within \\(0.25 \\times \\text{the number of orthologs} \\sim 0.75 \\times \\text{the number of orthologs}\\) (discarding those orthologs with expression levels extremely high or extremely low across samples);\nRetain the \\(1000\\) orthologs with the lower variances (standard deviations);\nCalculate the medians of those \\(1000\\) orthologs’ TPMs in each sample;\nCalculate the scaling factor of each sample: the scaling factor of sample A = TPM median of sample A / median(TPM median of all samples);\nFor each sample, scaled TPM = TPM / scaling factor.\n\nNote: be aware of the fact that the expression difference of each same/homologous gene among species and the difference among batches are different."
  },
  {
    "objectID": "posts/bulk RNA-seq/identify_housekeeping_genes/index.html#reference-datasets",
    "href": "posts/bulk RNA-seq/identify_housekeeping_genes/index.html#reference-datasets",
    "title": "Identify housekeeping genes",
    "section": "5 Reference datasets",
    "text": "5 Reference datasets\nHuman housekeeping genes: https://www.gsea-msigdb.org/gsea/msigdb/cards/HOUNKPE_HOUSEKEEPING_GENES.html.\nMouse housekeeping genes: https://www.gsea-msigdb.org/gsea/msigdb/mouse/geneset/HOUNKPE_HOUSEKEEPING_GENES.html."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Bioinformatics",
    "section": "",
    "text": "Here is a collection of blogs related to bioinfomatics, such as bulk RNA-seq, scRNA-seq, etc.\nEmail: 2413667864@qq.com"
  }
]
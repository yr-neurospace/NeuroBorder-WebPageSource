[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Computer",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nGit syntax basics\n\n\n\n\n\n\ngit\n\n\nsyntax\n\n\n\n\n\n\n\n\n\nSep 22, 2024\n\n\nRui Yang\n\n\n\n\n\n\n\n\n\n\n\n\nJulia resource list\n\n\n\n\n\n\njulia\n\n\nresource\n\n\n\n\n\n\n\n\n\nSep 22, 2024\n\n\nRui Yang\n\n\n\n\n\n\n\n\n\n\n\n\nJulia syntax basics\n\n\n\n\n\n\nsyntax\n\n\njulia\n\n\n\n\n\n\n\n\n\nSep 22, 2024\n\n\nRui Yang\n\n\n\n\n\n\n\n\n\n\n\n\nR resource list\n\n\n\n\n\n\nr\n\n\nresource\n\n\n\n\n\n\n\n\n\nSep 22, 2024\n\n\nRui Yang\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/Programming/R/r_resource_list/index.html",
    "href": "posts/Programming/R/r_resource_list/index.html",
    "title": "R resource list",
    "section": "",
    "text": "Official documentations at https://cran.r-project.org/manuals.html.\nHands-on programming with R by Garrett Grolemund at https://rstudio-education.github.io/hopr.\nAdvanced R by Hadley Wickham at https://adv-r.hadley.nz/."
  },
  {
    "objectID": "posts/Programming/R/r_resource_list/index.html#get-started",
    "href": "posts/Programming/R/r_resource_list/index.html#get-started",
    "title": "R resource list",
    "section": "",
    "text": "Official documentations at https://cran.r-project.org/manuals.html.\nHands-on programming with R by Garrett Grolemund at https://rstudio-education.github.io/hopr.\nAdvanced R by Hadley Wickham at https://adv-r.hadley.nz/."
  },
  {
    "objectID": "posts/Programming/R/r_resource_list/index.html#tidyverse-series-packages",
    "href": "posts/Programming/R/r_resource_list/index.html#tidyverse-series-packages",
    "title": "R resource list",
    "section": "2 Tidyverse series packages",
    "text": "2 Tidyverse series packages\nA collection of packages for data science at https://github.com/tidyverse.\nIncluding:\n\nI/O of delimited data: vroom, readr.\nGiving you a modern data frame: tibble.\nData manipulation: dplyr.\nGiving you tidy data: tidyr.\nWorking with strings: stringr.\nWorking with factors: forcats.\nWorking with functions and vectors: purrr.\nWorking with dates and date-times: lubridate.\nWorking with time-of-day values: hms.\nWorking with binary data: blob.\nWorking with pipes: magrittr.\nFormatting your strings: glue.\nData visualization with 2D plot: ggplot2 at https://ggplot2-book.org."
  },
  {
    "objectID": "posts/Programming/R/r_resource_list/index.html#bioconductor-series-packages",
    "href": "posts/Programming/R/r_resource_list/index.html#bioconductor-series-packages",
    "title": "R resource list",
    "section": "3 Bioconductor series packages",
    "text": "3 Bioconductor series packages\nA collection of packages for bioinfomatics at https://bioconductor.org."
  },
  {
    "objectID": "posts/Programming/R/r_resource_list/index.html#futureverse-series-packages",
    "href": "posts/Programming/R/r_resource_list/index.html#futureverse-series-packages",
    "title": "R resource list",
    "section": "4 Futureverse series packages",
    "text": "4 Futureverse series packages\nA unifying parallelization framework at https://www.futureverse.org/."
  },
  {
    "objectID": "posts/Programming/Julia/julia_resource_list/index.html",
    "href": "posts/Programming/Julia/julia_resource_list/index.html",
    "title": "Julia resource list",
    "section": "",
    "text": "Julia as a second language by Erik Engheim.\nJulia language guide by Dongfeng Li at https://www.math.pku.edu.cn/teachers/lidf/docs/Julia/html/_book/index.html.\nJulia official documentation at https://docs.julialang.org/en/v1."
  },
  {
    "objectID": "posts/Programming/Julia/julia_resource_list/index.html#get-started",
    "href": "posts/Programming/Julia/julia_resource_list/index.html#get-started",
    "title": "Julia resource list",
    "section": "",
    "text": "Julia as a second language by Erik Engheim.\nJulia language guide by Dongfeng Li at https://www.math.pku.edu.cn/teachers/lidf/docs/Julia/html/_book/index.html.\nJulia official documentation at https://docs.julialang.org/en/v1."
  },
  {
    "objectID": "posts/Programming/Julia/julia_resource_list/index.html#julia-for-data-science",
    "href": "posts/Programming/Julia/julia_resource_list/index.html#julia-for-data-science",
    "title": "Julia resource list",
    "section": "2 Julia for data science",
    "text": "2 Julia for data science\n\nJulia language guide by Dongfeng Li at https://www.math.pku.edu.cn/teachers/lidf/docs/Julia/html/_book/index.html.\nJulia data science at https://juliadatascience.io."
  },
  {
    "objectID": "posts/Programming/Git/git_syntax_basics/index.html",
    "href": "posts/Programming/Git/git_syntax_basics/index.html",
    "title": "Git syntax basics",
    "section": "",
    "text": "Set the user name and email address\n\ngit config --global user.name \"Rui Yang\"\ngit config --global user.email \"neurospace@petalmail.com\"\n\nImprove the output readability\n\ngit config --global color.ui auto\nThese settings will be stored in the file ~/.gitconfig in the following form:\n[user]\n        name = Rui Yang\n        email = neurospace@petalmail.com\n[color]\n        ui = auto"
  },
  {
    "objectID": "posts/Programming/Git/git_syntax_basics/index.html#git-initial-settings",
    "href": "posts/Programming/Git/git_syntax_basics/index.html#git-initial-settings",
    "title": "Git syntax basics",
    "section": "",
    "text": "Set the user name and email address\n\ngit config --global user.name \"Rui Yang\"\ngit config --global user.email \"neurospace@petalmail.com\"\n\nImprove the output readability\n\ngit config --global color.ui auto\nThese settings will be stored in the file ~/.gitconfig in the following form:\n[user]\n        name = Rui Yang\n        email = neurospace@petalmail.com\n[color]\n        ui = auto"
  },
  {
    "objectID": "posts/Programming/Git/git_syntax_basics/index.html#github-initial-settings",
    "href": "posts/Programming/Git/git_syntax_basics/index.html#github-initial-settings",
    "title": "Git syntax basics",
    "section": "2 GitHub initial settings",
    "text": "2 GitHub initial settings\n\nSet SSH key\n\n# don't forget to enter passphrase\nssh-keygen -t rsa -C \"neurospace@petalmail.com\"\nThis command will create two files id_rsa (private key), and id_rsa.pub (public key) under ~/.ssh.\n\nAdd id_rsa.pub to GitHub\nValidate your settings\n\nssh -T git@github.com\n\nThen you can use SSH key to clone and push a repository from and to GitHub\n\ngit clone git@github.com:yr-neurospace/YRUtils.jl.git"
  },
  {
    "objectID": "posts/Programming/Git/git_syntax_basics/index.html#git-operations",
    "href": "posts/Programming/Git/git_syntax_basics/index.html#git-operations",
    "title": "Git syntax basics",
    "section": "3 Git operations",
    "text": "3 Git operations\n\n3.1 Basic operations\n\ngit init —— initialize a repository\n\n# create a directory first\nmkdir git-tutorial\ncd git-tutorial\n# initialize a repository\n# this will create a .git directory in the curent working directory\n# it records all needed for managing this repository\ngit init\n\n# 提示：使用 'master' 作为初始分支的名称。这个默认分支名称可能会更改。要在新仓库中\n# 提示：配置使用初始分支名，并消除这条警告，请执行：\n# 提示：\n# 提示：  git config --global init.defaultBranch &lt;名称&gt;\n# 提示：\n# 提示：除了 'master' 之外，通常选定的名字有 'main'、'trunk' 和 'development'。\n# 提示：可以通过以下命令重命名刚创建的分支：\n# 提示：\n# 提示：  git branch -m &lt;name&gt;\n# 已初始化空的 Git 仓库于 /home/yangrui/temp/git-tutorial/.git/\n\ngit status —— check the status of a repository\n\ngit status\n\n# 位于分支 master\n\n# 尚无提交\n\n# 无文件要提交（创建/拷贝文件并使用 \"git add\" 建立跟踪）\n\n# we have not any files to be committed yet\n# let's create a README.md file for the first commit\ntouch README.md\ngit status\n\n# 位于分支 master\n\n# 尚无提交\n\n# 未跟踪的文件:\n#   （使用 \"git add &lt;文件&gt;...\" 以包含要提交的内容）\n#         README.md\n\n# 提交为空，但是存在尚未跟踪的文件（使用 \"git add\" 建立跟踪）\n\ngit add —— add files to staging area\n\n# when we create a file, it won't be managed automatically by git\n# we can see that README.md created above is listed as \"Untracted files\"\n# before adding README.md to our repository formally, we first need to add it to the staging area\n# which can be considered as a buffer area\ngit add README.md\ngit status\n\n# 位于分支 master\n\n# 尚无提交\n\n# 要提交的变更：\n#   （使用 \"git rm --cached &lt;文件&gt;...\" 以取消暂存）\n#         新文件：   README.md\n\ngit commit —— add files in the staging area to our repository formally\n\n# content after -m is a summary of the current commit\n# if you want to write more about the commit\n# you can run \"git commit\" without -m directly\n# this will open a text editor\n# and then you can enter more about the commit\n# by convention, the content you enter should be in the format:\n# line 1: a brief summary about the commit\n# line 2: blank line\n# line 3 and after: detailed info about the commit\n# note: if you want to abort the commit, don't enter any, and then close the editor directly\ngit commit -m \"First commit\"\n\n# [master（根提交） 7f9f90e] First commit\n#  1 file changed, 0 insertions(+), 0 deletions(-)\n#  create mode 100644 README.md\n\ngit log —— check commit log\n\n# the string \"7f9f90ef2c6d56862f096f3e0e288af5c3024097\" by \"commit\" in the console output is a hash value\n# which can be used to locate this commit uniquely\ngit log\n\n# commit 7f9f90ef2c6d56862f096f3e0e288af5c3024097 (HEAD -&gt; master)\n# Author: Rui Yang &lt;neurospace@petalmail.com&gt;\n# Date:   Tue May 14 13:26:07 2024 +0800\n\n#     First commit\n\n# to show log in graph\ngit log --graph\n\n# to show more concise info each commit\ngit log --pretty=short\n\n# to show log associated with a specific dir or file\ngit log README.md\n\n# to show modifications added by the last commit\ngit log -p\n\n# to show modifications associated with a specific dir or file added by the last commit\ngit log -p README.md\n\ngit diff —— check modifications\n\n# now let's add \"# Git Guide\" to the README.md\n# this modifies README.md in the working tree\n# the following command displays the difference between the working tree and the staging area\n# due to nothing existed in the staging area\n# it turns to display the difference between the working tree and the last commit\ngit diff\n\n# diff --git a/README.md b/README.md\n# index e69de29..0a49ef6 100644\n# --- a/README.md\n# +++ b/README.md\n# @@ -0,0 +1 @@\n# +# Git Guide\n\ngit add README.md\n\n# if you run \"git diff\" now, it will print nothing\n# because the status between the working tree and the staging area is of no diffrence\n# to check the difference between the working tree and the last commit\n# using\ngit diff HEAD\n\n# diff --git a/README.md b/README.md\n# index e69de29..0a49ef6 100644\n# --- a/README.md\n# +++ b/README.md\n# @@ -0,0 +1 @@\n# +# Git Guide\n\ngit commit -m \"Add index\"\n\n\n3.2 Operations on branches\nThe master branch is created by Git by default.\nWe can create multiple branches from the master branch or other branches.\nEach branch can be developed at the same time and is usually dedicated to a specific feature development (including fixing some bugs). Once the development of some branch is done, we can merge it with the master branch (in most cases).\n\ngit branch —— list all branches\n\n# the active branch is indicated by an * beside the branch name\ngit branch\n\n# * master\n\ngit checkout -b —— create and switch to a new branch\n\n# create and switch to the new branch feature-A from the master branch\n# if this is done\n# then all modifications take effect to the feature-A branch, not the master branch\ngit checkout -b feature-A\n# the above command can also be achieved by combining the two\ngit branch feature-A  # create\ngit checkout feature-A  # switch to\n\n# 切换到一个新分支 'feature-A'\n\ngit branch\n\n# * feature-A\n#   master\n\n# add a new line to README.md like\n# # Git Guide\n\n#   - feature-A\n\ngit add README.md\ngit commit -m \"Add feature-A\"\n\ngit merge —— merge branches\n\n# switch to the master branch\ngit checkout master\n# merge feature-A to master\n# create a merge commit in all cases using --no-ff\ngit merge --no-ff feature-A\n\n\n3.3 Modify commits\n\ngit reset --hard —— back to a specific status\n\n# purpose:\n# back to the status before creating the feature-A branch\n# then create a new branch named fix-B\n# you need to provide the hash value of some commit, to which you want to back\n# you can query it using \"git log\"\n# because we want to back to the status before creating the feature-A branch\n# we back to the commit \"Add index\", which is the last commit before creating the feature-A branch\ngit reset --hard e4fbb2140a7a25d8fa03a53bbf2129c5d8d56aaa\n\n# HEAD 现在位于 e4fbb21 Add index\n\ngit checkout -b fix-B\n\n# add a new line to README.md like\n# # Git Guide\n\n#   - fix-B\n\ngit add README.md\ngit commit -m \"Fix B\"\n\n# forward to the status after merging feature-A\n# because \"git log\" can only query the history up to the current status\n# we use \"git reflog\" to query the repository log to retrieve the hash value we want\ngit checkout master\ngit reset --hard c61dab8\n\n# 切换到分支 'master'\n# HEAD 现在位于 c61dab8 Merge branch 'feature-A'\n\n# merge fix-B to master\ngit merge --no-ff fix-B\n\n# 自动合并 README.md\n# 冲突（内容）：合并冲突于 README.md\n# 自动合并失败，修正冲突然后提交修正的结果。\n\n# this tells us that there is a conflict in README.md between feature-A and fix-B\n# now we need to open the README.md\n# then we will see the following\n\n# # Git Guide\n\n# &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\n#   - feature-A\n# =======\n#   - fix-B\n# &gt;&gt;&gt;&gt;&gt;&gt;&gt; fix-B\n\n# the content above ======= is the content in HEAD\n# below is the content in fix-B\n# now we modify it to what we want after merging manually\n\n# # Git Guide\n\n#   - feature-A\n#   - fix-B\n\n# now just add and commit it\ngit add README.md\ngit commit -m \"Fix conflict\"\n\ngit commit --amend —— modify the last commit\n\n# this will open a text editor\n# you can modify the last commit summary and then save and exit\ngit commit --amend\n\ngit rebase -i —— change/merge history\n\n# create and switch to the branch feature-C\ngit checkout -b feature-C\n\n# modify README.md like\n# which contains a small typo error\n# # Git Guide\n\n#   - feature-A\n#   - fix-B\n#   - faeture-C\n\n# -a option automatically stages modified and deleted files, not new files\ngit commit -am \"Add feature-C\"\n\n# now fix the typo error\n# # Git Guide\n\n#   - feature-A\n#   - fix-B\n#   - feature-C\n\ngit commit -am \"Fix typo\"\n\n# in fact, we almost don't expect such a commit to be recorded in our commit history at any time\n# so we hope to merge it into the last commit instead of creating a new commit for it\n# here we use \"git rebase -i\" to do this\n# HEAD~2 means that we pick the last two commits and open them in a text editor\ngit rebase -i HEAD~2\n\n# replace \"pick\" with \"fixup\" in the line of \"Fix typo\"\n\n# 成功变基并更新 refs/heads/feature-C。\n\n# now we can see that the commit \"Fix typo\" is not existed in our log\ngit log\n\ngit checkout master\ngit merge --no-ff feature-C\n\n\n3.4 Push to remote repository\n# git@github.com:&lt;account name&gt;/&lt;repository name&gt;.git\n# add a remote repository for our local repository\n# Git will set \"origin\" as the name of the remote repository\ngit remote add origin git@github.com:yr-neurospace/git-tutorial.git\n\n# push the content of the current branch to the master branch of the remote repository origin\n# when using -u option, it will set the master branch of the remote repository origin as the upstream of the local branch used now\n# this will let the local branch used now automatically pull content from the master branch of the remote repository origin when using \"git pull\" command without adding extra options\ngit push -u origin master\n\n\n3.5 Pull from remote repository\n\ngit clone —— pull a remote repository\n\n# by default, we are in the master branch\n# at the same time, Git will set origin as the identifier of the remote repository\n# in other words, the local master branch and the remote master branch are identical\ngit clone git@github.com:yr-neurospace/git-tutorial.git\n\n# show branch info for both local and remote repositories\ngit branch -a\n\n# create the feature-D branch in local\n# the content of which is from the feature-D branch of the remore origin repository\ngit checkout -b feature-D origin/feature-D\n\n# pull the latest feature-D branch to local from the remote repository origin\ngit pull origin feature-D"
  },
  {
    "objectID": "posts/Programming/Git/git_syntax_basics/index.html#some-github-functions",
    "href": "posts/Programming/Git/git_syntax_basics/index.html#some-github-functions",
    "title": "Git syntax basics",
    "section": "4 Some GitHub functions",
    "text": "4 Some GitHub functions\n\n4.1 Issue\nThe system managing Issue is called Bug Tracking System (BTS).\nIn GitHub, you can use Issue to\n\nreport BUG\ncommunicate among developers\nmake to-do list\n\nIn Issue, you can use the GitHub Flavored Markdown (GFM) syntax to organize your content. This will make your content clearer. Especially, you can use the Tasklist syntax to make a to-do list:\n# To do\n\n- [] add an attractive logo\n- [x] finish deployment\n- [] add sampling tool\nTask marked by [x] is done.\nIn addition, as we all have seen that every Issue has been assigned an unique number, say “#24”. We can associate a commit to one or more commits by adding those Issue’s numbers to our commit log, e.g. Add feature #24.\nWe can also use this way to close an Issue by describing a commit in one of the following formats:\nfix #24\nfixes #24\nfixed #24\n\nclose $24\ncloses #24\nclosed #24\n\nresolve #24\nresolves #24\nresolved #24\nWe may also convert an Issue to a Pull Request, because the numbers of Issue and Pull Request are interoperable."
  },
  {
    "objectID": "posts/Programming/Git/git_syntax_basics/index.html#send-pull-request",
    "href": "posts/Programming/Git/git_syntax_basics/index.html#send-pull-request",
    "title": "Git syntax basics",
    "section": "5 Send Pull Request",
    "text": "5 Send Pull Request\n\nFork the repository you want to develop in GitHub.\nClone the forked repository to our local development environment using git clone command.\nCreate a feature branch from the target branch.\n\nGenerally, we first create a feature branch and then develop new functions or fix some bugs in this feature branch.\n\nDeveloping in the feature branch.\nadd and then commit our modifications.\nCreate the remote feature branch and then push the content of the local feature branch to it.\n\ne.g., git push origin work will create a remote feature branch called work and then push the local content to it.\n\nSend Pull Request in GitHub (don’t forget to switch to the feature branch).\n\nIn addition, to keep up-to-date with the original repository, not the forked repository under our account, we can set the original repository as our “upstream” repository with the command git remote add upstream &lt;the original repository&gt;.\nOnce set, we can fetch the latest source code from the original repository, and then merge it with the corresponding branch in our local repository, so we can perform development based the latest version.\ngit fetch upstream\ngit merge upstream/master"
  },
  {
    "objectID": "posts/Programming/Git/git_syntax_basics/index.html#accept-pull-request",
    "href": "posts/Programming/Git/git_syntax_basics/index.html#accept-pull-request",
    "title": "Git syntax basics",
    "section": "6 Accept Pull Request",
    "text": "6 Accept Pull Request\n\nClone the remote repository accepting pull request to local.\nSet the remote repository sending pull request as the remote repository of our cloned local repository with specific name e.g. “PRRepo”, and then fetch it to local.\nNow we have both the repository accepting pull request and the repository sending pull request. Next, we create a feature branch used to test merging from the repository accepting pull request. And then merge the pull request in the merging test branch. Once check passed, we can delete the merging test branch by using git branch -D &lt;merging test branch name&gt;.\nFormally merge the pull request by one of the two methods:\n\nClick Merge pull request in GitHub.\nMerge pull request in the local and then push it to the remote."
  },
  {
    "objectID": "posts/Programming/Julia/julia_syntax_basics/index.html",
    "href": "posts/Programming/Julia/julia_syntax_basics/index.html",
    "title": "Julia syntax basics",
    "section": "",
    "text": "Interactive programming\n\nJulia is a dynamically typed language, in contrast with statically typed languages.\n\nHigh performance\n\nJulia uses just-in-time compilation (JIT), compilation at run time.\nTypically, JIT continuously analyses the code being executed and identifies parts of the code where the speedup gained from compilation or recompilation would outweigh the overhead of compiling that code.\nTherefore, JIT combines advantages of ahead-of-time compilation (AOT, compilation before execution) and interpretation.\nDue to the ecosystem of packages, Julia is really suitable for scientific computing, but it can also be used as a general-purpose programming language.\n\n\n\nJulia starts more slowly than Python, R, etc. but begins to run faster once the JIT compiler has converted critical parts of the code to machine code; thus it’s not suitable for:\n\nProgramming small, short-running scripts.\nReal-time systems (Julia implements automatic garbage collection, which tends to introduce small random delays).\nSystem programming (it needs detailed control of resource usage).\nEmbedded systems with limited memory."
  },
  {
    "objectID": "posts/Programming/Julia/julia_syntax_basics/index.html#julia-pros-and-cons",
    "href": "posts/Programming/Julia/julia_syntax_basics/index.html#julia-pros-and-cons",
    "title": "Julia syntax basics",
    "section": "",
    "text": "Interactive programming\n\nJulia is a dynamically typed language, in contrast with statically typed languages.\n\nHigh performance\n\nJulia uses just-in-time compilation (JIT), compilation at run time.\nTypically, JIT continuously analyses the code being executed and identifies parts of the code where the speedup gained from compilation or recompilation would outweigh the overhead of compiling that code.\nTherefore, JIT combines advantages of ahead-of-time compilation (AOT, compilation before execution) and interpretation.\nDue to the ecosystem of packages, Julia is really suitable for scientific computing, but it can also be used as a general-purpose programming language.\n\n\n\nJulia starts more slowly than Python, R, etc. but begins to run faster once the JIT compiler has converted critical parts of the code to machine code; thus it’s not suitable for:\n\nProgramming small, short-running scripts.\nReal-time systems (Julia implements automatic garbage collection, which tends to introduce small random delays).\nSystem programming (it needs detailed control of resource usage).\nEmbedded systems with limited memory."
  },
  {
    "objectID": "posts/Programming/Julia/julia_syntax_basics/index.html#basics",
    "href": "posts/Programming/Julia/julia_syntax_basics/index.html#basics",
    "title": "Julia syntax basics",
    "section": "2 Basics",
    "text": "2 Basics\n\n2.1 Arithmetic operations and number types\n\n2.1.1 Arithmetic operations\nAddition, subtraction, multiplication, division, and power: + - * / ^.\n\n\n2.1.2 Number types\n\nSigned integers: Int8, Int16, Int32, Int64 (default), Int128, BigInt.\nUnsigned integers: UInt8, UInt16, UInt32, UInt64, UInt128.\n\nYou can check the minimum and maximum values of a certain integer type with typemin() and typemax().\nYou can check the type of the input argument with typeof().\nJulia defaults to showing all signed integers in decimal format, and all unsigned integers in hexadecimal format.\nIn fact, what is stored in memory is no difference. The only difference is how to interpret it. You can use the reinterpret() function to see how the exactly same bits in memory can be interpreted differently.\n\nFloating-point numbers: Float16, Float32, Float64 (default).\n\nYou can type a Float32 number by suffixing f0: 3.14f0.\n\nRational type: 2 // 5 represents a rational number \\(\\frac{2}{5}\\).\nComplex type: 1 + 2im.\n\n\n\n2.1.3 Arithmetic operations for integers\n\n/ always gives floating-point number\n\n\n4 / 2\n\n2.0\n\n\n\n÷ or div() gives the quotient\n\n\n5 ÷ 3\n\n1\n\n\n\ndiv(5, 3)\n\n1\n\n\n\n% or rem() gives the remainder\n\n\n5 % 3\n\n2\n\n\n\nrem(5, 3)\n\n2\n\n\n\ndivrem() gives both quotient and remainder\n\n\ndivrem(5, 3)\n\n(1, 2)\n\n\n\n\n\n\n\n\nCaution\n\n\n\nTypically, operations on the same type of values always give the same type of value, even though overflow may occur.\nEven though overflow will occur, Julia won’t give any prompt.\n\n\n\n\n\n2.2 Variables\nIn julia, identifiers can be used to give names to constants, variables, types, and functions.\nVariables defining memory addresses where values are stored, are only references to values, because Julia allocates memory based on values, not variables.\nIn comparison with this, statically typed languages allocate memory based on variables, so you must first decalre the type of a variable (e.g., int) before using it, which will allocate a predefined size (which depends on the type of the variable) in a predefined location in memory to this variable. As a consequence, you should never attempt to assign a value that cannot fit inside the memory slot set aside for the variable to this variable.\n\nThe equal sign (=) operator is used to assign values to variables (i.e., let a variable point to a value):\n\n\nx = 1\n\n1\n\n\n\nAllowed variable names:\n\n\nLeading characters: letters, underscore, Unicode code points greater than 00A0.\nSubsequent characters: other Unicode code points.\nVariable names containing only underscores can only be assigned values, which are immediately discarded.\nExplicitly disallowed variable names: built-in keywords.\n\n\n\n\n\n\n\nTip\n\n\n\nTo type many special characters, like Unicode math symbols, you can type the backslashed LaTeX symbol name followed by tab.\nIf you find a symbol elsewhere, which you don’t know how to type, the REPL help will tell you: just type ? and then paste the symbol.\n\n\n\nMy own rules for clarity:\n\n\nCan only contain letters, underscore, and numbers.\nCan only start with letters.\n\n\nTwo special variables:\n\n\nConstants: defined with the const keyword.\n\n\nconst my_pi = 3.14\n\n3.14\n\n\n\n\n\n\n\n\nNote\n\n\n\nYou can still assign a new value with the same type as the original one to a constant, but a warning is printed.\n\n\n\nThe ans variable: in interactive mode, Julia REPL assigns the value of the last expression to the ans (answer) variable.\n\n\nLiteral coefficient\n\nIn mathematics, 3×x + 2×y may be written as 3x + 2y. Julia lets you write a multiplication in the same manner. We refer to this as literal coefficient, which is a shorthand for multiplication between a number literal and a constant or variable:\n\nx = 3\n2x\n\n2*(3+2)\n2(3+2)\n\n2*π\n2π\n\n\n\n2.3 Relation and logical operations\n\n2.3.1 Relation operations\n==, != or ≠, &lt;, &gt;, &lt;= or ≤, &gt;= or ≥\nThe operation result is true or false, which is Bool type.\n\n\n2.3.2 Logical operations\n&&, ||, !\nThe logical evaluation is lazy.\nSuppose i = 10, and then 1 &lt;= i &lt;= 100 is equivalent to i &gt;= 1 && i &lt;= 100.\n\n\n\n2.4 Control flow\n\n2.4.1 Comment\nIn Julial, you can give an inline comment by using #, or multiline comment by using #=...=#.\n\n\n2.4.2 Compound expressions\nTo have a single expression which evaluates several subexpressions in order, returning the value of the last subexpression as its value.\n\n; chain\n\nPut all subexpressions separated by ; inside parentheses.\n\nz = (x = 1; y = 2; x + y)\n\n# or\nz = (x = 1;\n     y = 2;\n     x + y)\n\nz\n\n3\n\n\n\nbegin block\n\nPut all subexpressions separated by a newline character between begin and end keywords.\nYou can also put all subexpressions in one line by separating them with ;.\n\nz = begin\n    x = 1\n    y = 2\n    x + y\n    end\n\n# or\nz = begin x = 1; y = 2; x + y end\n\nz\n\n3\n\n\nThis is quite useful for the inline function definition.\n\n\n\n\n\n\nNote\n\n\n\nFor multiple statements, you can put them in one line and separate them with ;, which is not the same thing as compound expressions:\n\nx = 1 + 2; println(\"x=$x\")\n\nx=3\n\n\n\n\n\n\n2.4.3 Short-circuit evaluation\n\ncond && expr: evaluate expr if and only if cond is true.\ncond || expr: evaluate expr if and only if cond is false.\n\n\n\n2.4.4 Conditional evaluation\n\nif cond1\n    statements\nelseif cond2\n    statements\n...\nelse\n    statements\nend\n\n\n\n\n\n\n\nNote\n\n\n\nTernary operator: cond ? expr1 : expr2, which is closely equivalent to if cond expr1 else expr2.\n\n\n\n\n2.4.5 Looping\n\nwhile\n\n\nwhile cond\n    statements\nend\n\n\n‘for’\n\n\nfor var in iterable\n    statements\nend\n\nFor for loop, var in iterable, var ∈ iterable, and var = iterable are equivalent to one another!\n\n\n\n\n\n\nNote 1: Member operator in or ∈\n\n\n\n\nin(collection) or ∈(collection) creates a function which checks whether its argument is in collection:\n\n\nf = in(1:10)\n\nf(1)\n\ntrue\n\n\nNote: start:stop will generate a number sequence with step 1; start:step:stop with step step.\n\nin(item, collection) or ∈(item, collection) determines whether an item is in the given collection:\n\n\nin(1, 1:10)\n\ntrue\n\n\n\nSets check whether the item is equal to one of the elements:\n\n\n1 in Set(1:10)\n\ntrue\n\n\n\nDicts look for key=&gt;value pairs:\n\n\n(1=&gt;10) in Dict(1=&gt;10, 2=&gt;20)\n\ntrue\n\n\n\nin.(items, collection) or items .∈ collection checks whether each value in items and each value in collection at the corresponding position are the same one:\n\nIf either items or collection contains only one element, it will be broadcasted to the same length as the longer.\n\nin.([1, 3, 2], [1, 4, 2])\n\n3-element BitVector:\n 1\n 0\n 1\n\n\n\nin.(items, Ref(collection)) or items .∈ Ref(collection) checks whether each value in items is in collection:\n\nRef(collection) can also be written as (collection,) (i.e. wrap collection in a tuple or a Ref).\nNote: create a tuple containing only one element with (1,).\n\nin.([1, 3, 2], Ref([8, 6, 1, 4, 3, 2]))\n\n3-element BitVector:\n 1\n 1\n 1\n\n\nin. does not support infix form!\nin, ∈, and .∈ support both forms!\nIn contrary to ∈ (\\in&lt;tab&gt;), ∋ (\\ni&lt;tab&gt;), and .∈, we have, ∉ (\\notin&lt;tab&gt;), ∌ (\\nni&lt;tab&gt;), and .∉.\n\n\n\n\n2.4.6 Jump out of loops\n\nbreak: jump out of the loop in which break is.\ncontinue: stop an iteration and move on to the next one.\n@goto name and @label name: @goto name unconditionally jumps to the statement at the location @label name.\n\n\n\n\n2.5 Functions\n\n2.5.1 Inline functions\n&lt;function name&gt;(&lt;parameters&gt;) = &lt;expression&gt;:\n\ncylinder_volume(r, h) = π*r^2*h\n\ncylinder_volume(5, 3)\n\n235.61944901923448\n\n\n\n\n2.5.2 Multiline functions\n\nfunction &lt;function name&gt;(parameters)\n    ...\nend\n\nIn Julia, return &lt;value&gt; is not necessary. It is only used when you need to exit a function early; otherwise the value of the last expression will always be returned.\n\n\n\n\n\n\nNote\n\n\n\nFunctions are central to Julia! Various interfaces are achieved by functions even though they don’t look like functions.\n\nInfix form\n\n\n5 + 3\n\n8\n\n\n\nPrefix form\n\n\n+(5 + 3 + 5)\n\n13\n\n\nIf a function with a symbol name takes two arguments, we can use it by infix form:\n\n↔(x, y) = x^2 + y^2\n\n6 ↔ 6\n\n72\n\n\n\n\n\n\n2.5.3 Argument passing behaviour\nPass-by-sharing!\n\n\n2.5.4 Specify the type of return value\nYou can specify the type of return value of a function in the form FuncName(parameters)::ReturnType.\nIf the type of return value is not the given type, a conversion is attempted with convert().\n\nfoo(x::Int64) :: Int32 = 2x\n\ntypeof(foo(6))\n\nInt32\n\n\n\n\n2.5.5 Multiple assignments and multiple return values\n\nMultiple assignments\n\nAchieved by using (named) tuples.\n\n(a, b, c) = 1:3  # Assign each variable a value; parentheses are optional\n\n_, _, a = 1:3  # Use _ to discard unwanted values\n\na, b..., c = 1:6  # a -&gt; 1, b -&gt; 2:5, c -&gt; 6; b... indicates that b is a collection (b doesn't need to be the final one)\n\n(; b, a) = (a=1, b=2, c=3)  # Assign values to variables based on names\n\n\nMultiple return values\n\n\n\n2.5.6 Parameter types\n\nPositional parameters: non-optional; optional with defaults.\nKeyword parameters: non-optional; optional with defaults.\n\n\n(a, b = 1; c, d = 2)  # Keyword arguments are defined after ;\n\n# Positional arguments: a, b (optional)\n# Keyword arguments: c, d (optional)\n\n# When you pass arguments, either will be fine:\n(1, 2; c = 3, d = 4)  # Separated by ;\n(1, 2, c = 3, d = 4)  # Separated by ,\n\n\n\n\n\n\n\nImportant\n\n\n\nMultiple dispatch only considers positional arguments.\n\n\n\n\n2.5.7 Anonymous functions\nAnonymous functions play an important role in functional programming.\nAn anonymous function can be defined in two ways:\n\nInline style: (&lt;parameters&gt;) -&gt; &lt;expression&gt; (() can be omitted if it only has a single parameter).\nMultiline style:\n\n\nfunction (&lt;parameters&gt;)\n    ...\nend\n\n\n2.5.7.1 do blocks\nWe can use do blocks to create mutiline anonymous functions.\nThe following two statements are equivalent:\n\nmap(x -&gt; begin\n              if x &lt; 0 && iseven(x)\n                  return 0\n              elseif x == 0\n                  return 1\n              else\n                  return x\n              end\n         end,\n    [-2, 0, 2])\n\n3-element Vector{Int64}:\n 0\n 1\n 2\n\n\n\nmap([-2, 0, 2]) do x\n    if x &lt; 0 && iseven(x)\n        return 0\n    elseif x == 0\n        return 1\n    else\n        return x\n    end\nend\n\n3-element Vector{Int64}:\n 0\n 1\n 2\n\n\nIn the above example, the do x syntax creates an anonymous function with argument x and passes it as the first argument to map().\nSimilarly, do x, y will create a two-argument anonymous function but do (x, y) will create a one-argument anonymous function, whose argument is a tuple.\nIn a word, we can use do blocks to create anonymous functions which are passed as the first argument to some higher-order functions, the first argument of which must be the Function type.\n\n\n\n2.5.8 The splat operator ...\nThe splat operator can be used to turn arrays or tuples into function arguments.\ne.g. foo([1, 2, 3]...) is the same as foo(1, 2, 3).\nYou can define a parameter which accepts a variable number of arguments by using the splat operator:\n\n# All arguments except the 1st will be stored in a tuple, assigned to args\nfunction var_f(x, args...)\n    ...\nend\n\n\n\n2.5.9 Closure\nA closure is a function that has captured some external state not supplied as an argument since the inner scope can use variables defined in an outter scope.\nAnonymous functions are frequently used as closures.\n\nfunction make_pow(n::Real)  # Outer function\n    function (x::Real)  # Inner function\n        x^n  # The inner function uses n defined outside it and n is not passed as an argument to it\n    end\nend\n\npow2 = make_pow(2)  # The returned function with n=2 is assigned to variable pow2\npow3 = make_pow(3)\n\npow2(2), pow3(2)\n\n(4, 8)\n\n\n\n\n\n\n\n\nPerformance of captured variable\n\n\n\nFor the consideration of performance, if the type of a captured variable is already known, you would better add a type annotation to it. In addition, if the value of this captured variable need not be changed after the closure is created, you can indicate it with a let block:\n\nfunction abmult(r::Int)\n    r1::Int = r  # Type annotation\n    if r1 &lt; 0\n        r1 = -r1\n    end\n    f = let r1 = r1  # Fix it\n            x -&gt; x * r1\n        end\n    return f\nend\n\nf = abmult(10)\nf(10)\n\n100\n\n\n\n\n\n\n2.5.10 Partial function application\nPartial function application refers to the process of fixing a number of arguments to a function, producing another function accepting fewer arguments.\nObviously, closure is a way to achieve the partial function application.\n\n\n2.5.11 Function composition, vectorization and piping\n\n2.5.11.1 Function composition\nThe concept of function composition in Julia is the very concept of function composition in mathematics and the operation symbol is the same one: ∘, typed using \\circ&lt;tab&gt; (e.g. (f ∘ g)(args...) is the same as f(g(args...))).\n\n(sqrt ∘ +)(3, 6)  # Equivalent to sqrt(+(3, 6))\n\n3.0\n\n\n\n\n2.5.11.2 Dot syntax for vectorizing functions\nIn Julia, vectorized functions are not required for performance, and indeed it is often beneficial to write your own loops, but they can still be convenient.\nYou can add a dot . after regular function names (e.g. f) or before special operators (e.g. +) to get their vectorized versions.\n\nOperating on a single array:\n\n\nA = 1:3\n\nsin.(A)  # Which is equivalent to map(sin, A) or broadcast(sin, A)\n\n3-element Vector{Float64}:\n 0.8414709848078965\n 0.9092974268256817\n 0.1411200080598672\n\n\n\nOperating on multiple arrays (even of different shapes), or a mix of arrays and scalars:\n\n\nfp(x, y) = 3x + 4y\n\nA = 1:3\nB = 4:6\n\nfp.(pi, A)\n\n3-element Vector{Float64}:\n 13.42477796076938\n 17.42477796076938\n 21.42477796076938\n\n\n\nfp.(A, B)\n\n3-element Vector{Int64}:\n 19\n 26\n 33\n\n\n\nKeyword arguments are not broadcasted over, but are simply passed through to each of the function.\nNested f.(args...) calls are fused into a single broadcast loop.\n\n\nX = 1:6\n\nsin.(cos.(X))  # Equivalent to broadcast(x -&gt; sin(cos(x)), X)\n\n6-element Vector{Float64}:\n  0.5143952585235492\n -0.4042391538522658\n -0.8360218615377305\n -0.6080830096407656\n  0.2798733507685274\n  0.819289219220601\n\n\nHowever, the fusion stops as soon as a “non-dot” function call is encountered (e.g. sin.(sort(cos.(X)))).\n\nThe maximum efficiency is typically achieved when the output array of a vectorized operation is pre-alllocated.\n\n\nX = 1:10000\n\n@time sin.(X)\n\n  0.000054 seconds (3 allocations: 78.203 KiB)\n\n\n10000-element Vector{Float64}:\n  0.8414709848078965\n  0.9092974268256817\n  0.1411200080598672\n -0.7568024953079282\n -0.9589242746631385\n -0.27941549819892586\n  0.6569865987187891\n  0.9893582466233818\n  0.4121184852417566\n -0.5440211108893698\n -0.9999902065507035\n -0.5365729180004349\n  0.4201670368266409\n  ⋮\n -0.9534986003597155\n -0.26156028858731495\n  0.6708553462651908\n  0.9864896695694187\n  0.39514994010172155\n -0.5594888219681838\n -0.9997361413354392\n -0.5208306628783247\n  0.4369241250954582\n  0.9929728874353159\n  0.6360869563962336\n -0.30561438888825215\n\n\n\nY = Vector{Float64}(undef, 10000)  # Construct an uninitialized (undef) Vector{Float64} of length 10000\n\n@time Y .= sin.(X)  # Overwrite Y with sin.(X) in-place\n\n  0.008173 seconds (9.57 k allocations: 711.680 KiB, 99.03% compilation time)\n\n\n10000-element Vector{Float64}:\n  0.8414709848078965\n  0.9092974268256817\n  0.1411200080598672\n -0.7568024953079282\n -0.9589242746631385\n -0.27941549819892586\n  0.6569865987187891\n  0.9893582466233818\n  0.4121184852417566\n -0.5440211108893698\n -0.9999902065507035\n -0.5365729180004349\n  0.4201670368266409\n  ⋮\n -0.9534986003597155\n -0.26156028858731495\n  0.6708553462651908\n  0.9864896695694187\n  0.39514994010172155\n -0.5594888219681838\n -0.9997361413354392\n -0.5208306628783247\n  0.4369241250954582\n  0.9929728874353159\n  0.6360869563962336\n -0.30561438888825215\n\n\n\nUsing the @. macro to convert every function call, operation, and assignment in an expression into the “dotted” version.\n\n\nX = [1.0, 2.0, 3.0]\n\nY = similar(X)  # Pre-allocate the output array\n\n@. Y = sin(cos(X))\n\n3-element Vector{Float64}:\n  0.5143952585235492\n -0.4042391538522658\n -0.8360218615377305\n\n\n\nUsing vectorized piping operator.\n\n\n1:6 .|&gt; [x -&gt; x-1, inv, x -&gt; 2*x, -, isodd, iseven]\n\n6-element Vector{Real}:\n    0\n    0.5\n    6\n   -4\n true\n true\n\n\n\n\n\n\n\n\nbroadcast(f, As...)\n\n\n\nBroadcast the function f over the arrays, tuples, collections, Refs, and/or scalars As.\n\n\n\n\n\n\n\n\nPre-allocating outputs\n\n\n\n\nVector{Int}(undef, 10)  # Construct an uninitialized Vector{Int} of length 10\n\n10-element Vector{Int64}:\n 0\n 0\n 0\n 0\n 0\n 0\n 0\n 0\n 0\n 0\n\n\n\nMatrix{Float64}(undef, 3, 3)  # Construct an uninitialized Matrix{Float64} of 3 by 3\n\n3×3 Matrix{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n\n\n\n\n\n2.5.11.3 Function piping\nThe pipe operator is |&gt;, which is used to chain together functions taking single arguments as inputs.\n\n1:10 |&gt; sum |&gt; sqrt\n\n7.416198487095663\n\n\n\n\n\n\n2.6 Exception\nUsage:\n\ntry\n    &lt;some code which may raise some errors&gt;\ncatch &lt;exception variable&gt;\n    &lt;some code dealing with exceptions&gt;\nelse\n    &lt;some code to be executed when no error occurs&gt;\nfinally\n    &lt;some code to be executed anyway&gt;\nend\n\nYou can use throw() to raise a given type of exception or use error() to raise an ErrorException directly.\nThen you can use isa() to check whether the error type raised is the expected.\ne.g.\n\nx = [2, -2, 'a']\n\nfor i in x\n    try\n        y = sqrt(i)\n        println(\"√\", i, \" = \", y)\n    catch e\n        if isa(e, DomainError)\n            println(\"√\", i, \": $(i) is out of domain\")\n        else\n            println(\"√\", i, \": $(i) is an unsopported type\")\n        end\n    end\nend\n\n√2 = 1.4142135623730951\n√-2: -2 is out of domain\n√a: a is an unsopported type\n\n\n\n\n2.7 Metaprogramming\n\n\n\n\n\n\nKey concepts\n\n\n\n\nAbstract Syntax Tree (AST): a data structure used in computer science to represent the structure of a program or code snippet.\nHigher-order functions: functions taking one or more functions as arguments and returning a function. All other functions are called first-order functions.\nClosure: a function that has captured some external state not supplied as arguments to it since the inner scope can refer to variables defined in its outer scopes.\nReflection: the ability of a process to examine, introspect, and modify its own structure and behavior.\n\n\n\n\n2.7.1 Program representation\nIn a word, each Julia program starts its life as a string, which then is parsed into an object called expression of type Expr. The key point is that Julia code is internally represented as a data structure that is accessible from the language itself. It means that we can generate, examine, and modify Julia code like manipulating ordinary Julia objects within Julia.\n\n\n2.7.2 Expressions and evaluation\nThe next questions are how to construct expressions of type Expr, and how to execute (evaluate) them?\n\n2.7.2.1 Expressions\nThere are several ways to construct expressions:\n\nFrom strings via Meta.parse().\n\n\nprog = \"1 + 1\"\nex1 = Meta.parse(prog)\n\n:(1 + 1)\n\n\n\ntypeof(ex1)\n\nExpr\n\n\n\n\n\n\n\n\nNote\n\n\n\nExpr objects contain two fields:\n\nhead: a Symbol identifying the kind of expression.\nargs: the expression arguments, which may be symbols, expressions, or literal values.\n\n\n\n\nUse Expr() constructor.\n\n\nex2 = Expr(:call, :+, 1, 1)\n\n:(1 + 1)\n\n\n\nex1 == ex2\n\ntrue\n\n\n\nQuoting single/multiple statements of Julia code.\n\nThe usual representation of a quote form in an AST is an Expr with head :quote.\n\nQuoting single statement of Julia code using : character, followed by paired parentheses:\n\n\n:(a + b * c + 1) |&gt; typeof\n\nExpr\n\n\n\nQuoting multiple statements of Julia code using quote ... end blocks:\n\n\nex = quote\n    x = 1\n    y = 2\n    x + y\nend\ntypeof(ex)\n\nExpr\n\n\n\n\n\n\n\n\nInterpolation\n\n\n\nIn contrast with expressions constructed using Meta.parse() or Expr(), expressions constructed by quoting single/multiple statements of Julia code allow us to interpolate literals or expressions into, quite similar with string interpolation:\n\na = 1\n:($a + b)  # literals\n\n:(1 + b)\n\n\n\n:(a in $:((1,2,3)))  # expressions\n\n:(a in (1, 2, 3))\n\n\nSplatting interpolation: you have an array of expressions and need them all to become arguments of the surrounding expression. This can be done with the syntax $(xs...):\n\nargs = [:x, :y, :z]\n:(f(1, $(args...)))\n\n:(f(1, x, y, z))\n\n\n\n\n\nNested quote and interpolation:\n\nNaturally, it is possible for quote expressions to contain other quote expressions.\nUnderstanding how interpolation works in these cases can be a bit tricky.\nThe basic principle is that $x works similarly to eval(:x).\n\njulia&gt; x = 100\n# 100\n\njulia&gt; quote $x end  # x will be evaluated in a non-nested quote (this should be natrual for interpolation introduced above)\n# quote\n#     #= REPL[13]:1 =#\n#     100\n# end\n\njulia&gt; quote quote $x end end  # x won't be evaluated yet, because it belongs to the inner quote, not the outer quote\n# quote\n#     #= REPL[14]:1 =#\n#     $(Expr(:quote, quote\n#     #= REPL[14]:1 =#\n#     $(Expr(:$, :x))\n# end))\n# end\n\njulia&gt; quote quote $x end end |&gt; eval  # the inner quote will be evaluated and x will too as a consequence\n# quote\n#     #= REPL[15]:1 =#\n#     100\n# end\n\njulia&gt; quote quote $$x end end  # the outer quote can interpolate values inside $ in the inner quote with multiple $s, which means x will be evaluated in this case\n# quote\n#     #= REPL[16]:1 =#\n#     $(Expr(:quote, quote\n#     #= REPL[16]:1 =#\n#     $(Expr(:$, 100))\n# end))\n# end\n\njulia&gt; quote quote quote $$x end end end  # x won't be evaluated here, because the outer $ belongs to the innermost quote, and the inner $ belongs to the second quote\n# quote\n#     #= REPL[17]:1 =#\n#     $(Expr(:quote, quote\n#     #= REPL[17]:1 =#\n#     $(Expr(:quote, quote\n#     #= REPL[17]:1 =#\n#     $(Expr(:$, :($(Expr(:$, :x)))))\n# end))\n# end))\n# end\n\n\nQuoteNode:\n\nIn some situations, it is necessary to quote code without performing interpolation. This kind of quoting does not yet have syntax, but is represented internally as an object of type QuoteNode:\n\njulia&gt; quote quote $x end end |&gt; eval  # with interpolation\n# quote\n#     #= REPL[34]:1 =#\n#     100\n# end\n\njulia&gt; quote quote $x end end |&gt; QuoteNode |&gt; eval  # wihout interpolation\n# quote\n#     #= REPL[36]:1 =#\n#     $(Expr(:quote, quote\n#     #= REPL[36]:1 =#\n#     $(Expr(:$, :x))\n# end))\n# end\n\nNote: the parser yields QuoteNodes for simple quoted items like symbols:\n\ndump(Meta.parse(\":x\"))\n\nQuoteNode\n  value: Symbol x\n\n\n\n\n\n\n\n\nShow expressions elegantly\n\n\n\n\ndump(Meta.parse(\"1 + 1\"))\n\nMeta.show_sexpr(Meta.parse(\"(4 + 4) / 2\"))  # shows that Expr objects can be nested\n\nExpr\n  head: Symbol call\n  args: Array{Any}((3,))\n    1: Symbol +\n    2: Int64 1\n    3: Int64 1\n(:call, :/, (:call, :+, 4, 4), 2)\n\n\n\n\n\n\n\n\n\n\nSymbols\n\n\n\nA Symbol is an interned string, used as one building block of expressions.\nA Symbol can be constructed in two ways:\n\n# using : character from valid identifiers\ns = :foo\ntypeof(s)\n\nSymbol\n\n\n\n# using Symbol() constructor from any number of arguments by concatenating their string representations together\nSymbol(:var, \"_\", \"sym\")\n\n:var_sym\n\n\n\n# sometimes extra parentheses around the argument to : are needed to avoid ambiguity in parsing\n:(::)\n\n:(::)\n\n\nNote: in the context of an expression, symbols are used to indicate access to variables; when an expression is evaluated, a symbol is replaced with the value bound to that symbol in the appropriate scope.\n\n\n\n\n2.7.2.2 Evaluation\nGiven an expression object, one can cause Julia to evaluate (execute) it at global scope using eval() (for code block, use @eval begin ... end).\nEvery module has its own eval() function that evaluates expressions in its global scope.\nNote the behaviors of variable a and symbol :b in the following code:\n\na = 1\nex = Expr(:call, :+, a, :b)  # The value of the variable a at expression construction time is uesd as an immediate value in the expression; on the other hand, the symbol :b is used in the expression construction, so the value of the variable b at that time is irrelevant. Only when the expression is evaluated is the symbol :b resolved by looking up the value of the variable b.\na, b = 0, 2\neval(ex)\n\n3\n\n\n\n\n\n2.7.3 Code generation\nBy means of expressions along with its interpolation, and evaluation, one extremely useful feature of Julia is the capability to generate and manipulate Julia code within Julia itself. Such as defining functions returning Expr objects, defining methods programmatically, etc.\n\nstruct MyNumber\n    x::Float64\nend\n\nfor op = (:sin, :cos, :tan, :log, :exp)\n    eval(quote\n        Base.$op(a::MyNumber) = MyNumber($op(a.x))\n    end)\nend\n\nx = MyNumber(π)\nprintln(sin(x))\nprintln(cos(x))\n\nMyNumber(1.2246467991473532e-16)\nMyNumber(-1.0)\n\n\n\n\n2.7.4 Macros\nMacros provide a mechanism to include generated code in the final body of a program.\nA macro maps a tuple of arguments (including symbols, literal values, and expressions, which hints that all the other arguments passed to a macro are considered as expressions, except symbols and literal values) to a returned expression, which is compiled directly rather than requiring a runtime eval() call. This means that the returned expression is compiled at parse time. This is why we can include generated code in the final body of a program using macros.\n\nDefining macros:\n\n\nmacro &lt;NAME&gt;(&lt;arguments&gt;)\n    body  # return an expression at last\nend\n\nFor example,\n\nmacro sayhello(name)\n    return :(println(\"Hello, \", $name))\nend\n\n@sayhello(\"human\")\n\nHello, human\n\n\nWhen @sayhello is encountered, the quoted expression is expanded to interpolate the value of the argument into the final expression. Then, the compiler will replace all instances of @sayhello with :(Main.println(\"Hello, \", \"human\")). When @sayhello is entered in the REPL, the expression executes immediately, thus we only see the evaluation result. We can view the returned expression using the function macroexpand() or macro @macroexpand:\n\n@macroexpand @sayhello(\"human\")  # equivalent to macroexpand(Main, :(@sayhello(\"human\")))\n\n:(Main.println(\"Hello, \", \"human\"))\n\n\n\nWhy macros?\n\nMacros are necessary because they execute when code is parsed; therefore, macros allow the programmer to generate and include fragments of customized code before the full program is run.\n\nmacro twostep(arg)\n    println(\"I execute at parse time. The argument is: \", arg)\n    return :(println(\"I execute at runtime. The argument is: \", $arg))\nend\n\nex = @macroexpand @twostep :(1, 2, 3)\nprintln(typeof(ex))\nprintln(repr(ex))  # equivalent to show(ex), because repr() actually calls show() and then returns a string\neval(ex)\n\nI execute at parse time. The argument is: :((1, 2, 3))\nExpr\n:(Main.println(\"I execute at runtime. The argument is: \", $(Expr(:copyast, :($(QuoteNode(:((1, 2, 3)))))))))\nI execute at runtime. The argument is: (1, 2, 3)\n\n\n\nMacro invocation\n\n\n# separated by white space\n@name expr1 expr2 ...\n# separated by ,\n@name(expr1, expr2, ...)\n\nNote:\n\n# there is only an argument here - a tuple\n@name (expr1, expr2, ...)\n\n@name[a b] * c  # no space and parenthesis between the macro name and the argument, which is the unique argument to this macro\n# is equivalent to\n@name([a b]) * c\n\nNote: again, macros receive their arguments as expressions, literals, and symbols. You can explore the macro arguments using the show() function within the macro body.\nNote: in addition to the given argument list, every macro is passed extra two arguments named __source__, and __module__.\n\n__source__ argument provides information if the form of a LineNumberNode object about the parser location of the @ sign from the macro invocation. The location information can be accessed by referencing __source__.line, and __source__.file. It can also be used for other useful purposes, such as implementing the @__LINE__, @__FILE__, and @__DIR__ macros.\n__module__ argument provides information in the form of a Module object about the expansion context of the macro invocation. This allows macros to look up contextual information, such as existing bindings.\n\n\nHygiene\n\nHow to resolve variables within a macro result in an appropriate scope?\nIn short, we have several concerns:\n\nMacros must ensure that the variables they introduce in their returned expressions do not accidentally clash with existing variables in the surrounding code they expand into.\nConversely, the expressions that are passed into a macro as arguments are often expected to evaluate in the context of the surrounding code, interacting with and modifying the existing variables.\nIn addition, a macro may be called in a different module from where it was defined. In this case we need to ensure that all global variables are resolved in the correct module.\n\nJulia’s macro expander solves these problems in the following way:\n\nFirst, variables within a macro result are classified as either local or global. A variable is considered local if and only if it is assigned to declared local, or used as a function argument name. Otherwise, it is considered global. Local variables are then renamed to be unique via gensym() function, and global variables are resolved within the macro definition environment.\n\nThe above rules can meet the following expectations:\n\n# here, we want t0, t1, and val to be private temporary variables,\n# and we want time_ns() and println() refer to the time_ns() and println() functions in Julia Base,\n# not to any time_ns() and println() functions the user might have\nmacro time(ex)\n    return quote\n        local t0 = time_ns()\n        local val = $ex\n        local t1 = time_ns()\n        println(\"elapsed time: \", (t1-t0)/1e9, \" seconds\")\n        val\n    end\nend\n\n\nBut sometimes, we want some variables in the user expression to be resolved in the macro call environment. To achieve this goal, we can put the user expression in the esc() function, which means “escaping”. An expression wrapped in this manner is left alone by the macro expander and simply pasted into the output verbatim. Therefore it will be resolved in the macro call environment.\n\nThe above rules can meet the following expectations:\n\n# suppose that the user has already defined a time_ns() function, different from the time_ns() function in the Julia Base,\n# and he call @time in this way:\n\n@time time_ns()\n\n# obviously, we just want time_ns() contained in the user expression to be resolved in the macro call environment, instead of the macro definition environment.\n# so this is why we need esc().\n\n\nMacro dispatch\n\nMacro dispatch is based on the types of AST that are handed to the macro, not the types that AST evaluates to at runtime.\nFor example:\n\nExpr: contains many different heads.\nSymbol\nLiteral values: Int64, Float64, String, Char, etc.\nQuoteNode\nLineNumberNode\n\nand so on.\n\n\n2.7.5 Non-standard string and command literals\n\nStandard string literals\n\nFor example, \"abc\", \"\"\"abc\"\"\".\n\nNon-standard string literals\n\nTo provide some convenient methods to generate some special objects using non-standard string literals.\n\nmacro r_str(pattern, flags...)\n    Regex(pattern, flags...)\nend\n\np = r\"^http\"  # equivalent to call @r_str \"^http\" to produce a regular expression object rather than a string\n\n# how to define a non-standard string literal\nmacro &lt;name&gt;_str(str)  # affixing _str after the formal macro name\n    ...\nend\n\n# add a flag\nmacro &lt;name&gt;_str(str, flag)  # flag is also a String type\n    ...  # the return value may depend on the flag content (different flags with different return values)\nend\n\n# how to call\nname\"str\"flag\n\n\nStandard command literals\n\nFor example, `echo hello, world`.\n\n# generate a Cmd from the str string which represents the shell command(s) to be executed\nmacro cmd(str)\n    cmd_ex = shell_parse(str, special=shell_special, filename=String(__source__.file))[1]\n    return :(cmd_gen($(esc(cmd_ex))))\nend\n\n# if you want to call shell_parse() and cmd_gen(), you need do it in the forms of Base.shell_parse() and Base.cmd_gen(), respectively\n\n\nNon-standard command literals\n\n\nmacro echo_cmd(str)\n    cmd_str = string(\"echo \", str)\n    return :(@cmd $cmd_str)\nend\n\nc = echo`hello, world`\ntypeof(c)\nshow(c)\n\n`echo hello, world`\n\n\n\n\n2.7.6 Generated functions\nHow to generate specialized code depending on only the types of their arguments using generated functions (argument names refer to types, and the code should return an expression)?\nThe capability of multiple dispatch can also be achieved by using generated functions, which is defined by prefixing @generated before a normal function definition, but we’d better obey some rules when defining generated functions.\nOf course, we can define an optionally-generated function containing a generated version and a normal version by using if @generated ... else ... in a normal function body. Statements after if @generated is the generated one and after else the normal one. The compiler may use the generated one if convenient; otherwise it may choose to use the normal implementation instead.\n\n\n\n2.8 Types\n\n2.8.1 Basics\nIn Julia, all are objects having a type, and types are first-class objects.\n\nYou can use typeof() to get the type of any object.\nYou can find the supertype of any type with supertype(): the root of type hierarchy is Any.\nYou can find the subtypes of any type with subtypes(): if there is no subtype for a given type, it will return Type[].\nYou can check whether a type is a subtype of the other with the &lt;: operator (e.g. String &lt;: Any).\nSeeing that you created an empty array with the type Integer, then you can only add elements with the type Integer or its subtypes to this array.\n\n\n\n\n\n\n\nPrimitive and composite types\n\n\n\nWe can roughly divide all types into primitive types (concrete types whose data consists of plain old bits) and composite types (derived from primitive types or other composite types). On the other hand, we can also devide all types into abstract types (with zero fields) and concrete types (with fields).\nIn Julia, there are three primitive types: integers, floating-point numbers and characters. You can use the function isprimitivetype() to check whether a type is a primitive type (e.g. isprimitivetype(Int8)).\nIt’s possible to define new primitive types in Julia by using primitive type ... end.\n\n\nYou can create composite types from primitive types or composite types:\n\nDefinition of an immutable composite type:\n\n\nstruct TypeName\n    # Defining typed fields here\nend\n\ne.g.\n\nstruct Archer\n    name::String\n    health::Int\n    arrows::Int\nend\n\n# Once the composite type Archer is defined, you can instantiate the Archer object\nwilliam = Archer(\"William Tell\", 30, 24)\n\n# Then access the values of fileds by using dot operator\nwilliam.name, william.health, william.arrows\n\n\n\n\n\n\n\nNote\n\n\n\nIn Julia, :: is used to annotate variables and expression with types.\nx::T means variable x should have type T.\n\n\n\nDefinition of a mutable composite type:\n\n\nmutable struct TypeName\n    # Defining typed fields here\nend\n\n\nDefinition of abstract type: abstract type TypeName end.\n\nObviously, the type created by using struct is a concrete type.\nYou can create objects of a concrete type but not of an abstract type.\nAn abstract type cannot have any fields. Only concrete types can have fields or a value.\nThe purpose of abstract types is to facilitate the construction of type hierarchy.\nA composite type is a concrete type with fields; a primitive type is a concrete type with a single value.\n\nYou can use the subtype operator &lt;: to create a concrete or abstract subtype of an abstract type.\n\n\nabstract type Warrior end\n\n# Archer is a subtype of Warrior\nstruct ArcherSoldier &lt;: Warrior\n    name::String\n    health::Int\n    arrows::Int\nend\n\nsupertype(ArcherSoldier)\n\nWarrior\n\n\n\n\n\n\n\n\nNote\n\n\n\nDifferent with object-oriented languages, composite types in Julia can only have fields, and cannot have methods bound to them.\n\n\nAfter creating concrete types, you can make objects of them (i.e. instantiate them) with arguments.\n\n\n\n\n\n\nNote\n\n\n\nYou can only make objects of concrete types!\n\n\ne.g.\n\nmutable struct TestType\n    a::Int64\n    b::Float64\nend\n\nt1 = TestType(1, 10.5)\n\nTestType(1, 10.5)\n\n\nYou can instantiate objects of TestType in this way t1 = TestType(1, 10.5), because Julia automatically creates a special function called constructor with the same name as your type. A constructor is responsible for making an instance (object) of the type it is associated with. Julia adds two methods to the constructor function, which takes the same number of arguments as you have fields. One method uses type annotations for its arguments, as specified for each field in the struct. The other takes arguments of Any type.\n\nmethods(TestType)\n\n# 2 methods for type constructor: TestType(a::Int64, b::Float64) in Main at In[62]:2  TestType(a, b) in Main at In[62]:2 \n\n\n\nfunction TestType(a::Int64)\n    TestType(a, a)\nend\n\nmethods(TestType)\n\n# 3 methods for type constructor: TestType(a::Int64) in Main at In[64]:1  TestType(a::Int64, b::Float64) in Main at In[62]:2  TestType(a, b) in Main at In[62]:2 \n\n\n\nTestType(100)\n\nTestType(100, 100.0)\n\n\nSurely, you can add methods to this constructor function outside of struct in the same manner as any other fucntion, called outer constructor.\nIn addition, you can define accessors (getters and setters) as well as other functions accepted arguments of this type to achieve some tasks.\nYou can only provide types without concrete parameters to define a function tied to types (this type of function are usually used to get some properties of a type, independent of its objects):\n\ntoy(::TestType) = 100\n\nt = TestType(100)\ntoy(t)\n\n100\n\n\nIn functions (including outer constructors) you defined outside of struct, you can easily check whether user-provided arguments are valid or not. But how can we check this when instantiating objects of a concrete type by using constructors Julia created?\nTo solve this problem, we need to define the constructor inside of struct, called inner constructor. Once you do this, you tell Julia that you don’t want it to create constructor methods automatically (i.e. disable this manner). Then, users can only use the constructor you defined to instantiate objects of a concrete type.\n\nmutable struct TempType\n    a::Int64\n    b::Float64\n    diff::Float64\n\n    function TempType(a::Int64, b::Float64)\n        new(a, b, b - a)  # We don't want users to provide the value of diff, which is defined as the difference of b and a\n    end\nend\n\n\n\n\n\n\n\nNote\n\n\n\nIn inner constructor, you need use new() (which is only available inside an inner constructor) to instantiate objects of a concrete type, which accepts zero or more arguments but never more aguments than the number of fields in your composite type, because creating an inner constructor removes all constructor methods created by Julia. Feilds with missing values will be set to random values.\n\n\n\nmethods(TempType)\n\n# 1 method for type constructor: TempType(a::Int64, b::Float64) in Main at In[67]:6 \n\n\n\nTempType(1, 10.5)\n\nTempType(1, 10.5, 9.5)\n\n\n\n# This will raise an error\nTempType(1, 10.5, 9.5)\n\n\nMethodError: no method matching TempType(::Int64, ::Float64, ::Float64)\n\nClosest candidates are:\n  TempType(::Int64, ::Float64)\n   @ Main In[67]:6\n\n\nStacktrace:\n [1] top-level scope\n   @ In[70]:3\n\n\n\n\n\n2.8.2 Multiple dispatch\n\n2.8.2.1 How does multiple dispatch work\n\nfunction myadd(x::Int, y::Int)\n    print(\"The sum is: \")\n    printstyled(x + y, \"\\n\", bold = true, color = :red)\nend\n\nfunction myadd(x::String, y::String)\n    print(\"The concatenated string is: \")\n    printstyled(join([x, y]), \"\\n\", bold = true, color = :red)\nend\n\nfunction myadd(x::Char, y::Char)\n    print(\"The character is: \")\n    printstyled(Char(Int(x) + Int(y)), \"\\n\", bold = true, color = :red)\nend\n\nmyadd(1, 1)\nmyadd(\"abc\", \"def\")\nmyadd('W', 'Y')\n\nThe sum is: 2\nThe concatenated string is: abcdef\nThe character is: °\n\n\nHow does Julia know which function should be called in this situation?\n\nIn fact, we defined three methods, attached to the function myadd, instead of three functions above.\nIn Julia, functions are just names. Without attached methods, they cannot do anything. Code is always stored inside methods. The type of arguments determines which method will get executed at runtime.\nYou can use methods() to check how many methods a function contains (e.g. methods(myadd)).\nIf some parameters without types specified, the type will be Any (i.e. accept all types of values).\nYou can only define functions without methods:\n\n\nfunction func_no_method end\n\nfunc_no_method(1, 1)  # Attempt to call a function with no methods\n\nLoadError: MethodError: no method matching func_no_method(::Int64, ::Int64)\nMethodError: no method matching func_no_method(::Int64, ::Int64)\n\nStacktrace:\n [1] top-level scope\n   @ In[72]:3\n\n\n\nfunc_not_defined(1, 1)  # Attempt to call a function not defined\n\nLoadError: UndefVarError: `func_not_defined` not defined\nUndefVarError: `func_not_defined` not defined\n\nStacktrace:\n [1] top-level scope\n   @ In[73]:2\n\n\n\n\n2.8.2.2 The way Julia selects the correct method of a function for each situation\nInternally, Julia has a list of functions. Every function enters another list containing the methods, which deals with different argument type combinations.\n\nFirst, Julia matches the function name (i.e. the called function should be defined).\nThen, Julia matches the type combination of arguments and parameters (i.e. the combination of types of arguments passed = the combination of types of parameters defined in a method).\n\nIn contrast with multiple dispatch, what method is used is decided only by the type of the first argument in single dispatch or object-oriented languages (i.e. in a.join(b), the function (method) used is only decided by the object a, not decided by both a and b, because in object-oriented languages, various attributes and fuctions (methods) are bound to objects of a class). If you defined a function multiple times with arguments of different types in object-oriented languages, the previous will be overwritten by the latter.\nIn statically typed languages which allows you to define a function multiple times with arguments of different types, when the code gts compiled, the compiler will pick the right function. But the selection process can only be done during compilation, it cannot be done during execution, which Julia can do.\ni.e. statically typed languages cannot deal with such a situation:\n\nfunction f1(a::Warrior, b::Warrior)\n    f2(a, b)\n    # Some other statements\nend\n\nIn the function f1, defined above, a and b must be subtypes of the Warrior type. Suppose that the function f1 is designed to allow accepting and dealing with these a and b with differnt subtypes of Warrior. When compiling the method f1, it only knows that a and b must be subtypes of Warrior but cannot know what concrete types they have. Then it won’t pick up the right method of f2 (suppose f2 has at least two methods bound to it).\n\n\n\n2.8.3 Conversion and promotion\n\n2.8.3.1 Why do we need type promotion\nInside a microprocessor, mathematical operations are always performed between identical types of numbers.\nThus, when dealing with expressions composed of different number types, all higher-level programming languages have to convert all arguments in the expression to the same number type.\nBut what should this common number type be? Figuring out this common type if what promotion is all about.\nIn most mainstream languages, the mechanisms and rules governing number promotion are hardwired into the language and detaild in the specifications of the language.\nBut Julia promotion rules are defined in the standard library, not in the internals of the Julia JIT compiler. This allows you to extend the existing system, not modifying it.\n\n\n\n\n\n\nTip\n\n\n\nYou can use the @edit macro to explore the Julia source code.\nBy prefixing with the @edit macro, Julia jumps to the definition of the function called to handled the expression (e.g. @edit 1+1).\nBefore using this, you may need to set the environment variable JULIA_EDITOR in your OS.\n\n\n\n\n2.8.3.2 How does type promotion work\nJulia performs type promotion by calling the promote() function, which promotes all arguments to a least common denominator.\ne.g. every arithmetic operation on some Number in Julia first calls promote() before performing the actual arithmetic operation.\ne.g. here, promote() promotes an integer and a floating-point number to floating-point numbers.\n\npromote(1, 2.5)  # It returns a tuple\n\n(1.0, 2.5)\n\n\n\n\n2.8.3.3 How does conversion work\n\n\n\n\n\n\nCaution\n\n\n\nConversion means converting from one type to another related type.\nThis is totally different from parsing a text string to produce a number, because a string and a number are not related types.\n\n\nFor number type conversion, it is recommended to use the constructor of the type you want to convert to.\n\nInt8(32)  # Convert a number of Int64 to Int8\n\n32\n\n\nDifferent from using type constructors, Julia calls the convert() function to achieve this.\n\nconvert(Int8, 32)\n\n32\n\n\nThe first argument of convert() is a type object (we know that all are objects in Julia).\nActually, the type of Int64 is Type{Int64}.\n\nInt64 isa Type{Int64}\n\ntrue\n\n\nYou can regard Type as a function, accepting a type argument T, and then returning the type of T - Type{T}.\n\n\n2.8.3.4 An example extending the type system\nHere we give an example of defining units for angles (redian/degree) and related operations.\n\n2.8.3.4.1 Defining unit types and constructors\n\nabstract type Angle end  # The super type of Radian and Degree\n\nstruct Radian &lt;: Angle\n    radians::Float64\n\n    # Defining customized constructor\n    function Radian(radians::Number=0.0)\n        new(radians)\n    end\nend\n\n# 1 degree = 60 minutes\n# 1 minute = 60 seconds\n# degrees, minutes, seconds (DMS)\nstruct DMS &lt;: Angle\n    seconds::Int\n\n    # Defining customized constructor\n    function DMS(degrees::Integer=0, minutes::Integer=0, seconds::Integer=0)\n        new(degrees * 60 * 60 + minutes * 60 + seconds)\n    end\nend\n\n\n\n2.8.3.4.2 Defining accessors\n\nradians(radian::Radian) = radian.radians\n\nseconds(dms::DMS) = dms.seconds % 60\n\nminutes(dms::DMS) = (dms.seconds ÷ 60) % 60\n\ndegrees(dms::DMS) = (dms.seconds ÷ 60) ÷ 60\n\ndegrees (generic function with 1 method)\n\n\n\n\n2.8.3.4.3 Displaying angles\nThe Julia REPL environment uses the show(io::IO, data) to display data of some specific type to the user.\n\nimport Base: show\n\nfunction show(io::IO, radian::Radian)\n    print(io, radians(radian), \"rad\")\nend\n\nfunction show(io::IO, dms::DMS)\n    print(io, degrees(dms), \"° \", minutes(dms), \"' \", seconds(dms), \"''\")\nend\n\nshow (generic function with 610 methods)\n\n\n\n\n\n\n\n\nCaution\n\n\n\nHere, we only want to attach new methods to the show() function, which is already defined in the Base package.\nSo we need to first import the show() function from the Base package; otherwise, it will automatically create a new function named show, which belongs to the namespace of Main, instead of Base, and then attach the newly defined method to this function.\n\n\n\n\n2.8.3.4.4 Defining type conversions\n\nimport Base: convert\n\nRadian(dms::DMS) = Radian(deg2rad(dms.seconds / 3600))\nDMS(radian::Radian) = DMS(floor(Int, rad2deg(radian.radians) * 3600))\n\nconvert(::Type{Radian}, dms::DMS) = Radian(dms)\nconvert(::Type{DMS}, radian::Radian) = DMS(radian)\n\nconvert (generic function with 673 methods)\n\n\n\n\n2.8.3.4.5 Defining type promotions\nIn fact, promote() does its job by calling the promote_rule() function.\n\nimport Base: promote_rule\n\n# If an expression contains both Radian and DMS, convert DMS into Radian\npromote_rule(::Type{Radian}, ::Type{DMS}) = Radian\n\npromote_rule (generic function with 210 methods)\n\n\n\n\n2.8.3.4.6 Defining arithmetic operations\n\nimport Base: +, -\n\n# If an expression contains both Radian and DMS, convert DMS into Radian, and then perform arithmetic operations of Radian\n+(θ::Angle, α::Angle) = +(promote(θ, α)...)\n-(θ::Angle, α::Angle) = -(promote(θ, α)...)\n\n+(θ::Radian, α::Radian) = Radian(θ.radians + α.radians)\n-(θ::Radian, α::Radian) = Radian(θ.radians - α.radians)\n\n+(θ::DMS, α::DMS) = DMS(θ.seconds + α.seconds)\n-(θ::DMS, α::DMS) = DMS(θ.seconds - α.seconds)\n\n- (generic function with 335 methods)\n\n\n\n\n2.8.3.4.7 Making pretty literals by using literal coefficients\n\nimport Base: *, /\n\n*(coeff::Number, dms::DMS) = DMS(0, 0, coeff * dms.seconds)\n*(dms::DMS, coeff::Number) = coeff * dms\n/(dms::DMS, denom::Number) = DMS(0, 0, dms.seconds / denom)\n\n*(coeff::Number, radian::Radian) = Radian(coeff * radian.radians)\n*(radian::Radian, coeff::Number) = coeff * radian\n/(radian::Radian, denom::Number) = Radian(radian.radians / denom)\n\nconst ° = DMS(1)\nconst rad = Radian(1.0)\n\n1.0rad\n\n\n\n\n2.8.3.4.8 Overriding standard sin() and cos() functions to only accept DMS and Radian\n\n\n\n\n\n\nCaution\n\n\n\nIn the following code snippet, we do not import sin() and cos() from the Base package, instead of overriding them (i.e. create a function and then attach the newly defined method to it).\n\n\n\n# The standard sin() and cos() only accept numbers regarded as the radian\nsin(rad::Radian) = Base.sin(rad.radians)\ncos(rad::Radian) = Base.cos(rad.radians)\n\nsin(dms::DMS) = sin(Radian(dms))\ncos(dms::DMS) = cos(Radian(dms))\n\n\n\n\n\n2.8.4 Representing unknown values\n\nnothing: indicates something not existed.\n\nThe nothing object is an instance of the type Nothing, which is a composite type without any fields.\n\n\n\n\n\n\nNote\n\n\n\nEvery instance of a composite type with zero fields is the same obeject.\n\nstruct MyNothing\n    # No fields defined here\nend\n\nobj1 = MyNothing()\nobj2 = MyNothing()\n\nobj1 == obj2\n\ntrue\n\n\nInstances of different composite types with zero fields are different.\n\nstruct AgainNothing\n    # No fields defined here\nend\n\nobj1 = MyNothing()\nobj2 = AgainNothing()\n\nobj1 == obj2\n\nfalse\n\n\n\n\n\nmissing: indicates something, which should have existed, but missing due to some reason (i.e. unlike nothing, missing data actually exists in the real world, but we don’t know what it is).\n\nThe concept of missing, which is of type Missing, a composite type with zero fields, is the same as that in statistics.\n\n\n\n\n\n\nCaution\n\n\n\nAny expression containing missing will be evaluated to missing!\nYou can use skipmissing() to filter missing out.\n\n\n\nNaN: indicates something, which is Not a Number.\n\nSimilarly, NaN also propagates through all calculations.\nThe only difference of the propagation behaviour between NaN and missing is that NaN always returns false when NaN is used in a comparison expression, where missing always returns missing:\n\nmissing &lt; 10, NaN &lt; 10\n\n(missing, false)\n\n\n\n\n\n\n\n\nCaution\n\n\n\n0/0 returns NaN.\nIn other words, 0/0 may be a valid number somewhere else, but now it doesn’t belong to any number we have already defined; thus it is regarded as NaN.\n\n\n\n#undef: indicates something undefined (i.e. a variable was not instantiated to a known value).\n\ne.g. Julia allows the construction of composite objects with uninitialized fields; however, it will throw an exception if you try to access an uninitialized field:\n\n\n\n\n\n\nNote\n\n\n\nBoth firstname and lastname in the type Person have no type annotations. If you define them with type annotations, Julia will automatically instantiate them to some values based on their types.\nIn other words, if some fields have no type annotations, then Julia has no way of guessing what the fields should be initialized to.\n\n\n\nstruct Person\n    firstname\n    lastname\n    Person(firstname::String, lastname::String) = new(firstname, lastname)  # This allows you to instantiate instances of Person with arguments\n    Person() = new()  # This allows you to instantiate instances of Person without arguments\nend\n\nfriend = Person()\n\nfriend\n\nPerson(#undef, #undef)\n\n\n\nfriend.firstname\n\nLoadError: UndefRefError: access to undefined reference\nUndefRefError: access to undefined reference\n\nStacktrace:\n [1] getproperty(x::Person, f::Symbol)\n   @ Base ./Base.jl:37\n [2] top-level scope\n   @ In[89]:2\n\n\n\n2.8.4.1 To solve infinite chain of initialization using parametric type\nA parametric type can be regarded as a function which accepts type parameters, and then returns a new type.\ne.g. if P is a parametric type, and T is a type, then P{T} returns a new type.\nYou can think of a parametric type as a template to make an actual type:\n\ntypeof(1:3)  # Equivalent to UnitRange(1, 3)\n\nUnitRange{Int64}\n\n\n\nFloatRange = UnitRange{Float64}\n\nUnitRange{Float64}\n\n\n\nFloatRange(1, 3)\n\n1.0:3.0\n\n\nWe can use the Union parametric type to solve infinite chain of initialization. Union accetps one or more type parameters, and then return a new type which can serve as placeholders for any of the types listed as type parameters.\n\nf1(x::Union{Int, String}) = x^3\n\nf1 (generic function with 1 method)\n\n\n\nf1(3)\n\n27\n\n\n\nf1(\"hello\")\n\n\"hellohellohello\"\n\n\n\nf1(1.1)\n\n\nMethodError: no method matching f1(::Float64)\n\nClosest candidates are:\n  f1(::Union{Int64, String})\n   @ Main In[93]:1\n\n\nStacktrace:\n [1] top-level scope\n   @ In[96]:2\n\n\n\nNow let’s solve the problem of infinite chain of initialization using parametric type:\n\nstruct Wagon\n    cargo::Float64\n    next::Union{Wagon, Nothing}  # next can be an object of either Wagon or Nothing\nend\n\n# Calculate the total tons of cargo in the train\ncargo(w::Wagon) = w.cargo + cargo(w.next)\ncargo(::Nothing) = 0.0\n\ntrain = Wagon(6, Wagon(8, Wagon(10, nothing)))\n\ncargo(train)\n\n24.0\n\n\n\n\n\n\n2.9 Collections\nCollections are objects that store and organize other objects.\n\n2.9.1 Strings\nIn computer memory, everything is a number, including characters.\n\nA character (Char type) is quoted by ''.\n\n\nInt8('A')\n\n65\n\n\n\nChar(65)\n\n'A': ASCII/Unicode U+0041 (category Lu: Letter, uppercase)\n\n\nYou can add a number to a character, which returns a new character corresponding to the sum:\n\n'A' + 3\n\n'D': ASCII/Unicode U+0044 (category Lu: Letter, uppercase)\n\n\n\nA string is quoted by \"\" or `\"\"\"\"\"\".\n\nLong lines in strings can be broken up by preceding the newline with a backslash (\\):\n\n\"This is a long \\\nline\"\n\n\"This is a long line\"\n\n\nMerging elements into a string by join():\n\nchars = 'A':'Z'\n\njoin(chars)\n\n\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n\nSplitting a string into characters by collect():\n\ncollect(\"HELLO\")\n\n5-element Vector{Char}:\n 'H': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)\n 'E': ASCII/Unicode U+0045 (category Lu: Letter, uppercase)\n 'L': ASCII/Unicode U+004C (category Lu: Letter, uppercase)\n 'L': ASCII/Unicode U+004C (category Lu: Letter, uppercase)\n 'O': ASCII/Unicode U+004F (category Lu: Letter, uppercase)\n\n\nIn fact, you can collect() any iterable objects into an array.\n\n2.9.1.1 Unicode and UTF-8\nText strings in Julia are Unicode, encoded in UTF-8 format.\nIn Unicode, each character is given a number (code point), encoded by several bytes (code units) in computer.\nUTF-8 is the current Unicode scheme used, which uses a variable number of bytes (1-4 bytes) per character to encode characters in computer.\nYou can use codepoint() to get the code point of a character, and ncodeunits() to get the code units of a character.\nIn addition, UTF-8 is backward compatible with ASCII (encoding each character with 1 byte). You can use isascii() to check whether a character is a ASCII character.\n\ncodepoint('A'), ncodeunits('A'), isascii('A')\n\n(0x00000041, 1, true)\n\n\nAs a consequence, you can type a character by typing either the character itself or its code point.\n\n'A', '\\U41', Char(0x00000041)\n\n('A', 'A', 'A')\n\n\n\n\n2.9.1.2 String indexing\nYou can use subscript index to index each character in a string, but the step between indices is not always 1. It may be an integer greater than 1.\nYou can combine the following functions to get correct indices for each character in a string:\n\nfirstindex(): return the first index in a string.\nlastindex(): return the last index in a string.\nnextind(s, i): return the next index of the element following index i in s.\neachindex(): return the indices of each element.\nUsing for loop to iterate a string.\n\n\ns = \"123一二三\"\n\ni = firstindex(s)\nwhile i &lt;= lastindex(s)\n    println((i, s[i]))\n    i = nextind(s, i)\nend\n\n(1, '1')\n(2, '2')\n(3, '3')\n(4, '一')\n(7, '二')\n(10, '三')\n\n\n\nfor i in s\n    println(i)\nend\n\n1\n2\n3\n一\n二\n三\n\n\n\nfor i in eachindex(s)\n    println((i, s[i]))\nend\n\n(1, '1')\n(2, '2')\n(3, '3')\n(4, '一')\n(7, '二')\n(10, '三')\n\n\n\n\n2.9.1.3 String operations\n\nSplitting strings\n\n\nsplit(\"abc_def_ghi\", \"_\")\n\n3-element Vector{SubString{String}}:\n \"abc\"\n \"def\"\n \"ghi\"\n\n\n\nsplit(\"abcAdefBghi\", isuppercase)\n\n3-element Vector{SubString{String}}:\n \"abc\"\n \"def\"\n \"ghi\"\n\n\n\nConverting letters between uppercases and lowercases\n\n\nmap(uppercasefirst, split(\"abc_def_ghi\", \"_\"))\n\n3-element Vector{String}:\n \"Abc\"\n \"Def\"\n \"Ghi\"\n\n\n\nisuppercase('A')  # Check whether a single letter is in the form of uppercase\n\ntrue\n\n\n\nJoining substrings\n\n\njoin([\"abc\", \"def\", \"ghi\"], \"_\")\n\n\"abc_def_ghi\"\n\n\n\nReading from and writing to the clipboard\n\n\n# Write to the clipboard\nclipboard(\"Hello, world!\")\n\n# Read from the clipboard\nclipboard()\n\n\"Hello, world!\\n\"\n\n\nOn Linux, clipboard() works only when you have installed the xsel or xclip commands.\n\nFinding whether a substring is existed in a string by using find* functions\n\n\nfindall(\"abc\", \"abc_def_abc\")\n\n2-element Vector{UnitRange{Int64}}:\n 1:3\n 9:11\n\n\n\nfindall(isuppercase, \"AaBbCc\")\n\n3-element Vector{Int64}:\n 1\n 3\n 5\n\n\n\nConverting between numbers and strings\n\n\nparse(Float64, \"3.14\")  # The default base is 10\n\n3.14\n\n\n\nparse(Int, \"1010101\", base = 2)\n\n85\n\n\n\nstring(100)  # The default base is 10\n\n\"100\"\n\n\n\nstring(100, base = 2)\n\n\"1100100\"\n\n\n\nString concatenation\n\n\nfruit = \"apple\"\n\nstring(\"This is a(an) \", fruit, \", made in China.\")\n\n\"This is a(an) apple, made in China.\"\n\n\n\n\"This is a(an) \" * fruit * \", made in China.\"\n\n\"This is a(an) apple, made in China.\"\n\n\n\nString interpolation\n\n\n\"This is a(an) $fruit, made in China.\"\n\n\"This is a(an) apple, made in China.\"\n\n\n\n\"This is a(an) $(fruit), made in China.\"\n\n\"This is a(an) apple, made in China.\"\n\n\n\nString formatting\n\nYou can use macros @printf and @sprintf to perform string formatting. These two macros are defined in the Printf module.\nIn Julia, macros are distinguished from functions with the @ prefix.\nA macro is akin to a code generator; the call site of a macro gets replaced with other code.\n\n@printf outputs the result to the console:\n\n\nusing Printf\n\n@printf(\"π = %0.2f\", pi)  # Output pi (floating-point number) with two digits\n\nπ = 3.14\n\n\n\n@sprintf returns the result as a string.\n\n\n@sprintf(\"π = %0.2f\", pi)\n\n\"π = 3.14\"\n\n\nFor a systematic specification of the format, see here.\n\n\n2.9.1.4 Nonstandard string literals\nIn Julia, you cannot express very large numbers as number literals, so you have to express them as strings that get parsed later.\ne.g.\n\n3.14e600\n\n\nParseError:\n# Error @ ]8;;file:///home/yangrui/mywd/NeuroGraph/Blogs/Computer/posts/Programming/Julia/julia_syntax_basics/In[127]#2:1\\In[127]:2:1]8;;\\\n\n3.14e600\n└──────┘ ── overflow in floating point literal\n\nStacktrace:\n [1] top-level scope\n   @ In[127]:2\n\n\n\n\nx = parse(BigFloat, \"3.14e600\")\n\n3.140000000000000000000000000000000000000000000000000000000000000000000000000003e+600\n\n\n\ntypeof(x)\n\nBigFloat\n\n\nIf you put such a expression into a loop, then it will be run at least once in each loop:\n\nfor i in 1:4\n    x = parse(BigFloat, \"3.14e600\")\n    println(x)\nend\n\n3.140000000000000000000000000000000000000000000000000000000000000000000000000003e+600\n3.140000000000000000000000000000000000000000000000000000000000000000000000000003e+600\n3.140000000000000000000000000000000000000000000000000000000000000000000000000003e+600\n3.140000000000000000000000000000000000000000000000000000000000000000000000000003e+600\n\n\nThis will damage the performance of your program.\nTo avoid having to parse strings to create objects such as BigFloat in each loop, Julia provides special string literals such as big\"3.14e600\".\nJulia will parse such a string literal only once for a for loop in your program, but run them many times (i.e. it won’t be parsed in each loop).\nIn other words, these objects such as BigFloat are created at parse time, rather than runtime.\n\nDateFormat strings\n\n\nIn the following code, the DateFormat object will be created in each loop:\n\n\nusing Dates\n\ndates = [\"21/7\", \"8/12\", \"28/2\"]\n\nfor s in dates\n    date = Date(s, DateFormat(\"dd/mm\"))  # Convert a date string into a date object\n    date_str = Dates.format(date, DateFormat(\"E-u\"))  # Convert a date object into a date string with given date format\n    println(date_str)\nend\n\nSaturday-Jul\nSaturday-Dec\nWednesday-Feb\n\n\n\nIn the following code, the DateFormat object will be created once, but the code becomes less clear at the first glance:\n\n\nusing Dates\n\ninformat = DateFormat(\"dd/mm\")\noutformat = DateFormat(\"E-u\")\n\ndates = [\"21/7\", \"8/12\", \"28/2\"]\n\nfor s in dates\n    date = Date(s, informat)  # Convert a date string into a date object\n    date_str = Dates.format(date, outformat)  # Convert a date object into a date string with given date format\n    println(date_str)\nend\n\nSaturday-Jul\nSaturday-Dec\nWednesday-Feb\n\n\n\nWe can use the dateformat literal to solve this problem:\n\n\nusing Dates\n\ndates = [\"21/7\", \"8/12\", \"28/2\"]\n\nfor s in dates\n    date = Date(s, dateformat\"dd/mm\")  # Convert a date string into a date object\n    date_str = Dates.format(date, dateformat\"E-u\")  # Convert a date object into a date string with given date format\n    println(date_str)\nend\n\nSaturday-Jul\nSaturday-Dec\nWednesday-Feb\n\n\nFor detailed date format specifications, see ?DateFormat.\n\nRaw strings\n\nIn regular Julia strings, characters such as $ and \\n have special meaning.\nIf you just want every character in a string to be literal, you need to prefix special characters with a \\ to escape them.\nBut the more convenient way is to prefix a string with raw to tell Julia that this is a raw string, which means that every character in it is literal.\n\nnum = 100\n\nraw\"What? $(num)?\"  # num won't be replaced by its actual value\n\n\"What? \\$(num)?\"\n\n\n\nRegular expressions\n\nIn Julia, you can create a Regex object by prefixing your regular expression string with a r.\n\ns = \"E-mail address: 123456@qq.com\"\n\nreplace(s, r\"\\d+(?=@)\" =&gt; \"abcdef\")  # Replace matched part with the pair value\n\n\"E-mail address: abcdef@qq.com\"\n\n\nIn the following code, match(r, s) will search for the first match of the regular expression r in s and return a RegexMatch object containing the match, or nothing if the match failed.\n\nrx = r\"\\d+:\\d+\"\n\nm = match(rx, \"11:30 in the morning; 12:00 in the noon\")\n\nm\n\nRegexMatch(\"11:30\")\n\n\nIf some parts of the regular expression are contained within parentheses, then these matched parts will be extracted out alone from the matched string, and you can retrieve these parts by indices:\n\nrx = r\"(\\d+):(\\d+)\"\n\nm = match(rx, \"11:30 in the morning; 12:00 in the noon\")\n\nm\n\nRegexMatch(\"11:30\", 1=\"11\", 2=\"30\")\n\n\n\nm[1], m[2]\n\n(\"11\", \"30\")\n\n\nFurther, you can give these parts names (?&lt;name&gt;) so you can retrieve them by names instead of indices:\n\nrx = r\"(?&lt;hour&gt;\\d+):(?&lt;minute&gt;\\d+)\"\n\nm = match(rx, \"11:30 in the morning; 12:00 in the noon\")\n\nm\n\nRegexMatch(\"11:30\", hour=\"11\", minute=\"30\")\n\n\n\nm[\"hour\"], m[\"minute\"]\n\n(\"11\", \"30\")\n\n\nIn addition, you can also iterate over a RegexMatch object, and many functions applicable to dictionaries also works with the RegexMatch object.\n\nNumber literals with big\n\nYou can use the big number literal to create extremely large numbers:\n\ntypeof(big\"100\")  # BigInt\n\nBigInt\n\n\n\ntypeof(big\"1e600\")  # BigFloat\n\nBigFloat\n\n\n\nDefining your own number literals with macros\n\n\nmacro int8_str(s)  # For a string literal with the prefix foo, such as foo\"100\", write foo_str\n    println(\"hello\")  # You can check how many times the \"hello\" will be printed when you call this macro in a loop\n    parse(Int8, s)  # Parse the number string and return an 8-bit number\nend\n\n@int8_str (macro with 1 method)\n\n\n\ntotal = 0\n\n# The \"hello\" will be printed only once,\n# which indicates that the 8-bit integer is created when the program is parsed,\n# not each time it is run\nfor _ in 1:4\n    total += int8\"10\"\nend\n\nhello\n\n\n\ntotal\n\n40\n\n\n\nMIME types\n\nMIME means Multipurpose Internet Mail Extensions, which is used as a standard to identify the file types across devices because Windows usually uses a filename extension to indicate the type of a file, while Unix-like system stores the file type in special attributes.\nIn Julia, you can create a MIME type object in the following way:\n\nMIME(\"text/html\")  # This denotes that the type of this file is a HTML page\n\nMIME type text/html\n\n\n\ntypeof(ans)  # The above MIME object with the type of MIME{Symbol(\"text/html\")}.\n\nMIME{Symbol(\"text/html\")}\n\n\nNow we know that MIME type is a parametric type. When you pass \"text/html\" to its constructor, the concrete type of the object is MIME{Symbol(\"text/html\")}. This is long and cumbersome to write so this is why Julia offers the shortcut MIME\"text/html\", which is a concrete MIME type, not an object.\n\nsay_hello(::MIME\"text/plain\") = \"hello world\"\nsay_hello(::MIME\"text/html\") = \"&lt;h1&gt;hello world&lt;/h1&gt;\"\n\nsay_hello (generic function with 2 methods)\n\n\n\nsay_hello(MIME(\"text/plain\"))\n\n\"hello world\"\n\n\n\nsay_hello(MIME(\"text/html\"))\n\n\"&lt;h1&gt;hello world&lt;/h1&gt;\"\n\n\n\n\n\n2.9.2 Arrays\n\n2.9.2.1 Types of arrays\n\n1D array\n\n\nColumn vector (type Vector)\n\nElements are separated by , inside [].\nCreating a column vector with default data type:\n\ncolumn_vector = [1, 2, 3]\n\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n\nCreating a column vector with given data type:\n\ncolumn_vector = Int8[1, 2, 3]\n\n3-element Vector{Int8}:\n 1\n 2\n 3\n\n\nYou can check what type each element in an array is by using the eltype() function. If an array contains different types of elements, it will return Any.\n\nRow vector (1 by n matrix, type Matrix)\n\nElements are separated by space.\n\nrow_vector = [1 2 3]\n\n1×3 Matrix{Int64}:\n 1  2  3\n\n\n\n2D array (type Matrix)\n\nRows are separated by ;.\n\nmatrix = [1 2 3;\n          4 5 6;\n          7 8 9]\n\n# or\nmatrix = [1 2 3; 4 5 6; 7 8 9]\n\n3×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n 7  8  9\n\n\nColumns are separated by space:\n\nmatrix = [[1, 2, 3] [4, 5, 6] [7, 8, 9]]\n\n3×3 Matrix{Int64}:\n 1  4  7\n 2  5  8\n 3  6  9\n\n\n\nArray (type Array)\n\nThe dimension of an array is greater than 2.\n\nzeros(Int64, 2, 3, 4)  # two rows, three columns, and four slices\n\n2×3×4 Array{Int64, 3}:\n[:, :, 1] =\n 0  0  0\n 0  0  0\n\n[:, :, 2] =\n 0  0  0\n 0  0  0\n\n[:, :, 3] =\n 0  0  0\n 0  0  0\n\n[:, :, 4] =\n 0  0  0\n 0  0  0\n\n\n\n\n2.9.2.2 Creating arrays by specific functions\nzeros(), ones(), fill(), rand().\n\n\n\n\n\n\nNote\n\n\n\nArrays can contain any type of element.\nYou can check the type of an object by using either typeof(), which reports the types of the object itself and its elements; or eltype(), which only reports the type of its elements.\nJulia will guess the type of elements in an array if it’s not given explicitly when an array is created.\nIf an array contains different types of elements, then the type of elements in this array will be Any, which means that you can store any type of values.\nWhen you add elements to an array by using push!(), it will check whether the type of elements to be added is consistent with the type of elements in this array, or whether the type of elements to be added can be converted to the type of elements in this array. If both failed, Julia will raise an error!\n\n\n\n\n2.9.2.3 Accessing array attributes\n\nsize(): the size of each dimension of an array.\neltype(): the type of elements in an array.\ntypeof(): the type of the object itself and its elements.\nndims(): the dimension of an array.\nlength(): total number of elements in an array.\nreshape(): change the shape of an array.\nnorm(): magnitude of a vector, calculated by the following formula (this function comes from the package LinearAlgebra).\n\n\\[\n\\|A\\|_p = \\left(\\sum_{i=1}^n |a_i|^p \\right)^{1/p}\n\\]\n\n\n2.9.2.4 Operartions on arrays\nSuppose we have:\n\namounts = [4, 2, 5, 8, 1, 10]\n\n6-element Vector{Int64}:\n  4\n  2\n  5\n  8\n  1\n 10\n\n\n\nprices = [15.0, 2.5, 3.8, 9.0, 10.5, 8.5]\n\n6-element Vector{Float64}:\n 15.0\n  2.5\n  3.8\n  9.0\n 10.5\n  8.5\n\n\nNote: both amounts and prices are column vectors.\n\nsum()\n\n\nsum(amounts)\n\n30\n\n\n\npush!(): insert one or more items into a collection.\nsort() or sort!()\n\n\n# Not modify input in place\nsort(amounts)\n\n6-element Vector{Int64}:\n  1\n  2\n  4\n  5\n  8\n 10\n\n\n\namounts\n\n6-element Vector{Int64}:\n  4\n  2\n  5\n  8\n  1\n 10\n\n\n\n# Modify input in place\nsort!(amounts)\n\n6-element Vector{Int64}:\n  1\n  2\n  4\n  5\n  8\n 10\n\n\n\namounts\n\n6-element Vector{Int64}:\n  1\n  2\n  4\n  5\n  8\n 10\n\n\n\n\n\n\n\n\nNote\n\n\n\nBy convention, Julia functions never modify any of their inputs in place.\nIf it is necessary to modify inputs in place, Julia has established the convention of tacking on an exclamation mark (!) to the name of any function which modifies its input in place instead of returning a modified version.\n\n\n\nElement-wise operations: .+, .-, .*, ./.\n\n\namounts .* prices\n\n6-element Vector{Float64}:\n 15.0\n  5.0\n 15.2\n 45.0\n 84.0\n 85.0\n\n\n\nPerforming statistics by using Statistics.\nPerforming operations of linear algebra by using LinearAlgebra.\n\n\n\n2.9.2.5 Slicing and dicing an array\nElements in a Julia array are numbered starting from 1 (i.e. 1-based indexing)!\n\nvec = [1, 2, 3, 4, 5, 6]\n\n6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n\n\n\nAccessing elements by using [index].\n\nFor arrays with dimension greater than 1, you can use [dim1, dim2, ...].\n\nvec[3]\n\n3\n\n\nOf course, subsetting and then assignment is supported:\n\nvec[3] = 100\n\n100\n\n\n\nUsing begin and end to access the first and last element.\n\n\nvec[begin], vec[end]\n\n(1, 6)\n\n\n\nUsing : to access all elements of some dimension.\n\n\nvec[:]  # Access the whole vector\n\n6-element Vector{Int64}:\n   1\n   2\n 100\n   4\n   5\n   6\n\n\n\nA = rand(Int64, 3, 3)\n\nA[:, 1]  # Access the 1st column\n\n3-element Vector{Int64}:\n -1943967381913603145\n  3809451781174345998\n -7087474726992380122\n\n\n\n\n\n\n\n\nImportant\n\n\n\nAll slice operations return copies of data.\n\nA = collect(1:6)\n\nB = A[4:end]\n\nB[1] = 100\n\nB\n\n3-element Vector{Int64}:\n 100\n   5\n   6\n\n\n\nA\n\n6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n\n\nInstead, to avoid copying data during slicing an array, you can prefix the @view macro to the slice operations, since it will only return a view of subset of the array.\n\nA = collect(1:6)\n\nB = @view A[4:end]\n\nB[1] = 100\n\nB\n\n3-element view(::Vector{Int64}, 4:6) with eltype Int64:\n 100\n   5\n   6\n\n\n\nA\n\n6-element Vector{Int64}:\n   1\n   2\n   3\n 100\n   5\n   6\n\n\n\n\n\n\n2.9.2.6 Combining arrays\ncat(), hcat(), and vcat().\n\n\n\n2.9.3 Tuples\nElements are separated by , inside ().\n\nt = (1, 2, 3)\n\n(1, 2, 3)\n\n\n\n\n\n\n\n\nNote\n\n\n\nCreating a tuple containing only one element with (1,) (i.e. adding a , after the element).\nTuples are immutable once created.\n\n\n\n2.9.3.1 Named tuples\n\nstudent = (name = \"Bob\", score  = 99, height = 2)\n\n# Index by Symbol or dot\nstudent[:name], student.name\n\n(\"Bob\", \"Bob\")\n\n\n\n# Symbol &lt;==&gt; String\nSymbol(\"price\"), string(:price)\n\n(:price, \"price\")\n\n\n\n\n\n2.9.4 Dictionaries\nA dictionary is made up of a number of pairs of key =&gt; value, where key and value can be any type of values.\n\n2.9.4.1 Creating a dictionary\n\nCreating a pair with the arrow operator =&gt;:\n\n\np = 'a' =&gt; 1  # This is a pair with type Pair\n\ntypeof(p)\n\nPair{Char, Int64}\n\n\n\ndump(p)  # You can use dump() to look at the fields of any value\n\nPair{Char, Int64}\n  first: Char 'a'\n  second: Int64 1\n\n\n\n# From the output of dump(), we can easily see how to get values of a pair\n# This will generate a tuple by putting several values in one line by separating them with a comma\n# the functions first() and last() are versatile for ordered collections\np.first, p.second, first(p), last(p), p[1], p[2]\n\n('a', 1, 'a', 1, 'a', 1)\n\n\n\nYou can provide a list of pairs to create a dictionary:\n\n\nd = Dict('a' =&gt; 1, 'b' =&gt; 2, 'c' =&gt; 3)\n\ntypeof(d)\n\nDict{Char, Int64}\n\n\n\ndump(d)  # Checking the fields of a dictionary\n\nDict{Char, Int64}\n  slots: Array{UInt8}((16,)) UInt8[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf4, 0xad, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe3, 0x00]\n  keys: Array{Char}((16,))\n    1: Char '\\x30\\x60\\x30\\x60'\n    2: Char '\\x60\\x30\\x60\\x70'\n    3: Char '\\x60\\x70\\x30\\x70'\n    4: Char '\\x70\\x30\\x60\\x30'\n    5: Char '\\x60\\x60\\x00\\x60'\n    ...\n    12: Char '\\x70\\x30\\x60\\x30'\n    13: Char '\\x60\\x60\\x00\\x60'\n    14: Char '\\x60\\x60\\x60\\x60'\n    15: Char 'b'\n    16: Char '\\0'\n  vals: Array{Int64}((16,)) [1, 1, 4, 1, 4, 1, 6, 1, 3, 1, 8, 1, 9, 1, 2, 8]\n  ndel: Int64 0\n  count: Int64 3\n  age: UInt64 0x0000000000000003\n  idxfloor: Int64 8\n  maxprobe: Int64 1\n\n\n\nPassing an array of pairs to the dictionary constructor:\n\n\na = ['a' =&gt; 1, 'b' =&gt; 2, 'c' =&gt; 3]\n\nDict(a)\n\nDict{Char, Int64} with 3 entries:\n  'a' =&gt; 1\n  'c' =&gt; 3\n  'b' =&gt; 2\n\n\n\nPassing an array of tuples containing only two elements to Dict():\n\n\na = [('a' =&gt; 1), ('b' =&gt; 2), ('c' =&gt; 3)]\n\nDict(a)\n\nDict{Char, Int64} with 3 entries:\n  'a' =&gt; 1\n  'c' =&gt; 3\n  'b' =&gt; 2\n\n\n\nCreating an empty dictionary:\n\n\nDict()\n\nDict{Any, Any}()\n\n\n\nCreating an empty dictionary with given types of keys and values:\n\n\nd = Dict{String, Int64}()\n\nDict{String, Int64}()\n\n\nIn the above case, you must provide the keys and values with matched types as set above:\n\nd[\"a\"] = 1\n\n1\n\n\n\nd['b'] = 2  # This will raise an error, because the type of 'b' is Char, not String\n\n\nMethodError: Cannot `convert` an object of type Char to an object of type String\n\nClosest candidates are:\n  convert(::Type{String}, ::JuliaSyntax.Kind)\n   @ JuliaSyntax ~/.julia/packages/JuliaSyntax/q0tWf/src/kinds.jl:975\n  convert(::Type{String}, ::Base.JuliaSyntax.Kind)\n   @ Base /cache/build/builder-amdci4-0/julialang/julia-release-1-dot-10/base/JuliaSyntax/src/kinds.jl:975\n  convert(::Type{String}, ::String)\n   @ Base essentials.jl:321\n  ...\n\n\nStacktrace:\n [1] setindex!(h::Dict{String, Int64}, v0::Int64, key0::Char)\n   @ Base ./dict.jl:367\n [2] top-level scope\n   @ In[188]:1\n\n\n\n\nCreating a dictionary from two separate arrays zipped by zip() function:\n\n\nDict(zip('a':'c', 1:3))\n\nDict{Char, Int64} with 3 entries:\n  'a' =&gt; 1\n  'c' =&gt; 3\n  'b' =&gt; 2\n\n\n\n\n\n\n\n\nNote\n\n\n\nzip() function can zip the corresponding values in a list of arrays into paired tuples, until any of them is exhausted.\n\ncollect(zip('a':'c', 1:3, 'A':'C'))\n\n3-element Vector{Tuple{Char, Int64, Char}}:\n ('a', 1, 'A')\n ('b', 2, 'B')\n ('c', 3, 'C')\n\n\n\n\n\n\n2.9.4.2 Accessing elements\n\nd = Dict(i =&gt; j for (i, j) in zip('A':'F', 'a':'f'))\n\nDict{Char, Char} with 6 entries:\n  'C' =&gt; 'c'\n  'D' =&gt; 'd'\n  'A' =&gt; 'a'\n  'E' =&gt; 'e'\n  'F' =&gt; 'f'\n  'B' =&gt; 'b'\n\n\n\nBy key:\n\n\nd['F']\n\n'f': ASCII/Unicode U+0066 (category Ll: Letter, lowercase)\n\n\n-By get(dict, key, default): if the key is not in the dict, it will return the default, instead of raising an error.\n\nget(d, 'Z', -1)  #\n\n-1\n\n\n\n\n\n\n\n\nNote\n\n\n\nYou can use keys() and values() to get all keys and values, respectively.\nYou can check whether a dictionary contains a key by using haskey(dict, key).\n\n\n\n\n\n2.9.5 Sets\n\nCreating sets\n\n\nfruits = Set([\"apple\", \"banana\", \"peach\", \"pear\", \"orange\"])\n\nSet{String} with 5 elements:\n  \"peach\"\n  \"pear\"\n  \"orange\"\n  \"banana\"\n  \"apple\"\n\n\n\nProperties of sets\n\nThe set in Julia is the very set in mathematics.\nFor a given set S, the following hold:\n\nEach element x is either in S or not in S.\nElements are unordered in S.\nThere are no duplicate elements in S.\n\n\nSet-specific operations\n\n\nUnion: ∪ or union().\nIntersection: ∩ or intersect().\nDifference: setdiff().\n\nCertainly, you can check whether an element belongs to a set or not (see Note 1), as well as whether a set is a (proper) subset of the other (see Note 2).\n\n\n\n\n\n\nNote 2: Subset operator ⊆\n\n\n\nYou can use issubset(), ⊆, ⊇, or ⊈ to judge the relationship between any two sets.\n\n\n\n\n2.9.6 Collection comprehension\nAn example in terms of an array: [F(x, y, ...) for x = rx, y = ry, ...], where the latter for is nested within the former one, and generated values can be filtered using the if keyword.\n\n[i for i in 1:10 if i%2 == 0]\n\n5-element Vector{Int64}:\n  2\n  4\n  6\n  8\n 10\n\n\n\n[(i, j, k) for (i, j, k) in zip('A':'F', 1:6, 'a':'f')]  # For (i, j, k), () is mandatory\n\n6-element Vector{Tuple{Char, Int64, Char}}:\n ('A', 1, 'a')\n ('B', 2, 'b')\n ('C', 3, 'c')\n ('D', 4, 'd')\n ('E', 5, 'e')\n ('F', 6, 'f')\n\n\n\nDict('A'+i =&gt; i+1 for i in 0:10)\n\nDict{Char, Int64} with 11 entries:\n  'K' =&gt; 11\n  'J' =&gt; 10\n  'I' =&gt; 9\n  'H' =&gt; 8\n  'E' =&gt; 5\n  'B' =&gt; 2\n  'C' =&gt; 3\n  'D' =&gt; 4\n  'A' =&gt; 1\n  'G' =&gt; 7\n  'F' =&gt; 6\n\n\n\n[[j for j in 1:6] for i in 1:3]\n\n3-element Vector{Vector{Int64}}:\n [1, 2, 3, 4, 5, 6]\n [1, 2, 3, 4, 5, 6]\n [1, 2, 3, 4, 5, 6]\n\n\nYou can specify the type of elements generated by prefixing with a wanted type:\n\nVector{Float64}[[j for j in 1:6] for i in 1:3]\n\n3-element Vector{Vector{Float64}}:\n [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]\n [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]\n [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]\n\n\n\n\n2.9.7 Generator\nCollection comprehensions can also be written without the enclosing brackets, producing an object known as a generator.\n\nsum(1/n^2 for n = 1:1000)\n\n1.6439345666815615\n\n\nNote: when writing a generator expression with multiple dimensions inside an argument list, parentheses are needed to separate the generator from subsequent arguments.\n\nmap(tuple, (1/(i+j) for i=1:2, j=1:2), [1 3; 2 4])\n\n2×2 Matrix{Tuple{Float64, Int64}}:\n (0.5, 1)       (0.333333, 3)\n (0.333333, 2)  (0.25, 4)\n\n\nGenerating a matrix:\n\n[100i + j for i=1:3, j=1:3]\n\n3×3 Matrix{Int64}:\n 101  102  103\n 201  202  203\n 301  302  303\n\n\nThe above code is equivalent to:\n\nA = zeros(Float64, 3, 3)\n\nfor i in 1:3\n    for j in 1:3\n        A[i,j] = 100i + j\n    end\nend\n\nA\n\n3×3 Matrix{Float64}:\n 101.0  102.0  103.0\n 201.0  202.0  203.0\n 301.0  302.0  303.0\n\n\n\n\n2.9.8 Enumerating values and indices\n\ncollect(enumerate('A':'F'))\n\n6-element Vector{Tuple{Int64, Char}}:\n (1, 'A')\n (2, 'B')\n (3, 'C')\n (4, 'D')\n (5, 'E')\n (6, 'F')\n\n\n\n[(i, val) for (i, val) in enumerate('A':'F')]\n\n6-element Vector{Tuple{Int64, Char}}:\n (1, 'A')\n (2, 'B')\n (3, 'C')\n (4, 'D')\n (5, 'E')\n (6, 'F')\n\n\n\n\n2.9.9 Creating an enum type with @enum macro\n\n@enum Fruit apple peach pear banana orange\n\nFruit\n\nEnum Fruit:\napple = 0\npeach = 1\npear = 2\nbanana = 3\norange = 4\n\n\n\nFruit(0), Fruit(3)  # Access by index\n\n(apple, banana)\n\n\n\ninstances(Fruit)  # Return all possible values\n\n(apple, peach, pear, banana, orange)\n\n\n\n\n2.9.10 Understanding Julia collections\nTwo key questions:\n\nWhat makes something a collection?\nWhat are the differences and similarities between different collection types?\n\n\n2.9.10.1 What makes something a collection\nAt a minimum, you are expected to extend the iterate() function for your data type with the following methods to make your data type a collection:\n\n\n\n\n\n\n\nMethod\nPurpose\n\n\n\n\niterate(iter)\nReturn the first item and the next state (e.g. the index of the next item)\n\n\niterate(iter, state)\nReturn the current item and the next state\n\n\n\nAn index-based iteration example:\n\nDefine the Cluster type to be iterated:\n\n\n# Define the Engine type\nabstract type Engine end\n\n# Define valid engine models\nstruct Panda &lt;: Engine\n    count::Integer\nend\nstruct Bear &lt;: Engine\n    count::Integer\nend\nstruct Dog &lt;: Engine\n    count::Integer\nend\n\n# Define the Cluster type, which can consist of many engine models\nstruct Cluster &lt;: Engine\n    engines::Vector{Engine}  # A vector with elements of Engine type\nend\n\n\nengine_type(::Panda) = \"Panda\"\nengine_type(::Bear) = \"Bear\"\nengine_type(::Dog) = \"Dog\"\n\nengine_count(engine::Union{Panda, Bear, Dog}) = engine.count\n\nengine_count (generic function with 1 method)\n\n\n\nExtend the iterate() function:\n\n\nimport Base: iterate\n\n# Start the iteration\nfunction iterate(cluster::Cluster)\n    cluster.engines[1], 2  # Return the first element and the index of the next element\nend\n\n# Get the next element\nfunction iterate(cluster::Cluster, i::Integer)\n    if i &gt; length(cluster.engines)\n        nothing  # Return nothing to indicate you reached the end\n    else\n        cluster.engines[i], i+1  # Don't forget to return the index of the next element\n    end\nend\n\niterate (generic function with 488 methods)\n\n\n\nIterate the Cluster instance:\n\n\ncluster = Cluster([Panda(1), Bear(5), Dog(10)])\n\nCluster(Engine[Panda(1), Bear(5), Dog(10)])\n\n\n\nfor engine in cluster\n    println(engine_type(engine), \": \", engine_count(engine))\nend\n\nPanda: 1\nBear: 5\nDog: 10\n\n\nInternally, the Julia JIT compiler will convert this for loop into a lower-level while loop, which looks like the following code:\n\nnext = iterate(cluster)  # Begin iteration\nwhile next != nothing  # Check if you reached the end of the iteration\n    (engine, i) = next\n    println(engine_type(engine), \": \", engine_count(engine))\n    next = iterate(cluster, i)  # Advance to the next element\nend\n\nPanda: 1\nBear: 5\nDog: 10\n\n\nA linked list example:\n\nimport Base: iterate\n\nstruct MyLinkedList\n    id::Int\n    name::String\n    next::Union{MyLinkedList, Nothing}\nend\n\n# First, Julia uses the instance of MyLinkedList as the unique argument to retrieve the first element and the flag of the next element\niterate(first::MyLinkedList) = ((first.id, first.name), first.next)  # The first value is what you want to retrieve; the second value is used to tell where the next element is\n# Then, Julia uses the instance of MyLinkedList and the flag of the next element, returned by the previous one to retrieve the next element and the flag of the next element, in contrast with the current one\niterate(prev::MyLinkedList, current::MyLinkedList) = ((current.id, current.name), current.next)\n# Finally, iteration-supported function needs a nothing to indicate that the iteration is done\niterate(::MyLinkedList, ::Nothing) = nothing  # Return nothing if the iteration is done\n\nx = MyLinkedList(1, \"1st\", MyLinkedList(2, \"2nd\", MyLinkedList(3, \"3rd\", nothing)))\n\nfor (id, name) in x  # The parentheses are essential\n    println(id, \": \", name)\nend\n\n1: 1st\n2: 2nd\n3: 3rd\n\n\n\n\n\n\n\n\nCaution\n\n\n\nFor multiple assignment, parentheses are mandatory in for loop; otherwise it’s trivial.\n\n\nA similar while counterpart of for:\n\nnext = iterate(x)\nwhile next != nothing\n    current, next = next\n    println(current[1], \": \", current[2])\n    next = iterate(x, next)\nend\n\n1: 1st\n2: 2nd\n3: 3rd\n\n\n\nAdding support for map() and collect()\n\nIf you run collect() on x, you will get the following error:\n\ncollect(x)\n\n\nMethodError: no method matching length(::MyLinkedList)\n\nClosest candidates are:\n  length(::Automa.ByteSet)\n   @ Automa ~/.julia/packages/Automa/Aq8Mq/src/byteset.jl:7\n  length(::Tables.DictRowTable)\n   @ Tables ~/.julia/packages/Tables/8p03y/src/dicts.jl:118\n  length(::Core.Compiler.InstructionStream)\n   @ Base show.jl:2777\n  ...\n\n\nStacktrace:\n [1] _similar_shape(itr::MyLinkedList, ::Base.HasLength)\n   @ Base ./array.jl:710\n [2] _collect(cont::UnitRange{Int64}, itr::MyLinkedList, ::Base.HasEltype, isz::Base.HasLength)\n   @ Base ./array.jl:765\n [3] collect(itr::MyLinkedList)\n   @ Base ./array.jl:759\n [4] top-level scope\n   @ In[217]:2\n\n\n\nOf course, you can simply define a length() method for MyLinkedList type like the following:\n\nimport Base: length\n\nlength(::Nothing) = 0\nlength(x::MyLinkedList) = 1 + length(x.next)\n\nlength(x)\n\n3\n\n\nHowever, the time it takes to calculate the length of MyLinkedList is proportional to its length. Such algorithms are referred to as linear or \\(O(n)\\) in big-O notation.\nInstead, we will implement an IteratorSize() method:\n\nimport Base: IteratorSize\n\nIteratorSize(::Type{MyLinkedList}) = Base.SizeUnknown()\n\nIteratorSize\n\n\nBy default, IteratorSize() is defined like the following:\n\nIteratorSize(x) = IteratorSize(typeof(x))\nIteratorSize(::Type) = HasLength()\n\n\n\n\n\n\n\nNote\n\n\n\nHere, IteratorSize() is a trait of Julia collections. It is used to indicate whether a collection has a known length.\nIn Julia, traits are defined as abstract types. The values a trait can have are determined by a concrete subtype.\nFor example, the trait IteratorSize() has subtypes SizeUnknown(), HasLength(), and so on.\nIf the IteratorSize() trait is defined as HasLength(), then Julia will call length() to determine the size of the result array produced from collect(). Instead, when you define this trait as SizeUnknown(), Julia will use an empty array for output that grows as needed.\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nfoo(::Type{Integer}) = 'A'  # Only accepting the type Integer as a valid argument\n\nfoo(Integer)\n\n'A': ASCII/Unicode U+0041 (category Lu: Letter, uppercase)\n\n\n\nfoo(Int64)\n\n\nMethodError: no method matching foo(::Type{Int64})\n\nClosest candidates are:\n  foo(::Int64)\n   @ Main In[23]:1\n  foo(::Type{Integer})\n   @ Main In[220]:1\n\n\nStacktrace:\n [1] top-level scope\n   @ In[221]:2\n\n\n\n\nfb(::Type{&lt;:Integer}) = 'B'  # Integer as well as its all subtypes are valid arguments\n\nfb(Integer)\n\n'B': ASCII/Unicode U+0042 (category Lu: Letter, uppercase)\n\n\n\nfb(Int64)\n\n'B': ASCII/Unicode U+0042 (category Lu: Letter, uppercase)\n\n\n\n\n\nAdding more interfaces to your data type\n\nTo make your data type more versatile, you may add more interfaces to your data type.\nFor example, as a collection, your data type should support getting, setting, adding, and removing elements, which are achieved by the following methods:\n\ngetindex(): this makes it possible to access elements with [].\nsetindex!(): this makes it possible to set elements with [].\npush!(): adding elements to the back of a collection.\npushfirst!(): adding elements to the front of a collection.\npop!(): removing the last element.\npopfirst!(): removing the first element.\n\nIn a word, some interfaces to a collection are achieved by implicitly calling some methods by Julia itself (e.g. looping a collection); some other interfaces to a collection are achieved by explicitly calling some methods by users (e.g. adding elements).\n\n\n\n\n2.10 Functional programming\n\n2.10.1 Higher order functions\nThese are funtions that take other functions as arguments and/or return functions.\n\nmap(f, iterable): apply f to each element of iterable.\n\n\nmap(uppercase, 'a':'z')\n\n26-element Vector{Char}:\n 'A': ASCII/Unicode U+0041 (category Lu: Letter, uppercase)\n 'B': ASCII/Unicode U+0042 (category Lu: Letter, uppercase)\n 'C': ASCII/Unicode U+0043 (category Lu: Letter, uppercase)\n 'D': ASCII/Unicode U+0044 (category Lu: Letter, uppercase)\n 'E': ASCII/Unicode U+0045 (category Lu: Letter, uppercase)\n 'F': ASCII/Unicode U+0046 (category Lu: Letter, uppercase)\n 'G': ASCII/Unicode U+0047 (category Lu: Letter, uppercase)\n 'H': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)\n 'I': ASCII/Unicode U+0049 (category Lu: Letter, uppercase)\n 'J': ASCII/Unicode U+004A (category Lu: Letter, uppercase)\n 'K': ASCII/Unicode U+004B (category Lu: Letter, uppercase)\n 'L': ASCII/Unicode U+004C (category Lu: Letter, uppercase)\n 'M': ASCII/Unicode U+004D (category Lu: Letter, uppercase)\n 'N': ASCII/Unicode U+004E (category Lu: Letter, uppercase)\n 'O': ASCII/Unicode U+004F (category Lu: Letter, uppercase)\n 'P': ASCII/Unicode U+0050 (category Lu: Letter, uppercase)\n 'Q': ASCII/Unicode U+0051 (category Lu: Letter, uppercase)\n 'R': ASCII/Unicode U+0052 (category Lu: Letter, uppercase)\n 'S': ASCII/Unicode U+0053 (category Lu: Letter, uppercase)\n 'T': ASCII/Unicode U+0054 (category Lu: Letter, uppercase)\n 'U': ASCII/Unicode U+0055 (category Lu: Letter, uppercase)\n 'V': ASCII/Unicode U+0056 (category Lu: Letter, uppercase)\n 'W': ASCII/Unicode U+0057 (category Lu: Letter, uppercase)\n 'X': ASCII/Unicode U+0058 (category Lu: Letter, uppercase)\n 'Y': ASCII/Unicode U+0059 (category Lu: Letter, uppercase)\n 'Z': ASCII/Unicode U+005A (category Lu: Letter, uppercase)\n\n\n\nreduce(f, iterable): apply f to the element of iterable in an iterable way.\n\n\nreduce(+, 1:100)\n\n5050\n\n\n\nfilter(predicate, iterable): return a subset of iterable based on predicate.\n\nNote: a predicate is a function that takes an element of iterable and always returns a Boolean value.\n\nfilter(isuppercase, ['A', 'b', 'C', 'd'])\n\n2-element Vector{Char}:\n 'A': ASCII/Unicode U+0041 (category Lu: Letter, uppercase)\n 'C': ASCII/Unicode U+0043 (category Lu: Letter, uppercase)\n\n\n\n\n\n2.11 I/O (Networking and Streams)\n\n2.11.1 I/O types\nThe Julia I/O system is centered on the abstract type IO, which has several concrete types, such as IOStream, IOBuffer, Process and TCPSocket. Each type allows you to read and write data from different I/O devices, such as files, in-memory buffers, running processes, or network connections.\n\n\n2.11.2 Stream I/O\nAll Julia streams expose at least a read() and a write() method, taking the stream as their first argument.\nThe write() method operates on binary streams, which means that values do not get converted to any canonical text representation but are written out as is.\nwrite() takes the data to write as its second argument:\n\nwrite(stdout, \"Hello World\")  # return 11, the number of bytes written to stdout\n\nHello World\n\n\n11\n\n\n\nwrite(stdout, \"Hello World\");  # supress return value 11 with ;\n\nHello World\n\n\nread() takes the type of data to be read as its second argument:\n\njulia&gt; read(stdin, Char)\nA\n# 'A': ASCII/Unicode U+0041 (category Lu: Letter, uppercase)\n\nTo read a simple byte array:\n\njulia&gt; x = zeros(UInt8, 6)\n# 6-element Vector{UInt8}:\n#  0x00\n#  0x00\n#  0x00\n#  0x00\n#  0x00\n#  0x00\n\njulia&gt; read!(stdin, x)  # read from stdin and store them in x\nabcdef\n# 6-element Vector{UInt8}:\n#  0x61\n#  0x62\n#  0x63\n#  0x64\n#  0x65\n#  0x66\n\njulia&gt; x\n# 6-element Vector{UInt8}:\n#  0x61\n#  0x62\n#  0x63\n#  0x64\n#  0x65\n#  0x66\n\nThe above is equivalent to:\n\njulia&gt; x = read(stdin, 6)\nabcdef\n# 6-element Vector{UInt8}:\n#  0x61\n#  0x62\n#  0x63\n#  0x64\n#  0x65\n#  0x66\n\njulia&gt; x\n# 6-element Vector{UInt8}:\n#  0x61\n#  0x62\n#  0x63\n#  0x64\n#  0x65\n#  0x66\n\nTo read the entire line:\n\njulia&gt; readline(stdin)\n1234567890\n# \"1234567890\"\n\nTo read all lines of an I/O stream or a file as a vector of strings using redalines(io).\nTo read every line from stdin you can use eachline(io):\n\n# you can use Ctrl + D to terminate the input (play the role of EOF) \njulia&gt; for line in eachline(stdin)\n           println(\"Found $line\")\n       end\n123456\n# Found 123456\nabcdef\n# Found abcdef\n\nRead by character:\n\njulia&gt; while !eof(stdin)\n       x = read(stdin, Char)\n       println(\"Found: $x\")\n       end\nabcdef\n# Found: a\n# Found: b\n# Found: c\n# Found: d\n# Found: e\n# Found: f\n\n\n\n2.11.3 Text I/O\nFor text I/O, using the print() or show() methods, taking the stream as their first argument, which is a mandatory convention.\nprint() is used to write a canonical text representation of a value to the output stream. If a canonical text representation exists for the value, it is printed without any adornments. If no canonical text representation exists, print() calls the show() function to display the value.\nprint() is more about customizing the output for specific messages, while show() is about displaying complex objects in a readable format. The choice between print() and show() depends on the context and the desired output format. For simple text output, print() is often sufficient, but for displaying the structure and content of complex objects, show() is the preferred choice.\nFor custom pretty-printing of your own types, define show() (which calls print() to customize the output content and style of your own type) instead of print() for it.\nOf course, for more pretty-printing, Julia also provides functions such as println() (with trailing newline), printstyled() (support some rich displays, such as colors), etc.\n\n\n2.11.4 I/O output contextual properties\nSometimes I/O output can benefit from the ability to pass contextual information into show methods. The IOContext object provides this framework for associating arbitrary metadata with an I/O object.\n\n\n2.11.5 Working with files\n\n# 1. Write content to a file with the write(filename::String, content) method\n# 2. Read the contents of a file with the read(filename::String) method, or read(filename::String, String) to the contents as a string\njulia&gt; write(\"hello.txt\", \"Hello, World!\")  # return the number of bytes written\n# 13\n\njulia&gt; read(\"hello.txt\")  # return bytes\n# 13-element Vector{UInt8}:\n#  0x48\n#  0x65\n#  0x6c\n#  0x6c\n#  0x6f\n#  0x2c\n#  0x20\n#  0x57\n#  0x6f\n#  0x72\n#  0x6c\n#  0x64\n#  0x21\n\njulia&gt; read(\"hello.txt\", String)  # return the contents as a string\n# \"Hello, World!\"\n\nInstead of directly passing a string as the file name, you can first open a file with open(filename::AbstractString, [mode::AbstractString]; lock = true) -&gt; IOStream, which returns an IOStream object that you can use to read/write things from/to the file.\n\njulia&gt; f = open(\"hello.txt\")  # open a file\n# IOStream(&lt;file hello.txt&gt;)\n\njulia&gt; readlines(f)  # do something (read/write)\n# 1-element Vector{String}:\n#  \"Hello, World!\"\n\njulia&gt; close(f)  # close the file\n\nInstead of closing the file manually, you can pass a function (accepting the IOStream returned by open() as its first argument) as the first argument of open() method, which will close the file upon completion for you.\n\njulia&gt; open(\"hello.txt\") do io\n       uppercase(read(io, String))\n       end\n# \"HELLO, WORLD!\"\n\n\n\n2.11.6 Working with networking\n\n\n\n\n\n\n\nA rough scheme of five network layers\n\n\n\n2.11.6.1 TCP (Transmission Control Protocol)\nIn a word, TCP provides highly reliable data transmission services with these features: connection-oriented, reliable, flow control, congestion control, error checking, slower than UDP due to providing such features.\n\nusing Sockets\n\n## server side\nerrormonitor(@async begin\n        server = listen(2000)  # 1. listen on a given port on a specified address; create a server waiting for incoming connections on the specified port 2000 in this case; a TCPServer socket is returned; in computer networking, a socket is a software structure that provides a bidirectional communication channel between two processes, where one process acts as a server and the other as a client\n        while true\n            sock = accept(server)  # 2. retrieve a connection to the client that is trying to connect to the server we just created\n            @async while isopen(sock)  # 3. if connected, do something between the server and the client\n                write(sock, string(\"The server has received the message from the client: \", readline(sock, keep = true)))  # 4. read something from the client and then write something to the client; keep = true means that these trailing newline characters are also returned (instead of removing them from the line before it is returned) as part of the line\n            end\n        end\nend)\n\n## client side\nclient = connect(2000)  # 1. connect to a host on a given port; return a TCPSocket socket\n\nerrormonitor(@async while isopen(client)  # 2. if connected, do something\n    write(stdout, readline(client, keep = true))  # 3. read something from the server and then print them to the termimal (stdout)\nend)\n\nprintln(client, \"Hello world from the client\")  # 3. write something to the server\n# The server has received the message from the client: Hello world from the client\n\n## finally, use close() to disconnect the socket\nclose(client)\n\nNote: some details about listen() and connect():\n\n## 1. connect([host], port::Integer) -&gt; TCPSocket  #  Connect to the host `host` on port `port` (TCPServer)\nlisten(2000)  # listen on localhost:2000 (IPv4)\nlisten(ip\"127.0.0.1\", 2000)  # equivalent to the above (IPv4)\nlisten(ip\"::1\", 2000)  # equivalent to the above (IPv6)\nlisten(IPv4(0), 2000)  # listen on port 2000 on all IPv4 interfaces\nlisten(IPv6(0), 2000)  # listen on port 2000 on all IPv6 interfaces\n\n## 2. connect(path::AbstractString) -&gt; PipeEndpoint  # connect to the named pipe (Windows) / UNIX domain socket at `path` (PipeServer)\nlisten(\"testsocket\")  # listen on a UNIX domain socket\nlisten(\"\\\\\\\\.\\\\pipe\\\\testsocket\")  # listen on a Windows named pipe (\\\\.\\pipe\\)\n\nThe difference between TCP and named pipes or UNIX domain sockets is subtle and has to do with the accept() and connect() methods:\n\naccept(server[, client])  # Accepts a connection on the given server and returns a connection to the client. An uninitialized client stream may be provided, in which case it will be used instead of creating a new stream.\n\nconnect([host], port::Integer) -&gt; TCPSocket  # Connect to the host `host` on port `port`.\nconnect(path::AbstractString) -&gt; PipeEndpoint  # Connect to the named pipe / UNIX domain socket at path.\n\nResolving IP addresses:\n\njulia&gt; getaddrinfo(\"google.com\")\n# ip\"59.24.3.174\"\n\n\n\n2.11.6.2 UDP (User Datagram Protocol)\nUDP provides no such features as provided by TCP.\nA common use for UDP is in multicast applications.\n\n## receiver\nusing Sockets\n\ngroup = ip\"226.6.8.8\"  # Choose a valid IP address for multicast: for IPv4, the multicast address range is from 224.0.0.0 to 239.255.255.255. Any address within this range is designated for multicast use. For IPv6, the multicast range begins with ff, such as ff05::5:6:7.\nsocket = UDPSocket()  # Open a UDP socket.\nbind(socket, ip\"0.0.0.0\", 6688)  # Bind socket to the given host:port. Note that 0.0.0.0 (IPv4) / :: (IPv6) will listen on all devices (listen on all available network interfaces and all IPv4 / IPv6 addresses associated with the host machine. When binding to a port, make sure that the port number is not in use by another application and that it's not a well-known or registered port that has a specific protocol associated with it.\njoin_multicast_group(socket, group)  # Join a socket to a particular multicast group.\nprintln(String(recv(socket)))  # For recv():  read a UDP packet from the specified socket, and return the bytes received. This call blocks.\n# Hello over IPv4\nleave_multicast_group(socket, group)  #  Remove a socket from a particular multicast group.\nclose(socket)  # Close the socket.\n\n## sender\nusing Sockets\n\ngroup = ip\"226.6.8.8\"\nsocket = UDPSocket()\nsend(socket, group, 6688, \"Hello over IPv4\")  #  Send msg over socket to host:port. It is not necessary for a sender to join the multicast group.\nclose(socket)\n\n\n\n\n\n2.12 Parametric types\nYou can think of the expression S=P{T} as parametric type P taking a type parameter T and returning a new concrete type S. Both T and S are concrete types, while P is just a template for making types.\n\n2.12.1 Defining parametric methods\n\nfunction linearsearch(haystack::AbstractVector{T}, needle::T) where T\n    for (i, x) in enumerate(haystack)\n        if needle == x\n            return i\n        end\n    end\nend\n\nlinearsearch([1, 4, 6, 8], 6)\n\n3\n\n\n\nlinearsearch([1, 4, 6, 8], \"six\")\n\n\nMethodError: no method matching linearsearch(::Vector{Int64}, ::String)\n\nClosest candidates are:\n  linearsearch(::AbstractVector{T}, ::T) where T\n   @ Main In[229]:1\n\n\nStacktrace:\n [1] top-level scope\n   @ In[230]:2\n\n\n\nIn this example, the linearsearch() is a parametric method, which takes a type parameter T, defined in the where T clause. You can define more than one type parameter in the where clause (e.g. where {T, S}).\n\n\n2.12.2 Defining parametric types\n\n\"A point at coordinate (x, y)\"\nstruct Point{T}\n    x::T\n    y::T\nend\n\nPoint\n\n\nYou can impose constraints on the type parameter T with subtype operator &lt;::\n\nstruct RPoint{T&lt;:Number}\n    x::T\n    y::T\nend\n\nWhen creating a point with Point, you can let Julia to infer the type parameter from arguments or explicitly set the type parameter:\n\nPoint(1, 2), Point{Int}(3, 4)\n\n(Point{Int64}(1, 2), Point{Int64}(3, 4))\n\n\nIn fact, sum(xs::Vector) is the same as sum(xs::Vector{T}) where T.\nIn summary, parametric types can improve the type safety (stricter type checking), performance (more type restrictions, less type-related jobs), and memory usage (more type restrictions, more precise assignment of memory).\n\n\n\n2.13 Scope of variables\n\n2.13.1 Introduction\nThe scope of a variable is the region of code within which a variable is accessible. Variable scoping helps avoid variable naming conflicts.\nThere are two main types of scopes in programming languages: lexical scope (also called static scope) and dynamic scope.\nIn languages with lexical scope, the name resolution depends on the location in the source code and the lexical context, where the named variable is defined. In contrast, in languages with dynamic scope, the name resolution depends on the program state and the runtime context when the name is encountered.\nIn a word, with lexical scope a name is resolved by searching the local lexical context, then if that fails, by searching the outer lexical context, and so on; with dynamic scope, a name is resolved by searching the local execution context, then if that fails, by searching the outer execution context, and so on, progressing up the call stack.\nJulia uses lexical scope. Further, there are two main types of scopes in Julia, global scope and local scope. The latter can be nested.\nIn Julia, different constructs may introduce different types of scopes.\n\n\n2.13.2 Scope constructs\nThe constructs introducing scopes are:\n\n\n\n\n\n\n\n\nConstruct\nScope type\nAllowed within\n\n\n\n\nmodule, baremodule\nglobal\nglobal\n\n\nstruct\nsoft local\nglobal\n\n\nfor, while, try\nsoft local\nglobal, local\n\n\nmacro\nhard local\nglobal\n\n\nfunctions, do blocks, let blocks, comprehensions, generators\nhard local\nglobal, local\n\n\n\nNote: begin blocks and if blocks do not introduce scopes.\n\n\n2.13.3 Global scope\nEach module introduces a global scope.\nModules can introduce variables of other modules into their scopes through the using or import statement, or through qualified access using the dot notation.\n\nmodule A\n    a = 1  # a is a global variable in A's scope\nend\n\nmodule B\n    module C\n        c = 2\n    end\n    b = C.c  # can access the namespace of a nested global scope through a qualified access\n\n    import ..A  # makes module A available\n    d = A.a\nend\n\nIf a top-level expression (e.g. a begin or if block) contains a variable declared with keyword local, then that variable is not accessible outside that expression.\n\nx = 1\nbegin\n    local x = 0\n    @show x\nend\n@show x\n\nx = 0\nx = 1\n\n\n1\n\n\nNote: the REPL is in the global scope of the module Main.\n\n\n2.13.4 Local scope\nA local scope nested inside another local/global scope can see variables in all the outer scopes in which it is contained. Outer scopes, on the other hand, cannot see variables in inner scopes.\nWhen x = &lt;value&gt; occurs in a local scope, Julia will apply the following rules to decide what the expression means:\n\nExisting local: if x is already a local variable, then the existing local x is assigned.\nHard scope: if x is not already a local variable and this assignment occurs inside of any hard scope construct, then a new local variable named x is created in the scope of the assignment.\nSoft scope: if x is not already a local variable and all of the scope constructs containing the assignment are soft scopes, the behavior depends on whether the global variable x is defined:\n\nIf global x is undefined, a new local variable named x is created in the scope of the assignment;\nIf global x is defined, then the following rules are applied:\n\nIn interactive mode, the global variable x is assigned;\nIn non-interactive mode, an ambiguity warning is printed and a new local variable named x is created in the scope of the assignment.\n\n\n\nTherefore, in non-interactive mode, the soft scope and hard scope behaves identically except that a warning is printed when an implicitly local variable shadows a global variable in the soft scope.\nNote: in Julia, a variable cannot be a non-local variable, meaning that it is either a local variable or a global variable, which is determined regardless of the order of expressions. As a consequence, if you assign to an existing local, it always updates that existing local; therefore, you can only shadow a local by explicitly declaring a new local in a nested scope with the local keyword.\n\nfunction outer_foo()\n    x = 99  # x is a local variable in the outer_foo's scope\n    @show x\n    let\n        x = 100  # updates the local variable x defined in the outer_foo's scope\n    end\n    @show x\n    return nothing\nend\n\nouter_foo (generic function with 1 method)\n\n\n\ncode = \"\"\"\ns = 0 # global\nfor i = 1:10\n    t = s + i # new local t\n    s = t # new local s with warning\nend\ns, # global; should be 0\n@isdefined(t) # global; should be false\n\"\"\";\n\ninclude_string(Main, code)\n\nLoadError: LoadError: UndefVarError: `s` not defined\nin expression starting at string:2\nLoadError: UndefVarError: `s` not defined\nin expression starting at string:2\n\nStacktrace:\n [1] top-level scope\n   @ ./string:3\n [2] eval\n   @ ./boot.jl:385 [inlined]\n [3] include_string(mapexpr::typeof(identity), mod::Module, code::String, filename::String)\n   @ Base ./loading.jl:2076\n [4] include_string\n   @ ./loading.jl:2086 [inlined]\n [5] include_string(m::Module, txt::String)\n   @ Base ./loading.jl:2086\n [6] top-level scope\n   @ In[236]:12\n\n\n\n\n\n\n\n\nCaution\n\n\n\nSo don’t forget to use the global keyword to declare a variable x if you want to use a global x instead of a local x in seeing a for loop in non-interactive mode:\n\ncode = \"\"\"\ns = 0\nfor i in 1:100\n    global s = s + i\nend\n@show s\n\"\"\"\n\ninclude_string(Main, code)\n\ns = 5050\n\n\n5050\n\n\n\n\n\n\n2.13.5 let blocks\nlet blocks create a new hard local scope and introduce new variable bindings each time they run. The variable need not be immediately assigned. The value evaluated from the last expression is returned.\n\nlet x  # x need not be immediately assigned\n    x = 1\nend\n\n1\n\n\nThe let syntax accepts a comma-separated series of assignments and variable names.\n\nx, y = 1, 2\n\nlet x = x, y = 20\n    @show x, y\nend\n\n(x, y) = (1, 20)\n\n\n(1, 20)\n\n\nNote: in the above example, x = x is possible, since the assignment is evaluated from the right to the left. x in the right-hand side is global; x in the left-hand side is local.\n\n\n2.13.6 Loops\nA for loop iteration variable is always a new local variable; otherwise you declare it using the outer keyword.\n\nfunction for_f1()\n    i = 0\n    for i = 1:3  # i is local\n    end\n    return i\nend\n\nfor_f1()\n\n0\n\n\n\nfunction for_f2()\n    i = 0\n    for outer i = 1:3  # i is global\n    end\n    return i\nend\n\nfor_f2()\n\n3\n\n\nA noteworthy fact is that you must declare i using the global keyword in the following code or an error will be raised when you run it in non-interactive mode:\n\ncode = \"\"\"\n    i = 10\n    while i &lt;= 12\n        i = i + 1  # i is regarded as a local instead of a global since this is determined regardless of the order of expressions\n        @show i\n    end\n    @show i\n\"\"\"\n\ninclude_string(Main, code)\n\nLoadError: LoadError: UndefVarError: `i` not defined\nin expression starting at string:2\nLoadError: UndefVarError: `i` not defined\nin expression starting at string:2\n\nStacktrace:\n [1] top-level scope\n   @ ./string:3\n [2] eval\n   @ ./boot.jl:385 [inlined]\n [3] include_string(mapexpr::typeof(identity), mod::Module, code::String, filename::String)\n   @ Base ./loading.jl:2076\n [4] include_string\n   @ ./loading.jl:2086 [inlined]\n [5] include_string(m::Module, txt::String)\n   @ Base ./loading.jl:2086\n [6] top-level scope\n   @ In[242]:11\n\n\n\ncode = \"\"\"\n    i = 10\n    while i &lt;= 12\n        global i = i + 1  # i is global\n        @show i\n    end\n    @show i\n\"\"\"\n\ninclude_string(Main, code)\n\ni = 11\ni = 12\ni = 13\ni = 13\n\n\n13\n\n\n\n\n2.13.7 Constants\nThe const declaration should only be used in global scope on globals. It is difficult for the compiler to optimize code involving global variables, since their values (or even their types) might change at almost any time. If a global variable will not change, adding a const declaration solves this performance problem.\nLocal constants are quite different. The compiler is able to determine automatically when a local variable is constant, so local constant declarations are not necessary, and in fact are currently not supported.\n\n\n2.13.8 Typed globals\nA global can be declared to always be of a constant type by using the syntax global x::T or upon assignment as x::T = 123.\nOnce a global is declared to be of a constant type, it cannot be assigned to values which cannot be converted to the specified type. In addition, a global has either been assigned to or its type has been set, the binding type is not allowed to change.\n\n\n\n2.14 Parallel computing\n\n2.14.1 Asynchronous tasks\nA task has a create-start-run-finish lifecycle, allowing suspending and resuming computations.\n\nCreate a task by calling the Task constructor on a 0-argument function or using the @task macro: Task(() -&gt; x) is equivalent to @task x.\nStart a task by calling schedule(x) (i.e., add it to an internal queue of tasks).\n\nNote: for convenience, you can use @async x to create and start a task at once (equivalent to schedule(@task x)).\n\nYou can then call wait(x) to wait the task to exit.\n\n\nfunction mysleep(seconds)\n    sleep(seconds)\n    println(\"done\")\nend\n\nt = Task(() -&gt; mysleep(5))  # equivalent to `@task mysleep(5)`\nschedule(t)\nwait(t)\n\ndone\n\n\n\nCommunicating with channels.\n\n\nYou can call the Channel{T}(size) constructor to create a channel with an internal buffer that can hold a maximum of size objects of type T (Channel(0) constructs an unbuffered channel).\nDifferent tasks can write to the same channel concurrently via put!(channel, x) calls.\nDifferent tasks can read data concurrently via take!(channel) (remove and return a value from a channel) or fetch() (return the first available value from a channel without removing) calls.\nIf a channel is empty, readers (on a take!() call) will block until data is available.\nIf a channel is full, writers (on a put!() call) will block until space becomes available.\nYou can use isready(channel) to check for the presence of any object in the channel, and use wait(channel) to wait for an object to become available.\nYou can use close(channel) to close a channel. On a closed channel, put!() will fail, but take!() and fetch() can still successfully return any existing values until it is emptied.\nYou can associate a channel with a task using the Channel(f) constructor (f is a function accepting a single argument of type Channel) or the bind(channel, task) function. This means that the lifecycle of the channel is bound to this task (i.e., you don’t have to close the channel explicitly, while the channel will be closed the moment the task exits). In addition, it will not only log any unexpected failures, but also force the associated resources to close and propagate the exception everywhere. Compared with bind(), errormonitor(task) only prints an error log if task fails.\nThe returned channel can be used as an iterable object in a for loop, in which case the loop variable takes on all the produced values. The loop is terminated when the channel is closed.\n\n\njobs = Channel{Int}(32)\nresults = Channel{Tuple}(32)\n\nfunction do_work()\n    for job_id in jobs\n        exec_time = rand()\n        sleep(exec_time)\n\n        put!(results, (job_id, exec_time))\n    end\nend\n\nfunction make_jobs(n)\n    for i in 1:n\n        put!(jobs, i)\n    end\nend\n\nn = 12\n\nerrormonitor(@async make_jobs(n))\n\nfor i in 1:4  # spawn 4 tasks\n    errormonitor(@async do_work())\nend\n\nsum_time = 0\neval_time = @elapsed while n &gt; 0\n    job_id, exec_time = take!(results)\n    println(\"$job_id finished in $(round(exec_time; digits = 2)) seconds\")\n    global n = n - 1\n    global sum_time = sum_time + exec_time\nend\nprintln(\"The evaluated time is $eval_time seconds\")\nprintln(\"The accumulated time is $sum_time seconds\")\n\n2 finished in 0.21 seconds\n1 finished in 0.23 seconds\n3 finished in 0.62 seconds\n6 finished in 0.47 seconds\n7 finished in 0.18 seconds\n4 finished in 0.89 seconds\n5 finished in 0.78 seconds\n11 finished in 0.09 seconds\n10 finished in 0.62 seconds\n12 finished in 0.39 seconds\n8 finished in 0.79 seconds\n9 finished in 0.97 seconds\nThe evaluated time is 1.87878966 seconds\nThe accumulated time is 6.230269712513654 seconds\n\n\n\nMore task operations\n\nTask operations are built on a low-level primitive called yieldto(task, value), which suspends the current task, switches to the specified task, and causes that task’s last yieldto() call to return the specified value.\nA few other useful functions of tasks:\n\ncurrent_task(): gets a reference to the currently-running task.\nistaskdone(): queries whether a task has exited.\nistaskstarted(): queries whether a task has run yet.\ntask_local_storage(): manipulates a key-value store specific to the current task.\n\n\n\n2.14.2 Multi-threading\nJulia’s multi-threading, provided by the Threads module, a sub-module of Base, provides the ability to schedule tasks simultaneously on more than one thread or CPU core, sharing memory.\n\n2.14.2.1 Starting Julia with multiple threads\nThe number of execution threads is controlled either by using -t/--threads (julia -t 4) command line argument or by using the JULIA_NUM_THREADS (export JULIA_NUM_THREADS=4, which must be done before starting Julia, and setting it in startup.jl file by using ENV is too late) environment variable. When both are specified, the -t/--threads takes precedence. Both options support the auto argument, which let Julia itself infer a useful default number of threads to use.\nNote: The number of threads specified with -t/--threads is propagated to processes that are spawned using the -p/--procs or --machine-file command line option. For example, julia -p 2 -t 2 spawns 1 main process and 2 worker processes, and all three processes have 2 threads enabled. For more fine grained control over worker threads use addprocs() and pass -t/--threads as exeflags.\nNote: The Garbage Collector (GC) can use multiple threads. You can specify it either by using the --gcthreads command line argument or by using the JULIA_NUM_GC_THREADS environment variable.\nAfter starting Julia with multiple threads, you can check it with the following functions:\n\nThreads.nthreads()\n\n1\n\n\n\nThreads.threadid()\n\n1\n\n\n\n\n2.14.2.2 Thread pools\nThere are two types of thread pools: :interactive (often used for interactive tasks) and :default (often used for long duration tasks).\nYou can set the number of execution threads available for each thread pool of the two by: -t 3,1 or JULIA_NUM_THREADS=3,1, which means that there are 3 threads in the :default thread pool, and 1 thread in the :interactive thread pool. Both numbers can be replaced with the word auto.\nCorresponding helper functions:\n\nusing Base.Threads\n\nprintln(nthreadpools())  # the number of thread pools\n\nprintln(threadpool(1))  # which thread pool the thread 1 belongs to\n\nprintln(nthreads(:default))  # the number of threads available for the :default thread pool\n\n2\ndefault\n1\n\n\n\n\n2.14.2.3 Spawning threads\n\n@spawn: you can specify which thread pool should be used by the spawned thread.\n\n\nThreads.@spawn :interactive begin; println(\"task done\"); end\n\ntask done\n\n\nTask (done) @0x00007fef63892590\n\n\n\n@threads: this macro is affixed in front of a for loop to indicate to Julia that the loop is a multi-threaded region.\n\n\na = zeros(10)\n\n# the iteration space is plit among the threads\nThreads.@threads for i = 1:10\n    a[i] = Threads.threadid()\nend\n\na\n\n10-element Vector{Float64}:\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n\n\nNote: after a task starts running on a certain thread it may move to a different thread although the :static schedule option for @threads does freeze the thread id. This means that in most cases threadid() should not be treated as constant within a task.\n\n\n2.14.2.4 Avoiding data race\nBe very careful about reading any data if another thread might write to it!\nInstead, always use the lock pattern when changing data accessed by other threads.\n\nlk = ReentrantLock()\n\n# method 1\nlock(lk) do \n    use(a)\nend\n\n# method 2\nbegin\n    lock(lk)\n    try\n        use(a)\n    finally\n        unlock(lk)  # each lock must be matched by an unlock\n    end\nend\n\nA toy example:\n\nWithout multi-threading:\n\n\n# the correct result\nfunction sum_single(x)\n    s = 0\n    for i = x\n        s += i\n    end\n    s\nend\n\n@time sum_single(1:1_000_000)  # in Julia, the underscore (_) can be used as a separator in literal integers to enhance readability\n\n  0.000001 seconds\n\n\n500000500000\n\n\n\nData race often leads to non-deterministic results:\n\n\n# with data race and the result is non-deterministic\nfunction sum_multi_bad(x)\n    s = 0\n    Threads.@threads for i = x\n        s += i\n    end\n    s\nend\n\nfor i = 1:6\n    println(sum_multi_bad(1:1_000_000))\nend\n\n500000500000\n500000500000\n500000500000\n500000500000\n500000500000\n500000500000\n\n\n\nAdd lock when performing data race operations:\n\n\n# locked version\n# the result is correct\nlk = ReentrantLock()\n\nfunction sum_multi_lock(x)\n    s = 0\n    Threads.@threads for i = x\n        lock(lk) do\n            s += i\n        end\n    end\n    s\nend\n\nfor i = 1:6\n    println(sum_multi_lock(1:1_000_000))\nend\n\n500000500000\n500000500000\n500000500000\n500000500000\n500000500000\n500000500000\n\n\n\nSplit data into chunks –&gt; use its own internal buffer for each thread –&gt; collect all results of chunks:\n\n\n# split the sum into chunks that are race-free\n# collect the result of each chunk\n# add the results together\nfunction sum_multi_chunk(x)\n    chunks = Iterators.partition(x, length(x) ÷ Threads.nthreads())\n    tasks = map(chunks) do chunk\n        Threads.@spawn sum_single(chunk)\n    end\n    chunk_sums = fetch.(tasks)\n    return sum_single(chunk_sums)\nend\n\n@time sum_multi_chunk(1:1_000_000)\n\n  0.026836 seconds (15.59 k allocations: 1.081 MiB, 99.62% compilation time)\n\n\n500000500000\n\n\n\nUse atomic operations:\n\nJulia supports accessing and modifying values atomically, that is, in a thread-safe way to avoid data race.\nA value (which must be of a primitive type) can be wrapped as Threads.Atomic{T}(value) to indicate it must be accessed in this way.\nIn a word, perform atomic operations on atomic values to avoid data race.\n\nfunction sum_multi_atomic(x)\n    s = Threads.Atomic{Int}(0)  # s is an atomic value of type Int\n    Threads.@threads for i = x\n        Threads.atomic_add!(s, i)  # perform atomic operation atomic_add! (add i to s, and return the old value) on atomic value s\n    end\n    s\nend\n\nres = sum_multi_atomic(1:1_000_000)\nres[]  # Atomic objects can be accessed using the [] notation\n\n500000500000\n\n\n\n\n\n2.14.3 Multi-processing and Distributed computing\nDistributed computing provided by module Distributed runs multiple Julia processes with separate memory spaces.\n\n2.14.3.1 Starting and managing multiple processes\nIn Julia, each process has an associated identifier. The process providing the interactive Julia prompt always has an id equal to 1, called the main process.\nBy default, the processes used for parallel operations are referred to as “workers”. When there is only 1 process, process 1 is considered a worker. Otherwise, workers are considered to be all processes other than process 1. As a result, adding 2 or more processes is required to gain benefits from parallel processing methods. Adding a single process is beneficial if you just wish to do other things in the main process while a long computation is running on the worker.\nJulia has built-in support for two types of clusters:\n\nA local cluster specified with the -p/--procs option (implicitly loads module Distributed).\nA cluster spanning machines using the --machine-file option.\n\nThis uses a passwordless ssh login to start Julia worker processes from the same path as the current host on the specified machines.\nEach machine definition takes the form [count*] [user@]host[:port] [bind_addr[:port]]. count is the number of workers to spawn on the node, and defaults to 1; user defaults to the current user; port defaults to the standard ssh port; bind_addr[:port] specifies the IP address and port that other workers should use to connect to this worker.\nNote: in Julia, distribution of code to worker processes relies on Serialization.serialize (the need for data serialization and deserialization arises primarily due to the requirement to convert complex data structures into formats that can be transmitted across a network when different nodes communicate with each other), so it is advised that all workers on all machines use the same version of Julia to ensure compatibility of serialization and deserialization.\nDistributed package provides some useful functions for starting and managing processes within Julia:\n\nusing Distributed  # Module Distributed must be explicitly loaded on the master process before invoking addprocs() and other functions if you want to start distributed computing within Julia, instead of using command line options. It is automaticaly made available on the worker processes.\n\naddprocs()  # launch worker processes using the LocalManager (the same as -p), SSHManager (the same as --machine-file) or other cluster managers of type ClusterManager\n\nprocs()  # return a list of all process identifiers\n\nnprocs()  # return the number of available processes\n\nworkers()\n\nnworkers()\n\nmyid()  # get the id of the current process\n\nNote: workers do not run a ~/.julia/config/startup.jl startup script, nor do they synchronize their global state with any of the other running processes. You may use addprocs(exeflags = \"--project\") to initialize a worker with a particular environment.\n\n\n\n\n\n\nNetwork requirements for LocalManager and SSHManager\n\n\n\n\nThe master process does not listen on any port. It only connects out to the workers.\nEach worker binds to only one of the local interfaces and listens on an ephemeral port number assigned by the OS.\nLocalManager, used by addprocs(N), by default binds only to the loopback interface. An addprocs(4) followed by an addprocs([\"remote_host\"]) will fail. To create a cluster comprising their local system and a few remote systems, it can be done by explicitly requesting LocalManager to bind to an external network interface via restrict keyword argument: addprocs(4; restrict = false).\nSSHManager, used by addprocs(list_of_remote_hosts), launches workers on remote hosts via SSH. By default SSH is only used to launch Julia workers. Subsequent master-worker and worker-worker connections use plain, unencrypted TCP/IP sockets. The remote hosts must have passwordless login enabled. Additional SSH flags or credentials may be specified via keyword argument sshflags.\n\n\n\n\n\n\n\n\n\nCluster cookie\n\n\n\nAll processes in a cluster share the same cookie which, by default, is a randomly generated string on the master process, and can be accessed via cluster_cookie(), while cluster_cookie(cookie) sets it and returns the new cookie. It can also be passed to the workers at startup via --worker=&lt;cookie&gt;.\n\n\n\n\n\n\n\n\nSpecifying network topology\n\n\n\nThe keyword argument topology to addprocs() is used to specify how the workers must be connected to each other. The default is :all_to_all, meaning that all workers are connected to each other.\n\n\n\n\n2.14.3.2 Starting distributed programming\nDistributed programming in Julia is built on two primitives:\n\nRemote references: a remote reference is an object of type RemoteChannel that can be used from any process to refer to an object stored on a particular process. Multiple processes can communicate via RemoteChannel.\nRemote calls: a remote call is a request by one process to call a certain function on certain arguments on another (possibly the same) process. A remote call returns a Future object to its result. Then you can use wait() to wait the function running to finish or use fetch() to get the returned value by the called function.\n\nLaunch remote calls:\n\n@spawn p expr  # Create a closure around an expression and run the closure asynchronously on process p. If p is set to :any, then the system will pick a process to use automatically.\n@fetchfrom p expr  # equivalent to fetch(@spawnat p expr)\n\nremotecall(f, pid, ...)  # Call a function f asynchronously on the given arguments ... on the specified process pid.\nremotecall(f, pool, ...)  # Give a pool of type WorkerPool instead of a pid. It will wait for and take a free worker from pool to use.\nremotecall_fetch()  # equivalent to fetch(remotecall())\nremote_do(f, id, ...)  # Run f on worker id asynchronously. Unlike remotecall, it does not store the result of computation, nor is there a way to wait for its completion.\n\n\nusing Distributed\n\naddprocs(2)  # add 2 wrokers via LocalManager\n\nr = remotecall(rand, 2, 3, 3)  # run rand(3, 3) on process 2\ns = @spawnat 2 1 .+ fetch(r)  # run expr 1 .+ fetch(r) on process 2 (note: this forms a closure () -&gt; 1 .+ fetch(r) which contains the global variable r)\nfetch(s)\n\n3×3 Matrix{Float64}:\n 1.89343  1.00515  1.07274\n 1.04054  1.07922  1.32374\n 1.6222   1.11747  1.36632\n\n\nNote: once fetched, a Future will cache its value locally. Further fetch() calls don not entail a network hop. Once all referencing Futures have fetched, the remote stored value is deleted.\n\n\n2.14.3.3 Code and data availability\nBefore spawning a process, you must ensure that your code and data are available on any process that runs it.\n\nCode availability\n\n\nfunction rand2(dims...)\n    return 2 * rand(dims...)\nend\n\nrand2(2, 2)\n\n2×2 Matrix{Float64}:\n 1.42344  0.173776\n 1.94838  1.10593\n\n\n\nusing Distributed\n\naddprocs(2)\n\n\n# rand2 is defined in the main process\n# so process 1 knew it but the others did not\nfetch(@spawnat :any rand2(2, 2))\n\n\nOn worker 2:\nUndefVarError: `#rand2` not defined\nStacktrace:\n  [1] deserialize_datatype\n    @ ~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Serialization/src/Serialization.jl:1399\n  [2] handle_deserialize\n    @ ~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Serialization/src/Serialization.jl:867\n  [3] deserialize\n    @ ~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Serialization/src/Serialization.jl:814\n  [4] handle_deserialize\n    @ ~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Serialization/src/Serialization.jl:874\n  [5] deserialize\n    @ ~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Serialization/src/Serialization.jl:814 [inlined]\n  [6] deserialize_global_from_main\n    @ ~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Distributed/src/clusterserialize.jl:160\n  [7] #5\n    @ ~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Distributed/src/clusterserialize.jl:72 [inlined]\n  [8] foreach\n    @ ./abstractarray.jl:3097\n  [9] deserialize\n    @ ~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Distributed/src/clusterserialize.jl:72\n [10] handle_deserialize\n    @ ~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Serialization/src/Serialization.jl:960\n [11] deserialize\n    @ ~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Serialization/src/Serialization.jl:814\n [12] handle_deserialize\n    @ ~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Serialization/src/Serialization.jl:871\n [13] deserialize\n    @ ~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Serialization/src/Serialization.jl:814\n [14] handle_deserialize\n    @ ~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Serialization/src/Serialization.jl:874\n [15] deserialize\n    @ ~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Serialization/src/Serialization.jl:814 [inlined]\n [16] deserialize_msg\n    @ ~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Distributed/src/messages.jl:87\n [17] #invokelatest#2\n    @ ./essentials.jl:892 [inlined]\n [18] invokelatest\n    @ ./essentials.jl:889 [inlined]\n [19] message_handler_loop\n    @ ~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Distributed/src/process_messages.jl:176\n [20] process_tcp_streams\n    @ ~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Distributed/src/process_messages.jl:133\n [21] #103\n    @ ~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Distributed/src/process_messages.jl:121\n\nStacktrace:\n [1] remotecall_fetch(f::Function, w::Distributed.Worker, args::Distributed.RRID; kwargs::@Kwargs{})\n   @ Distributed ~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Distributed/src/remotecall.jl:465\n [2] remotecall_fetch(f::Function, w::Distributed.Worker, args::Distributed.RRID)\n   @ Distributed ~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Distributed/src/remotecall.jl:454\n [3] remotecall_fetch\n   @ ~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Distributed/src/remotecall.jl:492 [inlined]\n [4] call_on_owner\n   @ ~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Distributed/src/remotecall.jl:565 [inlined]\n [5] fetch(r::Future)\n   @ Distributed ~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Distributed/src/remotecall.jl:619\n [6] top-level scope\n   @ ~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Distributed/src/macros.jl:95\n\n\n\nNote: more commonly you’ll be loading code from files or packages, and you’ll have a considerable amount of flexibility in controlling which processes load code. So if you have defined some functions, types, etc., you’d better organize them into files or packages, which will make things easier.\nConsider a file, DummyModule.jl, containing the following code:\n\nmodule DummyModule\nexport MyType, f\n\nmutable struct MyType\n    a::Int\nend\n\nf(x) = x^2 + 1\n\nprintln(\"DummyModule loaded\")\n\nend\n\nIn order to refer to the code defined in DummyModule.jl across all processes, first, DummyModule.jl needs to be loaded on every process. Calling include(\"DummyModule.jl\") loads it only on a single process. To load it on every process, use the @everywhere [procs()] expr macro, which execute an expression under Main on all procs:\n\n@everywhere include(\"DummyModule.jl\")\n@everywhere using InteractiveUtils\n\n@fetchfrom 2 InteractiveUtils.varinfo()  # show exported global variables in a module\n\nDummyModule loaded\n      From worker 2:    DummyModule loaded\n      From worker 3:    DummyModule loaded\n\n\n\n\n\nname\nsize\nsummary\n\n\n\n\nBase\n\nModule\n\n\nCore\n\nModule\n\n\nDistributed\n1.130 MiB\nModule\n\n\nDummyModule\n266.719 KiB\nModule\n\n\nMain\n\nModule\n\n\nr\n256 bytes\nFuture\n\n\n\n\n\nOnce loaded, we can use code defined in DummyModule.jl across all processes by:\n\n@everywhere using .DummyModule\n\n@fetchfrom 2 f(100)\n\n      From worker 2:    ┌ Warning: Cannot transfer global variable f; it already has a value.\n      From worker 2:    └ @ Distributed ~/softs/julia-1.10.4/share/julia/stdlib/v1.10/Distributed/src/clusterserialize.jl:166\n\n\n10001\n\n\nNote: a file can be preloaded on multiple processes at startup with the -L flag, and a driver script can be used to drive the computation: julia -p &lt;n&gt; -L file1.jl -L file2.jl driver.jl. The Julia process running the driver script given here has an id equal to 1, just like a process providing an interactive prompt.\nIf DummyModule.jl is a package, just use @everywhere using DummyModule, which will make code defined in DummyModule.jl available in every process.\n\nData availability\n\nSending messages and moving data constitute most of the overhead in a distributed program.\nReducing the number of messages and the amount of data sent is critical to achieving performance and scalability.\n\nGlobal variables\nExpressions executed remotely via @spawnat, or closures specified for remote execution using remotecall() may refer to global variables.\nRemote calls with embedded global references (under Main module only) manage globals as follows:\n\nNew global bindings are created on destination workers if they are referenced as part of remote call.\nGlobal constants are declared as constants on remote nodes too.\nGlobals are re-sent to a destination worker only in the context of a remote call, and only if its value has changed.\nThe cluster does not synchronize global bindings across nodes.\n\n\nNote: memory associated with globals may be collected when they are reassigned on the master, while no such action is taken on the workers as the bindings continue to be valid. clear!() can be used to manually reassign specific globals on remote nodes to nothing once they are no longer required.\nOnly when remote calls refer to globals under the Main module are new global bindings created on destination workers, so we can use let blocks to localize global variables when forming closures. This avoids new global bindings’ creating on destination workers:\n\nA = rand(10, 10)\nremotecall_fetch(() -&gt; A, 2)  # A is a global variable under the Main module, so new global binding of A will be created on process 2\n\nB = rand(10, 10)\nlet B = B  # B becomes a local variable, so B won't be created on process 2\n    remotecall_fetch(() -&gt; B, 2)\nend\n@fetchfrom 2 InteractiveUtils.varinfo()\n\n\n\n\nname\nsize\nsummary\n\n\n\n\nA\n840 bytes\n10×10 Matrix{Float64}\n\n\nBase\n\nModule\n\n\nCore\n\nModule\n\n\nDistributed\n1.137 MiB\nModule\n\n\nDummyModule\n267.550 KiB\nModule\n\n\nMain\n\nModule\n\n\nr\n256 bytes\nFuture\n\n\n\n\n\n\nCommunicating with RemoteChannels\nCreate references to remote channels with the following:\n\nRemoteChannel(f, pid)  # Create references to remote channels of a specific size and type. f is a function that when executed on pid (the default is the current process) must return an implementation of an AbstractChannel. e.g., RemoteChannel(() -&gt; Channel{Int}(10), pid).\nRemoteChannel(pid)  # make a reference to a Channel{Any}(1) on process pid\n\n\nA Channel is local to a process, but a RemoteChannel can put and take values across workers.\nA RemoteChannel can be thought of as a handle to a Channel.\nThe process id, pid, associated with a RemoteChannel identifies the process where the backing store, i.e., the backing Channel exists.\nAny process with a reference to a RemoteChannel can put and take items from the channel. Data is automatically sent to or retrieved from the process a RemoteChannel is associated with.\nSerializing a Channel also serializes any data present in the channel. Deserializing it therefore effectively makes a copy of the original object.\nOn the other hand, serializing a RemoteChannel only involves the serialization of an identifier that identifies the location and instance of Channel referred to by the handle. A deserialized RemoteChannel object on any worker, therefore also points to the same backing store as the original.\n\n\n\njobs = RemoteChannel(() -&gt; Channel{Int}(32))\nresults = RemoteChannel(() -&gt; Channel{Tuple}(32))\n\n@everywhere function do_work(jobs, results)  # define work function everywhere\n    while true\n        job_id = take!(jobs)\n        exec_time = rand()\n        sleep(exec_time)  # simulate elpased time doing actual work\n        put!(results, (job_id, exec_time, myid()))\n    end\nend\n\nfunction make_jobs(n)\n    for i in 1:n\n        put!(jobs, i)\n    end\nend\n\nn = 12\n\nerrormonitor(@async make_jobs(n))\n\nfor p in workers()\n    remote_do(do_work, p, jobs, results)\nend\n\n@elapsed while n &gt; 0\n    job_id, exec_time, where = take!(results)\n    println(\"$job_id finished in $(round(exec_time; digits = 2)) seconds on worker $where\")\n    global n = n - 1\nend\n\n2 finished in 0.32 seconds on worker 3\n1 finished in 0.68 seconds on worker 2\n4 finished in 0.32 seconds on worker 2\n5 finished in 0.14 seconds on worker 2\n3 finished in 0.61 seconds on worker 3\n7 finished in 0.05 seconds on worker 3\n8 finished in 0.05 seconds on worker 3\n9 finished in 0.24 seconds on worker 3\n10 finished in 0.11 seconds on worker 3\n11 finished in 0.35 seconds on worker 3\n6 finished in 0.96 seconds on worker 2\n12 finished in 0.47 seconds on worker 3\n\n\n2.68813445\n\n\n\n\n\n\n\n\nLocal invocations\n\n\n\nWhen data is stored on a different node from the execution node, data is necessarily copied over to the remote node for execution. However, when the destination node is the local node, i.e., the calling process id is the same as the remote node id, it is executed as a local call. It is usually (not always) executed in a different task, but there is no serialization/deserialization of data. Consequently, the call refers to the same object instances as passed, i.e., no copies are created.\n\nrc = RemoteChannel(() -&gt; Channel(3))  # RemoteChannel created on local node\n\nv = [0]  # array in Julia has stable memory address\n\nfor i in 1:3\n    v[1] = i  # reusing v\n    put!(rc, v)\nend\n\nres = [take!(rc) for _ in 1:3]\n\nprintln(res)\n\nprintln(map(objectid, res))\n\nprintln(\"Num unique obejcts: \", length(unique(map(objectid, res))))\n\n[[3], [3], [3]]\nUInt64[0xb396bdcb7eb46d7a, 0xb396bdcb7eb46d7a, 0xb396bdcb7eb46d7a]\nNum unique obejcts: 1\n\n\nIn general, this is not an issue. If the local node is also being used as a compute node, and the arguments used post the call, this behavior needs to be factored in and if required deep copies of arguments.\n\n\n\nShared arrays\n\nShared arrays use system shared memory to map the same array across many processes.\nEach “participating” process has access to the entire array, which is totally different from the DArray defined in DistributedArrays.jl, of which each process has local access to just a chunk (i.e., no two processes share the same chunk).\nA SharedArray defined in SharedArrays module is a good choice when you want to have a large amount of data jointly accessible to two or more processes on the same machine.\nIn cases where an algorithm insists on an Array input, the underlying array can be retrieved from a SharedArray by calling sdata(). For other AbstractArray types, sdata() just returns the object itself.\nThe constructor for a shared array is of the form: SharedArray{T, N}(dims::NTuple; init=false, pids=Int[]), by which we can construct an N-dimensional shared array of a bits type (check whether an element is supported using isbits()) T and size dims across the processes specified by pids. If an initialization function of the form f(S::SharedArray) is passed to init, then it is called on all the participating workers. You can specify that each worker runs the init function on a distinct portion of the array, thereby parallelizing initialization.\n\n@everywhere using SharedArrays\n\nS = SharedArray{Int, 2}((3, 4), init = S -&gt; S[localindices(S)] = repeat([myid()], length(localindices(S))))\n\n# localindices(S): return a range describing the \"default\" indices to be handled by the current process.\n# indexpids(S): return the current worker's index (starting from 1, not the same as the actual pid) in the list of workers mapping the SharedArray, or 0 if the SharedArray is not mapped onto the current process.\n# procs(S): return the list of pids mapping the SharedArray.\n\n3×4 SharedMatrix{Int64}:\n 2  2  3  3\n 2  2  3  3\n 2  2  3  3\n\n\nNote: because any process mapping the SharedArray has access to the entire array, you must take consideration on possible operation conflicts.\n\n\n2.14.3.4 Parallel loops and map\n\nLooping and then reducing\n\nMany iterations run independently over several processes, and then their results are combined using some function (the result of each iteration is taken as the value of the last expression inside the loop) . The combination process is called a reduction. In code, this typically looks like the pattern x = f(x, v[i]), where x is the accumulator, f is the reduction function, and v[i] are the elements being reduced. It is desirable for f to be associative, so that it does not matter what order the operations are performed in.\n\n# When reducer is given, it will be blocked and return the final result of reduction process.\n# @distributed [reducer] for var = range\n#     body\n# end\n\n# reducer is optional.\n# If it is omitted, then it will return a Task object immediately without waiting for completion.\n# You can prefix @sync or add wait(t) or fetch(t) (returns nothing) after it to wait for completion.\n # @sync @distributed for var = range\n #    body\n # end\n\nres = @distributed (vcat) for i in 1:6\n    [(myid(), i)]\nend\n\nres\n\n6-element Vector{Tuple{Int64, Int64}}:\n (2, 1)\n (2, 2)\n (2, 3)\n (3, 4)\n (3, 5)\n (3, 6)\n\n\n\nMapping\n\nIf we merely want to apply a function to all elements in some collection, we can use parallelized map, implemented in Julia as the pmap() function.\n\nusing LinearAlgebra\n\nM = Matrix{Float64}[rand(1000, 1000) for _ in 1:10]\npmap(svdvals, M)  # calculate the singular values of several matrices in parallel\n\n10-element Vector{Vector{Float64}}:\n [500.19591948127095, 18.177723709014206, 18.070046858489196, 17.968532776057664, 17.903479733510277, 17.80348575604172, 17.777976196783424, 17.723391519833193, 17.701261902442813, 17.618209581989433  …  0.1443501140707229, 0.11870883646175437, 0.1097846302552807, 0.0865123317029589, 0.08138553295320472, 0.06838300769246261, 0.05657426083786986, 0.03713916213962208, 0.0189889999840862, 0.0004138271343234121]\n [500.40550988149334, 17.991980218467212, 17.895227067676036, 17.834955911133672, 17.810199985906745, 17.793256966516985, 17.712249482574116, 17.660769908239395, 17.64261361907398, 17.625512862072267  …  0.13070210612219868, 0.11350645402365481, 0.08682756420033552, 0.0749659775082963, 0.07375957293968015, 0.07172163939436321, 0.0422095919949267, 0.027717976089603368, 0.020729023939328704, 0.007434832640593048]\n [499.9725216653124, 18.22881622507202, 18.05163441277596, 17.976781951935493, 17.934225456739853, 17.81628140994717, 17.727379436296765, 17.676226792075013, 17.64944992256773, 17.587003192189968  …  0.12555949214710216, 0.10771627898037246, 0.09812339132729837, 0.0832040634030236, 0.0795566631519147, 0.05771056471789384, 0.04146256456369192, 0.036514945295129775, 0.024173456653603143, 0.0019621940522431243]\n [500.724332259939, 18.172444500647327, 18.05893724324152, 17.977580732862496, 17.929983548159665, 17.809177695006902, 17.776643677110517, 17.731458727462186, 17.68708845107048, 17.58905663183363  …  0.15027946220726757, 0.1106767041403813, 0.10615565518280955, 0.101362094350808, 0.08553669093701075, 0.06606175947251856, 0.04859355947363102, 0.044716958081769335, 0.008765711994626764, 0.006905577124475283]\n [500.35320098673145, 18.17961900642624, 18.03720636581971, 17.969039989827394, 17.92888163391724, 17.792481670946792, 17.764990477397546, 17.684688355633785, 17.647425559773588, 17.568375081131357  …  0.14482736349318476, 0.13121160951369584, 0.12838466262962137, 0.10557557490513676, 0.08983232968870847, 0.07287636774373783, 0.03647525691999816, 0.027179423529931614, 0.0159452998577176, 0.007051797695311539]\n [500.29254692074187, 18.132066914160784, 18.014599760053674, 17.966742767780385, 17.901577660516082, 17.822005217516804, 17.780540847229776, 17.693033763351032, 17.617409512201437, 17.590614297635973  …  0.13655481404284014, 0.12128649898051894, 0.09932666861216487, 0.0933958715561772, 0.07868776680636735, 0.06386224732674027, 0.05818533672909265, 0.037539936210248065, 0.01541436707243011, 0.000593863363472274]\n [500.01644805903345, 18.16246193582335, 18.08842399105187, 17.9094443090554, 17.8444159901858, 17.776295476622558, 17.770511793747556, 17.729010790694947, 17.567038312117074, 17.539087204214916  …  0.14882458255053363, 0.13750049073314802, 0.11754172111257012, 0.08691837726630593, 0.07584729332290945, 0.06095792959055051, 0.05227263349705287, 0.04247805696904928, 0.03141195906005481, 0.013332427600273734]\n [500.0685371871959, 18.181938897080034, 18.124057908487156, 17.975067581324616, 17.92017821100634, 17.83973588443186, 17.81319224721688, 17.719882728188313, 17.680100128062747, 17.621698949491442  …  0.1282754525495913, 0.12298779049746486, 0.09652918661094274, 0.09073628803414234, 0.08836096135141609, 0.07234567177247235, 0.050890024773657956, 0.041884183786674606, 0.003706354884692974, 0.001115656495227806]\n [500.12631440508125, 18.1989017637818, 18.04043996660004, 17.948523069265576, 17.86407962733997, 17.830265678803396, 17.777113765852015, 17.704000278169335, 17.651821401075342, 17.566123546705086  …  0.13741409317602055, 0.1358532638289558, 0.1146295426908602, 0.07755682097346, 0.06301231681178131, 0.05015114789695217, 0.04748199505633011, 0.041299098276255025, 0.03056932143512753, 0.00671874725954981]\n [500.43455624373667, 18.174367859330932, 18.069044827687815, 17.994249471592102, 17.871420780990324, 17.816657504845406, 17.784041493287784, 17.73868285192251, 17.654119334996572, 17.625830610279742  …  0.12486655030472016, 0.11482492325635478, 0.1079888902752165, 0.09678078187760952, 0.08293693493480356, 0.07025954937565594, 0.05378456223040122, 0.03658517298542186, 0.02574330378551229, 0.017946780170500214]\n\n\n\n\n2.14.3.5 Noteworthy external parallel packages\nThere are also other packages implementing parallelism or providing data structures suitable for parallelism in Julia.\nIn addition, we have also several packages used for GPU programming in Julia.\n\n\n\n2.14.4 Running external programs\n\n2.14.4.1 Creating Cmd objects\nThere are two ways to create a Cmd objects:\n\nPut the command between backticks (`):\n\n\n`echo hello, world`\n\n\n`echo hello, world`\n\n\n\n\nUse Cmd() constructor:\n\n\nCmd(`echo hello, world`)  # from an existing Cmd\nCmd([\"echo\", \"hello, world\"])  # from a list of arguments\n\n\n`echo 'hello, world'`\n\n\n\nKeyword arguments of Cmd() allow you to specify several aspects of the Cmd’s execution environment.\nFor example, you can specify a working directory for the command via dir, setting execution environment variables via env, which can also be set by two helper functions setenv() and addenv().\n\n\n2.14.4.2 Running Cmd objects\nThe command is never run with a shell. Instead, Julia will do all of the following processes itself. In fact, the command is run as Julia’s immediate child process, using folk and exec calls.\nJulia provides several ways to run a Cmd object:\n\nrun():\n\n\nrun(`echo hello, world`)\n\nhello, world\n\n\n\nProcess(`echo hello, world`, ProcessExited(0))\n\n\n\n\nread():\n\n\nread(`echo hello, world`, String)  # run the command and return the resulting output as a `String`, or as an array of bytes if `String` is omitted\n\n\"hello, world\\n\"\n\n\nAs can be seen, the resulting string has a single trailing newline. You can use readchomp(), equivalent to chomp(read(x, String)) to remove it (chomp() can be used to remove a single trailing newline from a string).\n\nUse open() to read from or write to an external command:\n\n\n# writes go to the command's standard input (stdio = stdout)\nopen(`sort -n`, \"w\", stdout) do io\n    for i = 6:-1:1\n        println(io, i)\n    end\nend\n\n# reads from the command's standard output (stdio = stdin)\nopen(`echo \"hello, world\"`, \"r\", stdin) do io\n    readchomp(io)\nend\n\n1\n2\n3\n4\n5\n6\n\n\n\"hello, world\"\n\n\nNote: the program name and individual arguments in a command can be accessed and iterated over as if the command were an array of strings:\n\ncollect(`cut -f 1,3,5 test.txt`)\n\n4-element Vector{String}:\n \"cut\"\n \"-f\"\n \"1,3,5\"\n \"test.txt\"\n\n\n\n`cut -f 1,3,5 test.txt`[2]\n\n\"-f\"\n\n\n\n\n2.14.4.3 Command interpolation\nYou can use $ for interpolation much as you would in a string literal, and Julia will know when the inserted string needs to be quoted:\n\npath = \"/Volumes/External HD\"\nname = \"data\"\next = \"csv\"\n`sort $path/$name.$ext`  # due to the command is never interpreted by a shell, there's no need for actual quoting, which is only for presentation to the user\n\n\n`sort '/Volumes/External HD/data.csv'`\n\n\n\nIf you want to interpolate multiple words, just using an iterable container:\n\nfiles = [\"/etc/passwd\", \"/Volumes/External HD/data.csv\"]\n`grep foo $files`\n\n\n`grep foo /etc/passwd '/Volumes/External HD/data.csv'`\n\n\n\nIf you interpolate an array as part of a shell word, the shell’s Cartesian product generation is simulated:\n\nnames = [\"foo\", \"bar\", \"baz\"]\n`cat $names.txt`\n\n\n`cat foo.txt bar.txt baz.txt`\n\n\n\nSince you can interpolate literal arrays, no need to create temporary array objects first:\n\n`cat $[\"foo\", \"bar\"].$[\"png\", \"jpeg\"]`\n\n\n`cat foo.png foo.jpeg bar.png bar.jpeg`\n\n\n\n\n\n2.14.4.4 Quoting\nIf you just want to treat some special characters as is, then quote it with paired single quotes '', or quote it with paired double quotes \"\", which means that all characters within paired single quotes will have no special meanings, but some may have within paired double quotes:\n\n`cat '$file'`\n\n\n`cat '$file'`\n\n\n\n\nfile = \"text.txt\"\n`cat \"$file\"`\n\n\n`cat text.txt`\n\n\n\nAs can be seen, this mechanism used here is the same one as is used in shell, so you can just copy and paste a valid shell commands into here, and it will works properly.\n\n\n2.14.4.5 Pipelines\nShell metacharacters, such as |, &, and &gt;, need to be quoted (or escaped) inside of Julia’s backticks:\n\nrun(`echo hello \\| sort`)  # here, | is not a pipe, just a normal character\n\nhello | sort\n\n\n\nProcess(`echo hello '|' sort`, ProcessExited(0))\n\n\n\n\nUse pipeline() to construct a pipe:\n\n\nrun(pipeline(`cut -d : -f 3 /etc/passwd`, `head -n 6`, `sort -n`))\n\n0\n1\n2\n3\n4\n5\n\n\n\nBase.ProcessChain(Base.Process[Process(`cut -d : -f 3 /etc/passwd`, ProcessExited(0)), Process(`head -n 6`, ProcessExited(0)), Process(`sort -n`, ProcessExited(0))], Base.DevNull(), Base.DevNull(), Base.DevNull())\n\n\n\n\nRun multiple commands in parallel using &:\n\n\nrun(`echo hello` & `echo world` & `echo Tom`)  # the order of the output here is non-deterministic\n\nhello\nworld\nTom\n\n\n\nBase.ProcessChain(Base.Process[Process(`echo hello`, ProcessExited(0)), Process(`echo world`, ProcessExited(0)), Process(`echo Tom`, ProcessExited(0))], Base.DevNull(), Base.DevNull(), Base.DevNull())\n\n\n\nCombine both | and &:\n\nrun(pipeline(`echo world` & `echo hello`, `sort`))  # a single UNIX pipe is created and written to by both echo processes, and the other end of the pipe is read from by the sort command\n\nhello\nworld\n\n\n\nBase.ProcessChain(Base.Process[Process(`echo world`, ProcessExited(0)), Process(`echo hello`, ProcessExited(0)), Process(`sort`, ProcessExited(0))], Base.DevNull(), Base.DevNull(), Base.DevNull())\n\n\n\n\nproducer() = `awk 'BEGIN{for (i = 0; i &lt;= 6; i++) {print i; system(\"sleep 1\")}}'`\nconsumer(flag) = `awk '{print \"'$flag' \"$1; system(\"sleep 2\")}'`  # to make the interpolation $flag work, you have to put it between single quotes\nrun(pipeline(producer(), consumer(\"A\") & consumer(\"B\") & consumer(\"C\")))\n\nA 0\nB 1\nC 2\nA 3\nB 4\nC 5\nA 6\n\n\n\nBase.ProcessChain(Base.Process[Process(`awk 'BEGIN{for (i = 0; i &lt;= 6; i++) {print i; system(\"sleep 1\")}}'`, ProcessExited(0)), Process(`awk '{print \"A \"$1; system(\"sleep 2\")}'`, ProcessExited(0)), Process(`awk '{print \"B \"$1; system(\"sleep 2\")}'`, ProcessExited(0)), Process(`awk '{print \"C \"$1; system(\"sleep 2\")}'`, ProcessExited(0))], Base.DevNull(), Base.DevNull(), Base.DevNull())"
  },
  {
    "objectID": "posts/Programming/Julia/julia_syntax_basics/index.html#julia-documentation-system",
    "href": "posts/Programming/Julia/julia_syntax_basics/index.html#julia-documentation-system",
    "title": "Julia syntax basics",
    "section": "3 Julia documentation system",
    "text": "3 Julia documentation system\n\n\"Store propellant for a rocket\"\nabstract type OhTank end\n\n\"\"\"\n    total(t::OhTank) -&gt; Float64\n\nMass of propellant tank `t` when it is full.\n\"\"\"\nfunction totalmass end\n\ntotalmass\n\n\nThe Julia documentation system works by prefixing a function or type definition with a regular Julia text string, quoted by double or triple quotes. This is totally different from a comment with the # symbol. Comments don’t get stored in the Julia help system.\nInside this text string, you can document your function or type definition using markdown syntax."
  },
  {
    "objectID": "posts/Programming/Julia/julia_syntax_basics/index.html#modules-and-pakcages",
    "href": "posts/Programming/Julia/julia_syntax_basics/index.html#modules-and-pakcages",
    "title": "Julia syntax basics",
    "section": "4 Modules and Pakcages",
    "text": "4 Modules and Pakcages\nThe core Julia language imposes very little; many functions are extended by modules and packages.\nJulia code is organized into files, modules, and packages. Files containing Julia code use the .jl file extension.\n\n4.1 Modules\nModules help organize code into coherent units. They are delimited syntactically inside module &lt;NameOfModule&gt; ... end, and have the following features:\n\nModules are separate namespaces, each introducing a new global scope. This allows the same name to be used for different functions or global variables without conflict, as long as they are in separate modules.\nModules have facilities for detailed namespace management: each defines a set of names it exports, and can import names from other modules with using and import.\nModules can be precompiled for faster loading, and may contain code for runtime initialization.\n\nModule definition:\n\nmodule &lt;NameOfModule&gt;\n\n# using, import, export statements are usually here\n\ninclude(\"file1.jl\")\ninclude(\"file2.jl\")\n\nend\n\n\n\n\n\n\n\nNote\n\n\n\n\nFiles and file names are mostly unrelated to modules, since modules are associated only with module expression. One can have multiple files per module, and multiple modules per file.\ninclude behaves as if the contents of the source file were evaluated in the global scope of the including module.\nThe recommended style is not to indent the body of the module. It is also common to use UpperCamelCase for module names, and use the plural form if applicable.\n\n\n\n\n4.1.1 Namespace management\nNamespace management refers to the facilities the language offers for making names in a module available in other modules.\n\n4.1.1.1 Qualified names\nNames for functions, variables, and types in the global scope always belong to a module, called the parent module. One can use parentmodule() to find the parent module of a name.\nOne can also refer to those names outside their parent module by prefixing them with their module name, e.g. Base.UnitRange. This is called a qualified name.\nThe parent module may be accessible using a chain of submodules like Base.Math.sin, where Base.Main is called the module path.\nDue to syntactic ambiguities, qualifying a name that contains only symbols, such as an operator, requires inserting a colon, e.g. Base.:+. A small number of operators additionally require parentheses, e.g. Base.:(==).\n\n\n4.1.1.2 Export lists\nNames can be added to the export list of a module with export: these are symbols that are imported when using the module.\n\nmodule NiceStuff\n\nexport nice, DOG\n\n# definitions of nice and DOG\n\nend\n\nIn fact, a module can have multiple export statements in arbitrary locations.\n\n\n4.1.1.3 using and import\n\nusing: brings the module name and the elements of the export list into the surrounding global namespace.\nimport: brings only the module name into scope.\n\n\n\n\n\n\n\nNote\n\n\n\n\nTo load a module from a locally defined module, a dot needs to be added before the module name like using .ModuleName.\nOne can specify which identifiers to be loaded in a module, e.g., using .NiceStuff: nice, DOG.\nRenaming imported identifiers with as.\n\n\nimport CSV as C  # This only works with import\nimport CSV: read as rd\nusing CSV: read as rd\n\n\n\n\n\n\n4.1.2 How does Julia find a module\n\nJulia looks for module files in directories defined in the LOAD_PATH variable:\n\n\nLOAD_PATH\n\n3-element Vector{String}:\n \"@\"\n \"@v#.#\"\n \"@stdlib\"\n\n\n\nTo make it look in other places, add some more using push!():\n\n\npush!(LOAD_PATH, \"/path/to/my/julia/projects\")\n\n4-element Vector{String}:\n \"@\"\n \"@v#.#\"\n \"@stdlib\"\n \"/path/to/my/julia/projects\"\n\n\n\n\n\n\n\n\nNote\n\n\n\nTo avoid doing this every time you run Julia, put this line into your startup file ~/.julia/config/startup.jl, which runs each time you start an interactive Julia session.\n\n\n\nJulia looks for files in those directories in the form of a package with the structure: ModuleName/src/file.jl.\nOr, if not in package form, it will look for a filename that matches the name of your module.\n\n\n\n\n4.2 Standard modules\nThere are three most important modules:\n\nCore\n\nCore contains all identifiers considered “built in” to the language, i.e. part of the core language and not libraries.\nEevery module implicitly specifies using Core, since you cannot do anything without these definitions.\n\nBase\n\nBase contains basic functionality.\nAll modules implicitly contain using Base.\n\nMain\n\nMain is the top-level module, and Julia starts with Main set as the current module.\nVariables defined at the prompt go in Main, and varinfo() lists variables in Main.\n\n\n4.3 Packages\nJulia uses git for organizing and controlling packages.\nBy convention, all packages are stored in git repositories.\n\n\n4.4 Organizing your code into modules and packages\n\n4.4.1 Setting up your working environment\nIn Julia, different environments can have totally different packages and versions installed from another environment.\nThis makes it possible that you can construct an environment tailored to your project, which makes your project completely reproducible.\n\n## Make the job directory in the shell mode\nshell&gt; mkdir job\n\n## Activate the job environment in the package mode\n(@v1.10) pkg&gt; activate job\n  Activating new project at `~/temp/job`\n\n## Add packages into the job environment\n(job) pkg&gt; add CairoMakie ElectronDisplay\n\n## Check what packages are added into the job environment\n(job) pkg&gt; status\nStatus `~/temp/job/Project.toml`\n  [13f3f980] CairoMakie v0.11.5\n  [d872a56f] ElectronDisplay v1.0.1\n\n## Julia adds packages into the job environment by adding information of packages into the following two files of the job environment:\n# 1. Project.toml: specifies what packages are added to this environment\n\nshell&gt; cat Project.toml\n[deps]\nCairoMakie = \"13f3f980-e62b-5c42-98c6-ff1f3baf88f0\"  # The string is the universally unique identifier (UUID) of the CairoMakie package, which allows you to install different packages with the same package name. If there was another CairoMakie package, you should add this one with the command: add CairoMakie=13f3f980-e62b-5c42-98c6-ff1f3baf88f0\nElectronDisplay = \"d872a56f-244b-5cc9-b574-2017b5b909a8\"\n\n# 2. Manifest.toml: specifies the information of packages which those packages we just installed depend on\n\nshell&gt; head Manifest.toml\n# This file is machine-generated - editing it directly is not advised\n\njulia_version = \"1.10.0\"\nmanifest_format = \"2.0\"\nproject_hash = \"666c5e651c78c84e1125a572f7fba0bc8b920e62\"\n\n[[deps.AbstractFFTs]]\ndeps = [\"LinearAlgebra\"]\ngit-tree-sha1 = \"d92ad398961a3ed262d8bf04a1a2b8340f915fef\"\nuuid = \"621f4979-c628-5d54-868e-fcf4e3e8185c\"\nversion = \"1.5.0\"\nweakdeps = [\"ChainRulesCore\", \"Test\"]\n\n    [deps.AbstractFFTs.extensions]\n    AbstractFFTsChainRulesCoreExt = \"ChainRulesCore\"\n    AbstractFFTsTestExt = \"Test\"\n\n[[deps.AbstractLattices]]\ngit-tree-sha1 = \"222ee9e50b98f51b5d78feb93dd928880df35f06\"\nuuid = \"398f06c4-4d28-53ec-89ca-5b2656b7603d\"\nversion = \"0.3.0\"\n\nThese two files (Project.toml and Manifest.toml) are automatically created by Julia.\n\n\n4.4.2 Creating your own module and package\n\nshell&gt; cd job\n/home/yangrui/temp/job\n\nshell&gt; tree\n.\n├── Manifest.toml\n└── Project.toml\n\n0 directories, 2 files\n\n## Create a package scaffolding with the `generate` command in the package mode\n# You can also use the PkgTemplate library to create peackages with a more sophisticated way\n(job) pkg&gt; generate ToyPackage\n  Generating  project ToyPackage:\n    ToyPackage/Project.toml\n    ToyPackage/src/ToyPackage.jl\n\nshell&gt; tree\n.\n├── Manifest.toml\n├── Project.toml\n└── ToyPackage\n    ├── Project.toml  # In fact, Julia package is also an environment, which means you can add other packages it depends on\n    └── src\n        └── ToyPackage.jl  # This file contains the top-level module having the same name as the package\n\n2 directories, 4 files\n\nshell&gt; cat ToyPackage/src/ToyPackage.jl\nmodule ToyPackage  # You can now add code into this module (e.g. import names from other packages by using the `using` and `import` statements; specify what names should be exported by using the `export` statement; include other .jl files by using the `include()` function; you can also directly define variables, functions, types here)\n\ngreet() = print(\"Hello World!\")\n\nend # module ToyPackage\n\n## To make packages you are developing available when importing them by using the `using` and `import` statements, you can use the `dev` command to add your package info into the metadata files of the job environment\n(@v1.10) pkg&gt; activate job\n  Activating new project at `~/temp/job/job`\n\nshell&gt; ls\nManifest.toml  Project.toml  ToyPackage\n\n(job) pkg&gt; dev ./ToyPackage\n   Resolving package versions...\n    Updating `~/temp/job/job/Project.toml`\n  [0bc4f551] + ToyPackage v0.1.0 `../ToyPackage`\n    Updating `~/temp/job/job/Manifest.toml`\n  [0bc4f551] + ToyPackage v0.1.0 `../ToyPackage`\n\n(job) pkg&gt; status\nStatus `~/temp/job/job/Project.toml`\n  [0bc4f551] ToyPackage v0.1.0 `../ToyPackage`\n\nTwo packages are very useful when modifying and developing packages:\n\nOhMyREPL: provides syntax highlighting and history matching in the Julia REPL;\nRevise: monitors code changes to packages loaded into the REPL and updates the REPL with these changes.\n\n\n\n4.4.3 Testing your package\nYou can use the Test package to test your package.\n\n## In the ToyPackage/test/runtests.jl  # This is essential\nusing ToyPackage\nusing Test\n\n# Each test is contained in this block\n@testset \"All tests\" begin\n    include(\"trigtests.jl\")\nend\n\n## In the ToyPackage/test/trigtests.jl  # This is not essential if you write all tests into the above file\n@testset \"trigonometric tests\" begin\n    @test cos(0) = 1.0  # Each test starts with the macro @test. For floating-point numbers, the results may be not exactly identical, so you can use the ≈ (\\approx) or use the isapprox() function to specify the tolerance\n    @test sin(0) = 0.0\nend\n\n@testset \"polynomial tests\" begin\n    # Some more tests\nend\n\n## Test your package with the `test` command in the package mode\n(job) pkg&gt; activate ToyPackage  # Of course, this is not essential. You can test the ToyPackage package in any enviroment which knows where this package is (e.g. in the job environment)\n  Activating project at `~/temp/job/ToyPackage`\n\n(ToyPackage) pkg&gt; test ToyPackage  # If you are in the ToyPackage environment, only use the `test` command without the package name is fine"
  },
  {
    "objectID": "posts/Programming/Julia/julia_syntax_basics/index.html#appendices",
    "href": "posts/Programming/Julia/julia_syntax_basics/index.html#appendices",
    "title": "Julia syntax basics",
    "section": "5 Appendices",
    "text": "5 Appendices\n\n5.1 Heap and Stack\nHeap and stack are two important regions in computer memory used for storing data.\nThere are some differences between heap and stack:\n\nHeap: the heap is a larger memory area that is manually requested and released by the programmer or the memory manager of a programming language. Memory allocation on the heap is more flexible and can be dynamically adjusted according to the needs of the program. However, since it requires tracking all allocated and released memory blocks, heap management is usually more complex and slower than stack management. The heap is used to store objects whose size and lifetime are uncertain, such as dynamic arrays, object instances, etc.\nStack: the stack is a memory area managed automatically by the operating system or runtime environment. It follows the Last In, First Out (LIFO) principle, meaning the last element entered is the first one to be removed. Memory allocation and deallocation on the stack are very fast because these operations only involve moving pointers, without the need for complex memory management algorithms. The stack is typically used to store local variables and context information for function calls.\n\nJulia stores mutable data types in heap, and immutable data types in stack, which means the memory address pointed to an immutable value, such as an integer, may be unstable (changed often). So In Julia, you can only reliably get the memory address of mutable data by the follows:\n\na = [1, 2, 3, 4, 5, 6]\n\np = pointer_from_objref(a)  # get the memory address of a Julia object as a Ptr (Ptr{T} means a memory address referring to data of type T)\nprintln(p)\n\nx = unsafe_pointer_to_objref(p)  # convert a Ptr to an object reference (assuming the pointer refers to a valid heap-allocated Julia object)\nprintln(x)\n\n# ===/≡ is used to judge whether two objects are identical:\n# first the types of the two are compared\n# then mutable objects are compared by memory address\n# and immutable objects are compared by contents at the bit level\nprintln(a === x)\n\n# if x === y then objectid(x) == objectid(y)\n\n# == is used to compare whether the contents of the two obejcts are identical though other properties may also be taken into account\nx = 1 # Int64\ny = 1.0  # Float64\nprintln(x === y)\nprintln(x == y)\n\nPtr{Nothing} @0x00007fef1b0cf260\n[1, 2, 3, 4, 5, 6]\ntrue\nfalse\ntrue\n\n\n\n\n5.2 Julia installation and configuration\n\nSetting some environmental variables globally and permanently\n\nCreating a ~/.julia/config/startup.jl file with the contents:\n\n# Customizing package server\nENV[\"JULIA_PKG_SERVER\"] = \"https://mirrors.pku.edu.cn/julia\"\n\n# Customizing https proxy\nENV[\"https_proxy\"] = \"http://127.0.0.1:10809\"\n\n\n\n5.3 Julia REPL mode\n\njulia&gt;: the standard Julia mode.\nhelp?&gt;: the help mode. Enter help mode by pressing ?.\npkg&gt;: the package mode for installing and removing packages. Enter package mode by pressing ].\nshell&gt;: the shell mode. Enter shell mode by pressing ;.\n\nTo back to the standard Julia mode, press Backspace.\n\n\n5.4 Installing third-party packages\nPkg is Julia’s builtin package manager, which can be used to install, update, and remove packages.\nYou can install packages either by calling Pkg functions in the standard Julia mode or by executing Pkg commands in the package mode.\n\nIn the package mode:\n\n\n# To install packages (multiple packages are separated by comma or space), use add\n(@v1.9) pkg&gt; add JSON, StaticArrays\n\n# To install packages with specified versions using the @ symbol\n(@v1.9) pkg&gt; add CairoMakie@0.5.10\n\n# To remove packages, use rm or remove (some Pkg REPL commands have a short and a long version of the command)\n(@v1.9) pkg&gt; rm JSON, StaticArrays\n\n# To update packages, use up or update\n(@v1.9) pkg&gt; up\n\n# To see installed packages, use st or status\n(@v1.9) pkg&gt; st\n\n\n\n\n\n\n\nNote\n\n\n\nIn the REPL prompt, (@v1.9) lets you know that v1.9 is the active environment.\nDifferent environments can have totally different packages and versions installed from another environment.\nThis makes it possible that you can construct an environment tailored to your project, which makes your project completely reproducible.\n\n\n\nIn the standard Julia mode\n\n\njulia&gt; Pkg.add([\"JSON\", \"StaticArrays\"])\n\n# Pkg.remove()\n# Pkg.update()\n# Pkg.status()"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Computer",
    "section": "",
    "text": "Here is a collection of blogs related to computer, such as Linux, Git, R, Julia, etc.\nEmail: 2413667864@qq.com"
  }
]